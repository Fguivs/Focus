import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
  import { 
    getFirestore, doc, setDoc, getDoc, collection, getDocs, updateDoc, deleteDoc, 
    increment, writeBatch, query, where, onSnapshot, runTransaction, deleteField, orderBy, arrayUnion,
	addDoc, limit
  } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-firestore.js";
   import { GoogleGenerativeAI } from "https://esm.run/@google/generative-ai";

  const firebaseConfig = {
    apiKey: "AIzaSyDoncRn8ikIdij8aXC0OUeqdqnLITrhmPc",
    authDomain: "foco-diario-75630.firebaseapp.com",
    projectId: "foco-diario-75630",
    storageBucket: "foco-diario-75630.appspot.com",
    messagingSenderId: "1040579676771",
    appId: "1:1040579676771:web:ca12f964d8adb3778e4656"
  };

  const app = initializeApp(firebaseConfig);
  const db = getFirestore(app);
  
  // --- Vari√°veis Globais para Medalhas de Honra ---
let todasMedalhasHonra = []; // Cache para guardar as medalhas da loja
let medalhasInventarioCache = {}; // Cache para o invent√°rio de medalhas dos membros { membroId: [medalhaId1, ...] }
let medalhasOrdemCache = {}; // Cache para a ordem de exibi√ß√£o { membroId: [medalhaId1, ...] }
let medalhasDesejadasCache = {}; // Cache para a lista de desejos { medalhaId: [membroId1, ...] }

let fluxoNotificacaoFoco = false; // Trava para controlar o fluxo Foco -> Notifica√ß√£o

// --- Vari√°veis da Loteria ---
let numerosSelecionadosAposta = [];
let dadosLoteria = { 
  premioAcumulado: 0, 
  edicao: 0, 
  ano: 2025, 
  totalApostas: 0,
  historico: [] 
};
let minhasApostasEdicao = 0; // Contador de apostas do usu√°rio
const CUSTO_APOSTA = 100; // Alterado para 100
const LIMITE_APOSTAS_POR_EDICAO = 6;

// --- Vari√°veis do Mapa ---
let mapaEpicos = null;
let marcadoresMapa = [];

let timeOffset = 0;

let carrosselMedalhasInterval;
let carrosselMedalhasPausado = false;
let progressoBarraMedalhas;
let currentCarrosselMedalhasIndex = 0;
let totalSlidesMedalhas = 0;

// --- Vari√°veis Globais para a Lojinha de Poderes ---
let todosPoderesInfo = []; // Guarda a defini√ß√£o est√°tica dos poderes (nome, pre√ßo, etc.)
let statusPoderesAtivos = []; // Cache para efeitos ativos (ex: imunidade, soft_block)
let historicoPoderesSemana = {}; // Cache para limites de compra da semana atual
let poderParaComprar = null; // Guarda o objeto do poder sendo comprado
let equipeAlvoParaPoder = null; // Guarda a equipe alvo de um poder
let comprandoPoder = false;
// --- FIM das Vari√°veis da Lojinha de Poderes ---

// --- Vari√°veis para Recompensa e Prote√ß√£o ---
window.tempoEsperaRecompensa = 30; // 30 segundos (ALTERADO)
let timerRecompensaInterval = null;

function iniciarTimerRecompensa() {
    if (dailyClaimedToday) return; // Se j√° resgatou, n√£o precisa contar

    if (timerRecompensaInterval) clearInterval(timerRecompensaInterval);
    
    // Reseta o tempo se recarregar a p√°gina (for√ßa a ficar)
    window.tempoEsperaRecompensa = 30; // (ALTERADO)
    
    timerRecompensaInterval = setInterval(() => {
        window.tempoEsperaRecompensa--;
        
        // Atualiza o texto do bot√£o em tempo real se ele existir
        const btn = document.getElementById('btn-resgatar-diario');
        if (btn && !dailyClaimedToday) {
            if (window.tempoEsperaRecompensa > 0) {
                btn.textContent = `Aguarde... (${window.tempoEsperaRecompensa}s)`;
            } else {
                // Tempo acabou, libera o bot√£o
                atualizarInterfaceRecompensa(); 
                clearInterval(timerRecompensaInterval);
            }
        }
        
        if (window.tempoEsperaRecompensa <= 0) {
            clearInterval(timerRecompensaInterval);
        }
    }, 1000);
}

// --- Vari√°veis da Recompensa Di√°ria ---
const NIVEIS_RECOMPENSA = [
  { min: 0, max: 9, valor: 50, cor: "#3498db", textoCor: "#fff" }, // Azul
  { min: 10, max: 19, valor: 100, cor: "#2ecc71", textoCor: "#fff" }, // Verde
  { min: 20, max: 29, valor: 200, cor: "#f1c40f", textoCor: "#333" }, // Amarelo
  { min: 30, max: 39, valor: 300, cor: "#e67e22", textoCor: "#fff" }, // Laranja
  { min: 40, max: 49, valor: 400, cor: "#e74c3c", textoCor: "#fff" }, // Vermelho
  { min: 50, max: 59, valor: 500, cor: "#9b59b6", textoCor: "#fff" }, // Roxo
  { min: 60, max: 69, valor: 600, cor: "#ff7979", textoCor: "#fff" }, // Rosa Salm√£o
  { min: 70, max: 79, valor: 700, cor: "#00cec9", textoCor: "#fff" }, // Verde √Ågua
  { min: 80, max: 89, valor: 800, cor: "#006400", textoCor: "#fff" }, // Verde escuro
  { min: 90, max: 99, valor: 900, cor: "#000000", textoCor: "#fff" }, // N√≠vel 10: Preto "Black Card" (Destaque total do Amarelo)
  { min: 100, max: 99999, valor: 1000, cor: "#ff007f", textoCor: "#fff" } // Magenta Neon
];

function getNivelRecompensa(streak) {
  // Encontra o n√≠vel onde o streak atual se encaixa (entre min e max)
  const nivel = NIVEIS_RECOMPENSA.find(n => streak >= n.min && streak <= n.max);
  // Se por algum motivo n√£o achar (ex: streak negativo), retorna o n√≠vel 1
  return nivel || NIVEIS_RECOMPENSA[0];
}

let dailyStreakGlobal = 0;
let dailyClaimedToday = false;

// --- Vari√°veis Globais para o Hall da Fama ---
let hallDaFamaCache = [];
let carrosselHallDaFamaInterval;
let carrosselHallDaFamaPausado = false;
let progressoBarraHallDaFama;
let currentCarrosselHallDaFamaIndex = 0;
let totalSlidesHallDaFama = 0;
const ANO_ATUAL = new Date().getFullYear();
// --- FIM das Vari√°veis do Hall da Fama ---

// COLE ESTE NOVO BLOCO
// --- Vari√°veis para o Banco das Equipes ---
let saldosBancosEquipes = { abelha: 0, joaninha: 0, vagalume: 0 };
let unsubscribeBancosListener = null;
let estatisticasJurosCache = [];
let estatisticasContribuidoresCache = {};
// --- FIM DO NOVO BLOCO ---

// Para o carrossel interno de cada membro
let carrosseisInternosMedalhasState = {}; // Guarda a p√°gina atual de cada membro { membroId: 0 }

// Para o modal de ordena√ß√£o
let membroParaOrdenarMedalhas = null;
let ordemMedalhasTemporaria = [];

// Para o modal de compra
let medalhaParaComprarInfo = null;
let membroParaReceberMedalha = null;

// Constantes
const MEDALHAS_POR_PAGINA = 6;
// --- Fim das Vari√°veis de Medalhas de Honra ---
  
  // Configurar fuso hor√°rio para Bras√≠lia
Date.prototype.getBrasiliaHours = function() {
  const offset = this.getTimezoneOffset() + 180; // UTC-3 (Bras√≠lia)
  return (this.getHours() + Math.floor(offset / 60)) % 24;
};
  
  // Vari√°veis atualizadas para membros din√¢micos
  let streaksCache = {};
  let todosMembros = [];
  let equipes = {
    abelha: { membros: [], lider: null },
    joaninha: { membros: [], lider: null },
    vagalume: { membros: [], lider: null }
  };
  let liderGeral = null;
  
  const nomesEquipesCapitalizados = {
    abelha: 'Abelha',
    joaninha: 'Joaninha',
    vagalume: 'Vaga-lume'
  };
  
  let currentUser = null;
  let userRole = null;
  let userTeam = null;
  
  let analiseOraculoPendente = null;
  
  // Adicione estas novas vari√°veis no in√≠cio do seu script
let carrosselDesenhoInterval;
let carrosselDesenhoPausado = false;
let progressoBarraDesenho;
let currentCarrosselDesenhoIndex = 0;
let activeDrawingTeam = null; // Guarda qual tela de equipe est√° ativa no modal
let drawingContexts = {};

// --- Vari√°veis Globais para o Pix dos √âpicos ---
let pixDestinatarios = [];
let pixValor = 0;
let pixComentario = '';

let enviosDiariosRealizados = {};

// --- Vari√°veis Globais do Chat ---
let genAI;
let baseDeConhecimentoTexto = '';
let historicoConversaIA = [];
let feedEventosCache = [];

// --- Vari√°veis para Rota√ß√£o de API (Gemini) ---
let listaChavesGlobal = []; // Armazena todas as chaves carregadas
let indiceChaveAtual = 0;   // Controla qual chave est√° em uso

let enviandoMoedas = false;

let aguardandoConfirmacaoNotificacao = false;
let dadosNotificacaoPendente = null;
  
  // Vari√°veis para controle do carrossel
  let currentCarrosselIndex = 0;
  let carrosselInterval;
  let carrosselPausado = false;
  let progressoBarra;
  
  let maintenanceClickCount = 0;
let maintenanceClickTimer = null;
  
  let totalSlides = 0;
  
  let isUpdatingTop5Feed = false;
  
  let membroParaExpulsar = null;
  
  let isPasswordResetFlow = false;
  
  let recompensasConfig = {};
  let isTestModeActive = false;
let currentTestGameIndex = null;
let ordemJogosConfigurada = [];

  const medalhas = {
    3: { emoji: "üî•", nome: "Fagulha" },
    10: { emoji: "üëë", nome: "Lenda" },
    30: { emoji: "üåü", nome: "Constante" },
    60: { emoji: "üíé", nome: "Diamante" },
    120: { emoji: "üöÄ", nome: "Foguete" },
    150: { emoji: "üèÜ", nome: "Trof√©u" },
    240: { emoji: "üîÆ", nome: "Bola de cristal" },
    365: { emoji: "üåû", nome: "Solar" },
	550: { emoji: "üêâ", nome: "M√≠tico" },
  730: { emoji: "üéÉ", nome: "Horripilante" },
  900: { emoji: "üí£", nome: "Poder Destrutivo" },
  1100: { emoji: "üòá", nome: "Angelical" },
  1460: { emoji: "üí†", nome: "Primordial" },
  1825: { emoji: "‚ôæÔ∏è", nome: "Eterno" }
  };
  const totalDiasMembros = {};
  const pontosSemanais = { abelha: 0, joaninha: 0, vagalume: 0 };
  const rankingGeral = { abelha: 0, joaninha: 0, vagalume: 0 };
  const historicoAcoes = {};
  
  // Vari√°vel de controle para evitar duplica√ß√£o
  let atualizando = false;
  
  // Vari√°vel para acompanhar a data atual
  let dataAtual = '';
  
  // Sistema de fila para atualiza√ß√µes r√°pidas
  let filaAtualizacao = Promise.resolve();
  
// Vari√°veis globais para o novo sistema de popup
let popupQueue = [];
let isPopupShowing = false;
let unsubscribeNotificacoes = null;

// --- NOVA FILA PARA OS CARDS POPUPS (CENTRAIS) ---
let cardPopupQueue = []; // Fila para os modais grandes
let isCardPopupShowing = false; // Controle para n√£o sobrepor
  
  // Vari√°veis para controle do painel secreto
  let cliqueCount = 0;
  let timeoutClique;
  
  let initialDistance = null;
let isPinching = false;
  
  let composerSelectedColor = '#CAFFBF'; // Cor padr√£o
let composerTimestampInterval = null;
let composerEditMode = false;
let editingMessageId = null;
let messageIdToDelete = null;
let unsubscribeViewerListener = null; 

// --- Vari√°veis para o sistema de Men√ß√µes ---
let isMentioning = false;
let mentionQuery = '';
let mentionStartIndex = -1;
let activeSuggestionIndex = -1;
let mentionTextarea = null;
let currentMentionRange = null;

// --- 1. Vari√°veis Globais para o Sistema de Avatar ---
let todosOsItensAvatar = []; // Cache para guardar os itens da loja
let inventarioAvatarCache = []; // Cache para o invent√°rio do usu√°rio
let avatarTemporario = {}; // Guarda as edi√ß√µes antes de salvar
let avatarOriginal = {}; // ADICIONE ESTA LINHA
let unsubscribeAvatarListener = null; // NOVO: Para controlar o listener

const nomesCategorias = {
    corpo: 'Tons de peles',
    rosto: 'Express√µes',
    cabelo: 'Cabelos',
    roupa: 'Roupas',
    acessorio: 'Acess√≥rios',
    enfeite_de_parede: 'Itens Raros e Exclusivos', // NOVO
    fundo: 'Fundos'
};

const nomesSubcategorias = {
    chapeu: 'Chap√©u',
    oculos: '√ìculos',
    colar: 'Acess√≥rio de pesco√ßo',
    bolsa: 'Bolsa',
    outros: 'Outros'
};

// NOVAS VARI√ÅVEIS PARA GERENCIAR COMENT√ÅRIOS
let editingCommentId = null;
let commentIdToDelete = null;
let messageIdForCommentAction = null;

let checkboxLocks = {};
let folgasManualmenteRemovidas = {};
  
  // Vari√°veis para autentica√ß√£o
  let authContainer, mainContent, logoutBtn;
  let loginForm, changePasswordForm, forgotPasswordForm, secretQuestionForm;
  let loginBtn, loginUsernameInput, loginPasswordInput;
  
  let currentUserRole = 'membro'; // Inicializa com o papel padr√£o 'membro'
  let currentUserTeam = null; // Inicializa com a equipe padr√£o null
  let memberIdToRemove = null;
  
  let lastRefreshTimestamp = null;
  let officialAppVersion = null;
  const EMOJIS_MURAL = ['üëç', 'üíñ', 'üòÇ', 'üéâ', 'üî•', 'üòÆ', 'üò≠', 'üò°'];
  

  // Fun√ß√£o MESTRE de tempo: Retorna a data corrigida pelo servidor/API
  function getHoje() {
    // Pega o tempo do dispositivo e soma a diferen√ßa calculada na sincroniza√ß√£o
    return new Date(Date.now() + timeOffset);
  }

async function sincronizarHorarioBrasilia() {
  console.log("‚è≥ Sincronizando rel√≥gio com Bras√≠lia...");

  // Fun√ß√£o auxiliar para tentar uma URL com repeti√ß√µes (retries)
  const tentarBuscar = async (url, tentativasMaximas) => {
    for (let i = 1; i <= tentativasMaximas; i++) {
      try {
        // Adiciona timestamp (?t=...) para evitar que o navegador use cache antigo
        const response = await fetch(url + `?t=${Date.now()}`); 
        if (response.ok) {
            return await response.json();
        }
      } catch (erro) {
        console.warn(`‚ö†Ô∏è Tentativa ${i} falhou para ${url}.`);
        if (i < tentativasMaximas) {
            // Espera 1 segundo antes de tentar de novo
            await new Promise(resolve => setTimeout(resolve, 1000));
        }
      }
    }
    throw new Error(`Falha ap√≥s ${tentativasMaximas} tentativas.`);
  };

  try {
    // --- TENTATIVA PRINCIPAL: WorldTimeAPI (5 tentativas) ---
    // Insiste 5 vezes antes de desistir (ALTERADO AQUI)
    const data = await tentarBuscar("https://worldtimeapi.org/api/timezone/America/Sao_Paulo", 5);
    
    const serverTime = new Date(data.datetime).getTime();
    const localTime = Date.now();
    timeOffset = serverTime - localTime;
    
    console.log(`‚úÖ Rel√≥gio Sincronizado (WorldTimeAPI)! Compensa√ß√£o: ${timeOffset}ms`);

  } catch (erro) {
    // --- PLANO B: MATEM√ÅTICA (√öltimo recurso se a API falhar 5x) ---
    console.error("‚ùå WorldTimeAPI falhou todas as tentativas. Usando c√°lculo de fuso hor√°rio local.");
    
    const agora = new Date();
    // Pega o hor√°rio UTC (Tempo Universal) baseando-se no deslocamento do navegador
    const utc = agora.getTime() + (agora.getTimezoneOffset() * 60000);
    
    // For√ßa o hor√°rio para UTC-3 (Bras√≠lia) matematicamente
    // -3 horas = -10800000 ms
    const brasiliaEstimado = utc - 10800000; 
    
    timeOffset = brasiliaEstimado - agora.getTime();
    
    console.log(`‚ö†Ô∏è Rel√≥gio Ajustado Matematicamente (For√ßando UTC-3): Compensa√ß√£o: ${timeOffset}ms`);
    
    // Alerta de seguran√ßa se a data do celular estiver absurdamente errada (ex: ano 2023)
    if (new Date(brasiliaEstimado).getFullYear() < 2024) {
         alert("‚ö†Ô∏è Aten√ß√£o: N√£o conseguimos conectar ao servidor de hora e a data do seu celular parece estar errada. Por favor, verifique seu rel√≥gio para evitar erros.");
    }
  }
}

  // O getHojeISO usa o getHoje(), ent√£o ele se corrige automaticamente!
  function getHojeISO() {
    const hoje = getHoje(); // J√° retorna a data corrigida
    const ano = hoje.getFullYear();
    const mes = String(hoje.getMonth() + 1).padStart(2, '0');
    const dia = String(hoje.getDate()).padStart(2, '0');
    return `${ano}-${mes}-${dia}`;
  }

  function formatarData(date) {
    const dia = String(date.getDate()).padStart(2, '0');
    const mes = String(date.getMonth() + 1).padStart(2, '0');
    const ano = date.getFullYear();
    return `${dia}/${mes}/${ano}`;
  }
  
  // NOVO: Fun√ß√£o auxiliar para obter o nome do dia da semana
function getDiaSemanaString(data = new Date()) {
  const dias = [
    "domingo", 
    "segunda-feira", 
    "ter√ßa-feira", 
    "quarta-feira", 
    "quinta-feira", 
    "sexta-feira", 
    "s√°bado"
  ];
  return dias[data.getDay()];
}

const diaParaIndice = {
  "domingo": 0, "dom": 0,
  "segunda": 1, "seg": 1,
  "ter√ßa": 2, "terca": 2, "ter": 2,
  "quarta": 3, "qua": 3,
  "quinta": 4, "qui": 4,
  "sexta": 5, "sex": 5,
  "s√°bado": 6, "sabado": 6, "sab": 6
};

  function getSemanaAtual(dateInput = null) {
    let data = dateInput || getHoje();
    
    // Clona a data para n√£o alterar a original e zera as horas para c√°lculo preciso de dias
    data = new Date(data.valueOf());
    data.setHours(0, 0, 0, 0);

    // --- L√ìGICA ISO 8601 (UNIVERSAL PARA QUALQUER ANO) ---
    // 1. Encontra a Quinta-feira desta semana.
    //    A regra internacional diz: a semana pertence ao ano em que cai a sua Quinta-feira.
    const diaSemana = (data.getDay() + 6) % 7; // Ajusta para: Seg=0, Ter=1 ... Dom=6
    const quintaFeira = new Date(data);
    quintaFeira.setDate(data.getDate() - diaSemana + 3);

    // 2. O ano da semana √© o ano dessa Quinta-feira encontrada
    const anoDaSemana = quintaFeira.getFullYear();

    // 3. Encontra a primeira Quinta-feira desse ano
    const primeiroDiaAno = new Date(anoDaSemana, 0, 1);
    const diaSemanaPrimeiroDia = (primeiroDiaAno.getDay() + 6) % 7;
    const primeiraQuinta = new Date(primeiroDiaAno);
    primeiraQuinta.setDate(primeiroDiaAno.getDate() - diaSemanaPrimeiroDia + 3);

    // 4. Calcula o n√∫mero da semana
    //    Diferen√ßa entre a Quinta atual e a primeira Quinta, dividido por 7, mais 1.
    const semanaNumero = Math.round(((quintaFeira - primeiraQuinta) / 86400000) / 7) + 1;

    // --- C√ÅLCULO VISUAL (SEGUNDA A S√ÅBADO) ---
    // Recalcula a Segunda e o S√°bado baseados na data original para exibi√ß√£o na tela
    const dataVisual = new Date(data);
    const diaSemanaVisual = dataVisual.getDay(); // 0=Dom, 1=Seg...
    
    // Se for Domingo (0), a "semana visual" come√ßou 6 dias atr√°s. Se for outro dia, volta (dia - 1)
    // Nota: Essa l√≥gica mant√©m o domingo como parte da semana que come√ßou na segunda anterior.
    let diffParaSegunda = diaSemanaVisual - 1;
    if (diaSemanaVisual === 0) diffParaSegunda = 6;

    const segunda = new Date(dataVisual);
    segunda.setDate(dataVisual.getDate() - diffParaSegunda);
    
    const sabado = new Date(segunda);
    sabado.setDate(segunda.getDate() + 5);
    
    return {
      inicio: segunda,
      fim: sabado,
      numero: semanaNumero,
      inicioFormatado: formatarData(segunda),
      fimFormatado: formatarData(sabado),
      fimCompeticao: formatarData(sabado).slice(0, 5)
    };
  }
  
// =============================================
// ===== NOVAS FUN√á√ïES OTIMIZADAS (CONTADOR DA LOJA) =====
// =============================================

/**
 * Retorna um objeto Date para o final da semana atual (S√°bado, 23:59:59).
 */
function getFimDaSemanaAtual() {
    const semana = getSemanaAtual(); 
    const fimDaSemana = new Date(semana.fim); 
    fimDaSemana.setHours(23, 59, 59, 999); 
    return fimDaSemana;
}

/**
 * Retorna um objeto Date para o final da pr√≥xima semana (S√°bado, 23:59:59).
 */
function getFimDaProximaSemana() {
    const fimDaSemanaAtual = getFimDaSemanaAtual();
    const fimDaProximaSemana = new Date(fimDaSemanaAtual.getTime());
    fimDaProximaSemana.setDate(fimDaProximaSemana.getDate() + 7);
    return fimDaProximaSemana;
}

/**
 * Formata o tempo restante em dias, horas, minutos e segundos.
 */
function formatarTempoRestante(msRestantes) {
    if (msRestantes <= 0) return "Liberado!";
    
    const s = Math.floor((msRestantes / 1000) % 60);
    const m = Math.floor((msRestantes / 1000 / 60) % 60);
    const h = Math.floor((msRestantes / (1000 * 60 * 60)) % 24);
    const d = Math.floor(msRestantes / (1000 * 60 * 60 * 24));

    let str = "Libera em: ";
    if (d > 0) str += `${d}d `;
    if (h > 0) str += `${h}h `;
    if (m > 0) str += `${m}m `;
    if (d === 0 && h === 0 && m === 0) str += `${s}s`;

    return str.trim();
}

// Vari√°vel global para o intervalo √∫nico
let intervaloGlobalLoja = null;

/**
 * Inicia o Gerenciador Global de Timers.
 * Roda apenas UM intervalo para atualizar TODOS os elementos da tela.
 */
function iniciarGerenciadorDeTimers() {
    // Se j√° existe, limpa para n√£o duplicar
    if (intervaloGlobalLoja) clearInterval(intervaloGlobalLoja);

    intervaloGlobalLoja = setInterval(() => {
        // Busca todos os elementos que precisam de contagem
        const elementos = document.querySelectorAll('.timer-ativo');
        
        if (elementos.length === 0) return; // Se n√£o tem nada, n√£o faz nada (economiza CPU)

        const agora = new Date().getTime();

        elementos.forEach(el => {
            const dataFimMs = parseInt(el.dataset.deadline, 10);
            if (!dataFimMs) return;

            const msRestantes = dataFimMs - agora;

            if (msRestantes <= 0) {
                el.textContent = "Liberado!";
                el.classList.remove('timer-ativo'); // Para de atualizar este elemento
                // Opcional: Recarregar a loja automaticamente
                // construirInterfaceLojaPoderes(); 
            } else {
                el.textContent = formatarTempoRestante(msRestantes);
            }
        });
    }, 1000);
}

// =============================================
// ===== FIM DAS NOVAS FUN√á√ïES (CONTADOR DA LOJA) =====
// =============================================

    // ATUALIZADA: Entende o timestamp como um check-in v√°lido
  async function carregarPresenca() {
    const hojeISO = getHojeISO();
    const docSnap = await getDoc(doc(db, "presencas", hojeISO));

    if (docSnap.exists()) {
      const data = docSnap.data();
      todosMembros.forEach(membro => {
        const nome = membro.nome;
        const checkbox = document.getElementById(nome);
        // MUDAN√áA AQUI:
        // A condi√ß√£o `data[nome]` continuar√° funcionando, pois um objeto de data √© "truthy".
        // Apenas garantimos que `checkbox.checked` receba um booleano `true`.
        if (checkbox && data[nome]) {
          checkbox.checked = true;
        }
      });
    }
  }

  async function carregarPontosSemanais() {
    const hoje = getHoje();
    
    // O bloco de c√≥digo que apagava os pontos no domingo foi REMOVIDO.

    // Carregar pontos do documento √∫nico
    const pontosRef = doc(db, "semanas", "pontosSemanais");
    const docSnap = await getDoc(pontosRef);
    
    if (docSnap.exists()) {
      const data = docSnap.data();
      pontosSemanais.abelha = data.abelha || 0;
      pontosSemanais.joaninha = data.joaninha || 0;
      pontosSemanais.vagalume = data.vagalume || 0;
    } else {
      // Se n√£o existe e n√£o for domingo (dia de reset), cria um novo.
      if (hoje.getDay() !== 0) {
          await setDoc(pontosRef, {
            abelha: 0,
            joaninha: 0,
            vagalume: 0
          });
      }
      // Se for domingo e n√£o existe, est√° correto, pois a semana ainda vai come√ßar.
      pontosSemanais.abelha = 0;
      pontosSemanais.joaninha = 0;
      pontosSemanais.vagalume = 0;
    }
  }

  async function carregarRankingGeral() {
    const rankingDoc = await getDoc(doc(db, "ranking", "geral"));
    if (rankingDoc.exists()) {
      const data = rankingDoc.data();
      rankingGeral.abelha = data.abelha || 0;
      rankingGeral.joaninha = data.joaninha || 0;
      rankingGeral.vagalume = data.vagalume || 0;
    }
    atualizarRankingGeral();
  }

async function finalizarSemana() {
    await carregarDadosEssenciais();
    const hoje = getHoje();

    // L√≥gica de S√°bado (sem altera√ß√µes)
    if (hoje.getDay() === 6) { 
        try {
            const semana = getSemanaAtual();
            const docId = `semana_${semana.numero}_${semana.inicio.getFullYear()}`;
            const advantageRef = doc(db, "vantagemSemanal", docId);
            const docSnap = await getDoc(advantageRef);

            if (docSnap.exists() && docSnap.data().palavraDaSemana) {
                const palavraUsadaId = docSnap.data().palavraDaSemana.id;
                if (palavraUsadaId) {
                    await deleteDoc(doc(db, "jogoDaForca", palavraUsadaId));
                }
            }
        } catch (error) {
            console.error("Erro ao deletar palavra da forca da semana:", error);
        }

        const semana = getSemanaAtual();
        const docId = `semana_${semana.numero}_${semana.inicio.getFullYear()}`;
        const advantageRef = doc(db, "vantagemSemanal", docId);
        
        let bonusAcabouDeSerProcessado = false;
        let equipesComBonusProcessadas = [];
        let completadoPorProcessado = {};
        
        try {
            await runTransaction(db, async (transaction) => {
                const advantageDoc = await transaction.get(advantageRef);
                if (advantageDoc.exists() && advantageDoc.data().bonusAplicado) return;
                
                let bonusSeraAplicado = false;
                const completadoPor = advantageDoc.exists() ? advantageDoc.data().completadoPor || {} : {};
                const membrosQueCompletaram = new Set(Object.keys(completadoPor));
                const equipesComBonus = [];

                for (const nomeEquipe in equipes) {
                    const equipeInfo = equipes[nomeEquipe];
                    if (equipeInfo.membros.length > 0) {
                        const todosCompletaram = equipeInfo.membros.filter(m => !m.deFerias).every(membro => membrosQueCompletaram.has(membro.nome));
                        if (todosCompletaram) {
                            bonusSeraAplicado = true;
                            equipesComBonus.push(nomeEquipe);
                        }
                    }
                }
                
                if (bonusSeraAplicado) {
                    transaction.set(advantageRef, { 
                        bonusAplicado: true,
                        equipesComBonus: equipesComBonus
                    }, { merge: true });
                    
                    bonusAcabouDeSerProcessado = true;
                    equipesComBonusProcessadas = equipesComBonus;
                    completadoPorProcessado = completadoPor;
                }
            });

            if (bonusAcabouDeSerProcessado) {
                const completadoPor = completadoPorProcessado; 
                
                const premiacaoMoedasJogo = {
                    1: recompensasConfig.top5Vantagem_1 || 50, 2: recompensasConfig.top5Vantagem_2 || 40,
                    3: recompensasConfig.top5Vantagem_3 || 30, 4: recompensasConfig.top5Vantagem_4 || 20,
                    5: recompensasConfig.top5Vantagem_5 || 10
                };
                const rankingJogo = Object.entries(completadoPor)
                    .map(([nome, timestamp]) => ({ nome, tempo: timestamp.toDate().getTime() }))
                    .sort((a, b) => a.tempo - b.tempo)
                    .slice(0, 5);
                if (rankingJogo.length > 0) {
                    const batchJogo = writeBatch(db);
                    rankingJogo.forEach((vencedor, index) => {
                        const posicao = index + 1;
                        const moedasGanhas = premiacaoMoedasJogo[posicao];
                        if (moedasGanhas) {
                            batchJogo.update(doc(db, "membros", vencedor.nome), { moedas: increment(moedasGanhas) });
                            if (vencedor.nome === currentUser) mostrarPopupMoedas(moedasGanhas);
                        }
                    });
                    await batchJogo.commit();
                }
                
                mostrarPopup("‚ú® B√¥nus Garantido!", "As equipes que completaram o desafio garantiram o b√¥nus para a m√©dia final!", 6000);
                
                const equipesVencedoras = equipesComBonusProcessadas; 

                let textoFeed;
                if (equipesVencedoras.length > 0) {
                    const nomesEquipes = equipesVencedoras.map(e => `<strong>Equipe ${e.charAt(0).toUpperCase() + e.slice(1)}</strong>`).join(', ');
                    
                    // L√≥gica para singular ou plural
                    const verboCompletar = equipesVencedoras.length > 1 ? 'completaram' : 'completou';
                    const verboGarantir = equipesVencedoras.length > 1 ? 'garantiram' : 'garantiu';
                    
                    textoFeed = `Parab√©ns! ${nomesEquipes} ${verboCompletar} o Jogo da Vantagem e ${verboGarantir} um b√¥nus em sua m√©dia final no domingo!`;
                } else {
                    textoFeed = `O Jogo da Vantagem foi finalizado, mas nenhuma equipe cumpriu o requisito do b√¥nus esta semana.`;
                }

                await adicionarEventoAoFeed('vantagem', '‚ú® B√¥nus do Jogo da Vantagem!', textoFeed);
            }
        } catch (error) {
            console.error("Erro na finaliza√ß√£o do Jogo da Vantagem:", error);
        }
    }

    // L√≥gica de Domingo (ATUALIZADA PARA CORRIGIR TOP 5 E SA√öDE)
    if (hoje.getDay() === 0 && hoje.getBrasiliaHours() >= 0) {
        
        // Verifica se j√° estamos sob um bloqueio maior (da meia-noite). Se n√£o, ativa um.
        const bloqueioAtivoRef = await getDoc(doc(db, "appState", "globalLock"));
        const jaBloqueado = bloqueioAtivoRef.exists() && bloqueioAtivoRef.data().isLocked;
        
        if (!jaBloqueado) {
             await setGlobalLock(true, "üèÜ Finalizando Competi√ß√£o: Calculando vencedores...");
        }

        try {
        // IN√çCIO DO BLOCO DE CORRE√á√ÉO (Evitar re-execu√ß√£o ao recarregar a p√°gina)
        // 1. Calcula a semana passada de forma segura (clonando a data 'hoje')
        const hojeClonado = new Date(hoje);
        const semanaPassada = getSemanaAtual(new Date(hojeClonado.setDate(hojeClonado.getDate() - 1)));
        const semanaId = `semana_${semanaPassada.numero}_${semanaPassada.inicio.getFullYear()}`;
        const resultadoRef = doc(db, "resultadosCompeticao", semanaId);
        
        // 2. Verifica se o resultado j√° foi salvo (o lock)
        const resultadoSnap = await getDoc(resultadoRef);
        if (resultadoSnap.exists()) {
             console.log(`‚úÖ Finaliza√ß√£o da semana ${semanaId} j√° foi processada. Saindo.`);
             // Garante a limpeza da pontua√ß√£o para iniciar a pr√≥xima semana
             const pontosRef = doc(db, "semanas", "pontosSemanais");
             await deleteDoc(pontosRef).catch(() => {});
             pontosSemanais.abelha = 0; pontosSemanais.joaninha = 0; pontosSemanais.vagalume = 0;
             atualizarPlacarSemanal();
             return; // Aborta o resto da fun√ß√£o se j√° foi processado
        }
        // FIM DO BLOCO DE CORRE√á√ÉO

        const pontosRef = doc(db, "semanas", "pontosSemanais");
        const docSnap = await getDoc(pontosRef);

        if (docSnap.exists() && Object.keys(docSnap.data()).length > 0) {
            const pontos = docSnap.data();
            
            // AS VARI√ÅVEIS semanaPassada, semanaId e resultadoRef J√Å EST√ÉO DEFINIDAS ACIMA.
            // O c√≥digo original abaixo foi removido para evitar a redefini√ß√£o:
            /*
            const semanaPassada = getSemanaAtual(new Date(hoje.setDate(hoje.getDate() - 1)));
            const semanaId = `semana_${semanaPassada.numero}_${semanaPassada.inicio.getFullYear()}`;
            const resultadoRef = doc(db, "resultadosCompeticao", semanaId);
            */

            const detalhesMembros = {};
            todosMembros.forEach(m => {
                // CORRE√á√ÉO AQUI: Adicionado motivoAusencia e tempoTotal
				detalhesMembros[m.nome] = { 
                    nome: m.nome, 
                    equipe: m.equipe, 
                    pontuacao: { foco: 0, vantagem: 0, total: 0 }, 
                    meChamo: m['me chamo'] || m.nome, 
                    deFerias: m.deFerias || false,
                    motivoAusencia: m.motivoAusencia || null, // Essencial para identificar doentes
                    tempoTotal: 0 // Essencial para desempate do Top 5
                };
            });

            const inicioSemanaISO = formatarDataISO(semanaPassada.inicio);
            const fimSemanaISO = formatarDataISO(semanaPassada.fim);
            const qPresencas = query(collection(db, "presencas"), where('__name__', '>=', inicioSemanaISO), where('__name__', '<=', fimSemanaISO));
            const presencasSnap = await getDocs(qPresencas);
            
            presencasSnap.forEach(doc => {
                const presencasDoDia = doc.data();
                for (const nome in presencasDoDia) {
                    if (presencasDoDia[nome] && detalhesMembros[nome]) {
                        detalhesMembros[nome].pontuacao.foco++;
                        detalhesMembros[nome].pontuacao.total++;
                        
                        // CORRE√á√ÉO AQUI: Acumula o timestamp para desempate
                        if (presencasDoDia[nome].toDate) {
                            detalhesMembros[nome].tempoTotal += presencasDoDia[nome].toDate().getTime();
                        }
                    }
                }
            });

            const advantageRef = doc(db, "vantagemSemanal", semanaId);
            const advantageDoc = await getDoc(advantageRef);
            
            const PONTOS_FIXOS_JOGO_VANTAGEM = 3;
            const equipesComBonus = advantageDoc.exists() ? advantageDoc.data().equipesComBonus || [] : [];
            
            if (advantageDoc.exists()) {
                const completadoPor = advantageDoc.data().completadoPor || {};
                for (const nome in completadoPor) {
                    if (detalhesMembros[nome]) {
                        detalhesMembros[nome].pontuacao.vantagem += PONTOS_FIXOS_JOGO_VANTAGEM;
                        detalhesMembros[nome].pontuacao.total += PONTOS_FIXOS_JOGO_VANTAGEM;
                    }
                }
            }
			
            // Carrega dados de poderes
            const deducoesPoderes = advantageDoc.exists() ? advantageDoc.data().deducoesPoderes || {} : {};
            const adicoesPoderes = advantageDoc.exists() ? advantageDoc.data().adicoesPoderes || {} : {};
            const ajustesManuais = advantageDoc.exists() ? advantageDoc.data().ajustesManuais || {} : {};

            console.log("Calculando vencedor da semana com M√âDIA NIVELADA...");

            const medias = {};
            const nomesEquipesArray = ['abelha', 'joaninha', 'vagalume'];
            const equipesAtivas = [];

            let minTamanhoEquipe = Infinity;
            nomesEquipesArray.forEach(equipe => {
                const membrosAtivos = equipes[equipe]?.membros.filter(m => !m.deFerias) || [];
                const numeroMembrosAtivos = membrosAtivos.length;
                if (numeroMembrosAtivos > 0) {
                    equipesAtivas.push(equipe);
                    if (numeroMembrosAtivos < minTamanhoEquipe) {
                        minTamanhoEquipe = numeroMembrosAtivos;
                    }
                }
            });
            
            if (minTamanhoEquipe === Infinity) {
                minTamanhoEquipe = 0;
            }

            nomesEquipesArray.forEach(equipe => {
                const membrosAtivos = equipes[equipe]?.membros.filter(m => !m.deFerias) || [];
                const numeroMembrosAtivos = membrosAtivos.length;

                if (numeroMembrosAtivos === 0) {
                    medias[equipe] = 0;
                    return;
                }

                const pontuacoesIndividuais = membrosAtivos.map(membro => detalhesMembros[membro.nome]?.pontuacao.foco || 0);
                pontuacoesIndividuais.sort((a, b) => a - b);
                const pontosADescartar = numeroMembrosAtivos - minTamanhoEquipe;
                let pontuacoesParaMedia = [...pontuacoesIndividuais];
                
                if (pontosADescartar > 0) {
                    pontuacoesParaMedia = pontuacoesIndividuais.slice(pontosADescartar);
                }
                
                const somaDasPontuacoes = pontuacoesParaMedia.reduce((acc, score) => acc + score, 0);
                const numeroMembrosParaMedia = pontuacoesParaMedia.length;
                
                let mediaDeFoco = (numeroMembrosParaMedia > 0) ? (somaDasPontuacoes / numeroMembrosParaMedia) : 0;
                
                if (equipesComBonus.includes(equipe)) {
                    mediaDeFoco += PONTOS_FIXOS_JOGO_VANTAGEM;
                }

                // Aplica efeitos dos poderes
                if (adicoesPoderes[equipe] && adicoesPoderes[equipe].length > 0) {
                    const totalAdicao = adicoesPoderes[equipe].reduce((acc, poder) => acc + (poder.valor || 0), 0);
                    mediaDeFoco += totalAdicao;
                }
                
                if (deducoesPoderes[equipe] && deducoesPoderes[equipe].length > 0) {
                    const totalDeducao = deducoesPoderes[equipe].reduce((acc, poder) => acc + (poder.valor || 0), 0);
                    mediaDeFoco += totalDeducao; 
                }

                medias[equipe] = mediaDeFoco;
            });
            
            if (equipesAtivas.length === 0) {
                await adicionarEventoAoFeed('vitoria', 'üå¥ Competi√ß√£o Suspensa', 'Todos os membros ativos est√£o de f√©rias.');
                await deleteDoc(pontosRef);
                pontosSemanais.abelha = 0; pontosSemanais.joaninha = 0; pontosSemanais.vagalume = 0;
                atualizarPlacarSemanal();
                return;
            }

            if (equipesAtivas.length === 1) {
                const equipeUnica = equipesAtivas[0];
                if (pontos[equipeUnica] > 0) {
                    const mediaUnica = medias[equipeUnica].toFixed(2);
                    const nomeEquipeUnica = equipeUnica.charAt(0).toUpperCase() + equipeUnica.slice(1);
                    await updateDoc(doc(db, "ranking", "geral"), { [equipeUnica]: increment(1) });
                    rankingGeral[equipeUnica]++;
                    atualizarRankingGeral();
                    mostrarPopup("üèÜ Vit√≥ria Semanal", `Equipe ${nomeEquipeUnica} venceu a semana com uma m√©dia de ${mediaUnica} pontos!`, 8000);
                    await adicionarEventoAoFeed('vitoria', 'üèÜ Temos uma Campe√£ Semanal!', `A equipe <strong>${nomeEquipeUnica}</strong> venceu competindo sozinha com uma m√©dia de <strong>${mediaUnica}</strong> pontos.`, { vencedoras: [equipeUnica] });
                    const batchMoedas = writeBatch(db);
                    equipes[equipeUnica].membros.forEach(membro => {
                        if (!membro.deFerias) {
                            batchMoedas.update(doc(db, "membros", membro.nome), { moedas: increment(recompensasConfig.vitoriaSemanal || 500) });
                        }
                    });
                    await batchMoedas.commit();
                    const bancoRefUnico = doc(db, "bancosEquipes", equipeUnica);
                    await setDoc(bancoRefUnico, { saldo: increment(100000) }, { merge: true });
                    const movRefUnico = doc(collection(db, "bancosEquipes", equipeUnica, "movimentacoes"));
                    await setDoc(movRefUnico, {
                        tipo: 'premio',
                        valor: 100000,
                        descricao: "Pr√™mio da Competi√ß√£o Semanal",
                        timestamp: new Date()
                    });
                    await adicionarEventoAoFeed('vitoria', 'üí∞ Recompensa de Campe√£o!', `Como recompensa, cada membro ativo da equipe <strong>${nomeEquipeUnica}</strong> recebeu <strong>${recompensasConfig.vitoriaSemanal || 500} üí∞ moedas</strong>!`);
                } else {
                     await adicionarEventoAoFeed('vitoria', 'üèÅ Semana sem Vencedor', 'A √∫nica equipe ativa n√£o marcou pontos.');
                }
                await calcularMembrosOciosos();
                await deleteDoc(pontosRef);
                pontosSemanais.abelha = 0; pontosSemanais.joaninha = 0; pontosSemanais.vagalume = 0;
                atualizarPlacarSemanal();
                return;
            }
            
            const rankingEquipes = Object.entries(medias)
                .filter(([equipe]) => equipesAtivas.includes(equipe))
                .map(([equipe, media]) => ({ equipe, media }))
                .sort((a, b) => b.media - a.media);
            
            const posicoes = {};
            let rank = 1;
            for(let i = 0; i < rankingEquipes.length; i++) {
                if(i > 0 && rankingEquipes[i].media < rankingEquipes[i-1].media) {
                    rank++;
                }
                posicoes[rankingEquipes[i].equipe] = rank;
            }
            
            // --- IN√çCIO DA ALTERA√á√ÉO: BUSCAR HIST√ìRICO COMPLETO DE PODERES ---
            const historicoPoderesRef = collection(db, "historicoPoderes");
            // Busca tudo que foi comprado nesta semana
            const qHistorico = query(historicoPoderesRef, where("semana", "==", semanaPassada.numero));
            const historicoSnap = await getDocs(qHistorico);

            const historicoCompletoSemana = { abelha: [], joaninha: [], vagalume: [] };
            
            // Mapa manual de nomes para garantir, caso a vari√°vel global n√£o esteja pronta
            const mapaNomesPoderes = {
                'pocao_sextagem': 'üç∫ Po√ß√£o da Sextagem',
                'praga_kriptonita': 'ü§¢ Praga de Kriptonita',
                'maldicao_pilantragem': 'üíÄ Maldi√ß√£o da Pilantragem',
                'elixir_vida': 'üíñ Elixir de Vida',
                'runa_soft_block': 'üîí Runa do Soft Block',
                'amuleto_protecao': 'üõ°Ô∏è Amuleto de Prote√ß√£o',
                'amuleto_falha': '‚ùå Falha de Magia'
            };

            historicoSnap.forEach(doc => {
                const data = doc.data();
                // Verifica o ano para evitar conflito com mesma semana de anos diferentes
                const anoData = data.timestamp.toDate().getFullYear();
                if (anoData === semanaPassada.inicio.getFullYear()) {
                    if (historicoCompletoSemana[data.equipe]) {
                        const nomePoder = mapaNomesPoderes[data.poderId] || data.poderId;
                        historicoCompletoSemana[data.equipe].push({
                            nomePoder: nomePoder,
                            poderId: data.poderId,
                            alvo: data.alvo,
                            timestamp: data.timestamp
                        });
                    }
                }
            });
            // --- FIM DA ALTERA√á√ÉO ---

            const dadosDoResultado = {
                pontosEquipes: pontos,
                mediaEquipes: medias,
                rankingEquipes: posicoes,
                detalhesMembros: detalhesMembros,
                ajustesManuais: ajustesManuais,
                deducoesPoderes: deducoesPoderes,
                adicoesPoderes: adicoesPoderes,
                historicoCompletoPoderes: historicoCompletoSemana, // <--- NOVO CAMPO ADICIONADO
                timestamp: new Date(),
            };

            // Gera a an√°lise com a fun√ß√£o atualizada
            const analiseOraculoTexto = await gerarResumoSemanalComIA(dadosDoResultado, semanaPassada);
            dadosDoResultado.analiseOraculo = analiseOraculoTexto;
            
            await setDoc(resultadoRef, dadosDoResultado);
            
            let maxMedia = -1;
            for (const equipe of equipesAtivas) {
                if (medias[equipe] > maxMedia) maxMedia = medias[equipe];
            }

            const vencedoras = [];
            if (maxMedia > 0) {
                for (const equipe of equipesAtivas) {
                    if (Math.abs(medias[equipe] - maxMedia) < 0.001) {
                        vencedoras.push(equipe);
                    }
                }
            }
            
            const empate = vencedoras.length > 1;

            if (vencedoras.length > 0) {
                const rankingRef = doc(db, "ranking", "geral");
                const atualizacoes = {};
                vencedoras.forEach(equipe => {
                    atualizacoes[equipe] = increment(1);
                    rankingGeral[equipe]++;
                });
                await updateDoc(rankingRef, atualizacoes);
                atualizarRankingGeral();
                const nomesEquipes = { abelha: "Abelha", joaninha: "Joaninha", vagalume: "Vaga-lume" };
                const nomesVencedoras = vencedoras.map(eq => nomesEquipes[eq]).join(" e ");
                
                const textoPopup = `com uma m√©dia de ${maxMedia.toFixed(2)} pontos por membro!`;
                const textoFeed = `com uma incr√≠vel m√©dia de <strong>${maxMedia.toFixed(2)}</strong> pontos por membro.`;

                if (empate) {
                    mostrarPopup("üèÜ Empate Semanal", `As equipes ${nomesVencedoras} empataram ${textoPopup}`, 8000);
                    await adicionarEventoAoFeed('vitoria', 'üèÜ Empate na Competi√ß√£o Semanal!', `Que disputa acirrada! As equipes <strong>${nomesVencedoras}</strong> empataram ${textoFeed}`, { vencedoras: vencedoras });
                } else {
                    mostrarPopup("üèÜ Vit√≥ria Semanal", `Equipe ${nomesVencedoras} venceu a semana ${textoPopup}`, 8000);
                    await adicionarEventoAoFeed('vitoria', 'üèÜ Temos uma Campe√£ Semanal!', `A equipe <strong>${nomesVencedoras}</strong> venceu ${textoFeed}`, { vencedoras: vencedoras });
                }
                
                const batchMoedas = writeBatch(db);
                vencedoras.forEach(equipeVencedora => {
                    equipes[equipeVencedora].membros.forEach(membro => {
                        if (!membro.deFerias) {
                            batchMoedas.update(doc(db, "membros", membro.nome), { moedas: increment(recompensasConfig.vitoriaSemanal || 500) });
                        }
                    });
                });
                await batchMoedas.commit();
                
                const batchBanco = writeBatch(db);
                const timestampPremio = new Date();
                vencedoras.forEach(equipeVencedora => {
                    const bancoRef = doc(db, "bancosEquipes", equipeVencedora);
                    batchBanco.set(bancoRef, { saldo: increment(100000) }, { merge: true });
                    
                    const movRef = doc(collection(db, "bancosEquipes", equipeVencedora, "movimentacoes"));
                    batchBanco.set(movRef, {
                        tipo: 'premio',
                        valor: 100000,
                        descricao: "Pr√™mio da Competi√ß√£o Semanal",
                        timestamp: timestampPremio
                    });
                });
                await batchBanco.commit();

                const nomesEquipesParaFeed = vencedoras.map(eq => eq.charAt(0).toUpperCase() + eq.slice(1));
                const textoFeedBanco = `Al√©m disso, o <strong>Banco da(s) Equipe(s) ${nomesEquipesParaFeed.join(' e ')}</strong> recebeu um b√¥nus de <strong>100.000 üí∞ moedas</strong>!`;
                await adicionarEventoAoFeed('vitoria', 'üè¶ B√¥nus para o Banco!', textoFeedBanco);

                const textoFeedPremiacao = `Como recompensa, cada membro ativo da(s) equipe(s) <strong>${nomesEquipesCapitalizados.join(' e ')}</strong> recebeu <strong>${recompensasConfig.vitoriaSemanal || 500} üí∞ moedas</strong>!`;
                await adicionarEventoAoFeed('vitoria', 'üí∞ Recompensa de Campe√£o!', textoFeedPremiacao);
            }

            await calcularMembrosOciosos();
            await deleteDoc(pontosRef);
            pontosSemanais.abelha = 0; pontosSemanais.joaninha = 0; pontosSemanais.vagalume = 0;
            atualizarPlacarSemanal();
        }
        
        } catch (e) {
            console.error("Erro na finaliza√ß√£o da semana:", e);
        } finally {
            // S√≥ libera se fomos n√≥s que travamos (n√£o libera se for parte da rotina da meia-noite)
            if (!jaBloqueado) {
               await setGlobalLock(false);
            }
        }
    }
}

// ATUALIZADA: Fun√ß√£o esvaziada para desativar a sincroniza√ß√£o global
async function setGlobalLock(ativo, motivo = "Executando manuten√ß√£o...") {
  // Funcionalidade desativada. N√£o faz nada.
  console.log("SetGlobalLock chamado (desativado):", ativo, motivo);
  return Promise.resolve();
}

// ATUALIZADA: Fun√ß√£o esvaziada
function configurarOuvinteSincronizacaoGlobal() {
  // Listener desativado.
}

// =======================================================
// ===== FUN√á√ÉO ATUALIZADA: GERADOR DE RESUMO SEMANAL COM IA (v3 - Corre√ß√£o de Nomes) =====
// =======================================================

async function gerarResumoSemanalComIA(dadosResultado, semanaPassada) {
  if (!genAI) {
    console.warn("IA n√£o inicializada. Pulando resumo semanal do Or√°culo.");
    return;
  }

  // --- NOVO: BUSCA DADOS DA TEMPORADA (HALL DA FAMA) ---
  let textoVitoriaTemporada = "";
  try {
      const anoReferencia = semanaPassada.inicio.getFullYear(); // Ex: 2025
      const hallRef = doc(db, "hallDaFama", String(anoReferencia));
      const hallSnap = await getDoc(hallRef);
      
      // ALTERA√á√ÉO: S√≥ anuncia o fim da temporada se a semana analisada for a √∫ltima do ano (52 ou 53)
      if (hallSnap.exists() && semanaPassada.numero >= 52) {
          const dadosHall = hallSnap.data();
          const vencedoras = dadosHall.vencedora || [];
          // Formata nomes (Ex: Vaga-lume)
          const nomesFormatados = vencedoras.map(n => {
              if (n.toLowerCase() === 'vagalume') return 'Vaga-lume';
              return n.charAt(0).toUpperCase() + n.slice(1);
          }).join(' e ');

          textoVitoriaTemporada = `
          üö® ALERTA DE EVENTO HIST√ìRICO - FIM DE TEMPORADA!
          A Temporada ${anoReferencia} chegou ao fim hoje.
          A GRANDE CAMPE√É DO ANO √â A EQUIPE: ${nomesFormatados.toUpperCase()}!
          (Com um total de ${dadosHall.vitorias} vit√≥rias acumuladas no ano).
          
          INSTRU√á√ÉO OBRIGAT√ìRIA: Voc√™ DEVE dedicar um par√°grafo exclusivo e emocionado para parabenizar a equipe ${nomesFormatados} por essa conquista hist√≥rica anual. Diga que o nome deles ficar√° gravado no Hall da Fama dos √âpicos para sempre.
          `;
      }
  } catch (e) {
      console.error("Erro ao buscar dados da temporada para o Or√°culo:", e);
  }
  // -----------------------------------------------------

  // 1. Coletar e formatar os dados para a IA
  const { mediaEquipes, rankingEquipes, detalhesMembros = {}, adicoesPoderes = {}, deducoesPoderes = {} } = dadosResultado;
  
  // --- L√ìGICA DE VENCEDORES ---
  const vencedoras = Object.entries(rankingEquipes)
    .filter(([, pos]) => pos === 1)
    .map(([equipe]) => equipe);

  let textoVencedoras = '';
  if (vencedoras.length > 1) {
    const nomesEquipes = vencedoras.map(e => e.charAt(0).toUpperCase() + e.slice(1)).join(' e ');
    textoVencedoras = `Houve um belo empate entre as equipes ${nomesEquipes}.`;
  } else if (vencedoras.length === 1) {
    const nomeEquipe = vencedoras[0].charAt(0).toUpperCase() + vencedoras[0].slice(1);
    textoVencedoras = `A equipe vencedora foi a ${nomeEquipe}.`;
  } else {
    textoVencedoras = "N√£o tivemos um vencedor claro esta semana, mas o esfor√ßo de todos foi not√°vel.";
  }

  const placarFinalTexto = Object.entries(mediaEquipes)
    .map(([equipe, media]) => `- Equipe ${equipe.charAt(0).toUpperCase() + equipe.slice(1)}: M√©dia de ${media.toFixed(2)} pontos.`)
    .join('\n');

  // --- RANKING INDIVIDUAL CORRIGIDO (COM CRIT√âRIO DE DESEMPATE) ---
  const rankingIndividual = Object.values(detalhesMembros)
    .filter(m => !m.deFerias) // Mant√©m o filtro: quem est√° doente ou de f√©rias N√ÉO entra no ranking
    .sort((a, b) => {
        // Crit√©rio 1: Maior Pontua√ß√£o Total
        if (b.pontuacao.total !== a.pontuacao.total) {
            return b.pontuacao.total - a.pontuacao.total;
        }
		
        // Crit√©rio 2: Menor Tempo Total Acumulado (Mais r√°pido √© melhor)
        // Usamos 0 como fallback caso tempoTotal n√£o exista (compatibilidade)
        const tempoA = a.tempoTotal || Infinity;
        const tempoB = b.tempoTotal || Infinity;
        return tempoA - tempoB;
    })
    .slice(0, 5)
    .map((m, i) => `${i+1}¬∫: ${m.nome} (G√™nero: ${m.genero || 'Indefinido'}, Nome Real: ${m.meChamo}, ${m.pontuacao.total} pontos)`)
    .join('\n');

  // --- CORRE√á√ÉO: IDENTIFICAR MEMBROS DOENTES USANDO O CAMPO NOVO ---
  // Filtramos quem est√° marcado como 'deFerias' E tem o motivo 'saude'
  // (Agora verificamos 'm.motivoAusencia' que vem do detalhesMembros atualizado)
  const membrosDoentes = Object.values(detalhesMembros)
    .filter(m => m.deFerias && m.motivoAusencia === 'saude')
    .map(m => m.nome);
    
  const textoMembrosDoentes = membrosDoentes.length > 0 
    ? membrosDoentes.join(', ') 
    : "Ningu√©m.";

  // --- Coleta de eventos (Feed) e DETEC√á√ÉO DE ANIVERS√ÅRIOS ---
  let resumoSemanalFeedTexto = "Nenhum evento importante registrado ainda.";
  let aniversariantesDaSemana = []; // Array para guardar os nomes

  try {
    const inicioSemana = semanaPassada.inicio;
    const fimSemana = new Date(semanaPassada.fim.getTime() + (24*60*60*1000 - 1000)); 
    const q = query(
      collection(db, "resumoSemanalFeed"),
      where("timestamp", ">=", inicioSemana),
      where("timestamp", "<=", fimSemana),
      orderBy("timestamp", "asc") 
    );
    const querySnapshot = await getDocs(q);
    if (!querySnapshot.empty) {
      resumoSemanalFeedTexto = querySnapshot.docs.map(doc => {
        const evento = doc.data();
        
        // >>> NOVA L√ìGICA: Detecta cart√µes de anivers√°rio no feed <<<
        if (evento.titulo && evento.titulo.includes("Feliz Anivers√°rio")) {
            // O nome geralmente est√° em 'nomeMembro' no dadosExtras ou extra√≠mos do t√≠tulo
            const nomeAniversariante = evento.nomeMembro || evento.titulo.replace("üéÇ Feliz Anivers√°rio, ", "").replace("!", "");
            if (nomeAniversariante) aniversariantesDaSemana.push(nomeAniversariante);
        }
        // ---------------------------------------------------------

        const textoLimpo = evento.texto.replace(/<[^>]*>/g, " ").replace(/\s+/g, ' ').trim();
        return `- ${evento.titulo}: ${textoLimpo}`;
      }).join('\n');
    }
  } catch (error) {
    console.error("Or√°culo: Erro ao buscar hist√≥rico completo do feed:", error);
    // Fallback com cache
    if (feedEventosCache && feedEventosCache.length > 0) {
        resumoSemanalFeedTexto = feedEventosCache.map(e => `- ${e.titulo}: ${e.texto}`).join('\n');
    }
  }
  
  // --- Dados da Loteria da Semana ---
  let loteriaTexto = "N√£o houve sorteio registrado nesta semana.";
  if (dadosLoteria && dadosLoteria.historico && dadosLoteria.historico.length > 0) {
      // Pega o √∫ltimo sorteio
      const ultimoSorteio = dadosLoteria.historico[dadosLoteria.historico.length - 1];
      const dataSorteio = new Date(ultimoSorteio.data.seconds * 1000);
      // Verifica se o sorteio foi nesta semana (margem de 7 dias)
      const diffTempo = new Date().getTime() - dataSorteio.getTime();
      if (diffTempo < 7 * 24 * 60 * 60 * 1000) {
          if (ultimoSorteio.ganhadores && ultimoSorteio.ganhadores.length > 0) {
              loteriaTexto = `LOTERIA √âPICA: Tivemos ganhadores! Parab√©ns a ${ultimoSorteio.ganhadores.join(', ')} que dividiram o pr√™mio de ${ultimoSorteio.premio} moedas!`;
          } else {
              loteriaTexto = `LOTERIA √âPICA: O pr√™mio acumulou! Ningu√©m acertou os n√∫meros. Incentive o grupo a continuar tentando na pr√≥xima.`;
          }
      }
  }

  // --- Formata poderes usados ---
  let poderesUsadosTexto = "Nenhum poder foi usado esta semana.";
  const adicoesArray = Object.values(adicoesPoderes).flat();
  const deducoesArray = Object.values(deducoesPoderes).flat();
  if (adicoesArray.length > 0 || deducoesArray.length > 0) {
      poderesUsadosTexto = "Atividade da Lojinha de Magias:\n";
      adicoesArray.forEach(p => { poderesUsadosTexto += `- (B√îNUS): ${p.por} usou "${p.nomePoder}" para sua equipe.\n`; });
      deducoesArray.forEach(p => { poderesUsadosTexto += `- (PUNI√á√ÉO): ${p.por} usou "${p.nomePoder}" contra a equipe advers√°ria.\n`; });
  }
  
  // Prepara a string de aniversariantes para o prompt
  const textoAniversariantes = aniversariantesDaSemana.length > 0 
      ? `SIM! Tivemos anivers√°rios de: ${aniversariantesDaSemana.join(', ')}` 
      : "N√£o houve anivers√°rios registrados no feed.";

  // 2. Construir o prompt para o Or√°culo (ATUALIZADO)
  const prompt = `
    Voc√™ √© o Or√°culo, o mentor s√°bio, acolhedor e carinhoso do "Grupo √âpicos".
    A competi√ß√£o da semana acabou. Sua tarefa √© escrever um post especial para o "Resumo da Semana", analisando os resultados com sua personalidade de um mentor mais velho (cerca de 50 anos), que √© am√°vel e demonstra cuidado com o progresso do grupo.

    Aqui est√£o os dados da semana para sua an√°lise:
	${textoVitoriaTemporada}
    - Resultado da Competi√ß√£o: ${textoVencedoras}
    - Placar Final (M√©dias das equipes):
    ${placarFinalTexto}
    - Top 5 Membros da Semana (Dedica√ß√£o): 
    ${rankingIndividual || "Ningu√©m pontuou o suficiente para o Top 5."}
	- ANIVERSARIANTES DA SEMANA (Evento Especial):
    ${textoAniversariantes}
	- MEMBROS EM RECUPERA√á√ÉO DE SA√öDE (Doentes/Acidentados):
    ${textoMembrosDoentes}
	- ${loteriaTexto}
    - ${poderesUsadosTexto}
    - Acontecimentos Recentes (O que aconteceu durante a semana):
    ${resumoSemanalFeedTexto || "Nenhum evento especial registrado."}

    Instru√ß√µes para sua resposta:
    1.  O t√≠tulo do evento ser√° "üßô‚Äç An√°lise Semanal do Or√°culo".
    2.  Escreva uma an√°lise detalhada (3 a 5 par√°grafos) em seu estilo carinhoso e de mentor.
    3.  Parabenize a(s) equipe(s) vencedora(s) de forma calorosa. Comente sobre a disputa, elogiando o esfor√ßo de todos, mesmo os que n√£o venceram.
    4.  **ATEN√á√ÉO AO TOP 5:** Cite EXATAMENTE os nomes listados acima como o Top 5. Elogie-os pela dedica√ß√£o e *rapidez* (pois o desempate √© por velocidade). N√ÉO invente outros nomes.
	5.  REGRA DE G√äNERO OBRIGAT√ìRIA: Verifique a etiqueta (G√™nero: ...) ao lado de cada nome. Use pronomes e adjetivos concordando com esse g√™nero (ex: "a Kaii foi guerreira", "o Max foi r√°pido").
	6.  **REGRA DE ENDERE√áAMENTO:** Mencione o membro como <strong>@NomeDoMembro</strong>. Nunca use o Nome Real no texto, use-o apenas para ajudar a identificar o g√™nero caso o campo "G√™nero" esteja indefinido. Nunca use Nome Real diretamente na mensagem.
    7.  **3¬™ PESSOA (REGRA DE OURO):** No Mural, voc√™ fala **SOBRE** o membro para o grupo, nunca **COM** o membro.
        -   ERRADO: "Parab√©ns @Max, voc√™ mandou bem!" (Isso √© 2¬™ pessoa).
        -   CERTO: "O @Max mandou muito bem hoje!" (Isso √© 3¬™ pessoa).
        -   SEMPRE use: "Ele fez", "A @Ana conseguiu", "O foco dele". NUNCA use "Voc√™".
	8.  **NOVA INSTRU√á√ÉO (MUITO IMPORTANTE):** Verifique os "Acontecimentos Recentes". 
        -   Se houver algum evento indicando a chegada de um novo membro (ex: t√≠tulo "Bem-vindo(a) ao Grupo!"), inclua uma mensagem calorosa de boas-vindas a ele(a) em sua an√°lise.
        -   Se houver eventos de "Poder Ativado" ou "Medalha de Honra", comente brevemente sobre como essas a√ß√µes (o uso de magias ou o reconhecimento de membros) tornaram a semana mais interessante e competitiva.
	9.  **ATEN√á√ÉO AOS DOENTES:** Verifique a lista "MEMBROS EM RECUPERA√á√ÉO DE SA√öDE". Se houver nomes nela, voc√™ **DEVE** dedicar uma frase carinhosa desejando melhoras e pronta recupera√ß√£o a eles. Diga que a sa√∫de vem em primeiro lugar e que o grupo os aguarda.
    10.	**MEMBROS DE F√âRIAS:** Ignore membros que est√£o apenas de f√©rias (n√£o mencionados na lista de sa√∫de), eles est√£o descansando e n√£o precisam de men√ß√£o na an√°lise competitiva.
	11. **NOVA INSTRU√á√ÉO (MUITO IMPORTANTE):** Verifique a lista "ANIVERSARIANTES DA SEMANA". Se houver nomes nela, voc√™ **DEVE** dedicar um par√°grafo especial celebrando a vida deles novamente. Diga algo como "E como deixar de mencionar a alegria de celebrarmos mais um ano de vida de @Nome...". Celebre o fato de terem passado essa data com o grupo.
	12. **REGRA EXTREMAMENTE IMPORTANTE:** Use o "Nome de Usu√°rio" em negrito (ex: <strong>Nome</strong>). NUNCA use o s√≠mbolo '@' ou o nome real no texto.
    13.  Termine com uma mensagem de incentivo e afeto para a pr√≥xima semana, refor√ßando a import√¢ncia do descanso e da uni√£o.
    14.  Assine com "‚Äî Com carinho, Or√°culo." ou simplesmente "‚Äî Or√°culo.".
    15. Sua resposta deve ser apenas o texto da an√°lise, sem formata√ß√£o JSON e sem introdu√ß√µes.
    16. REGRA SOBRE PONTUA√á√ÉO: A pontua√ß√£o individual representa o total de dias de foco durante a semana. Elogie a 'dedica√ß√£o' e 'comprometimento', em vez de 'sequ√™ncia' ou 'dias consecutivos'.
	17. **SOBRE A BATALHA DE DESENHOS:** Verifique nos "Acontecimentos Recentes" se houve um vencedor da "Batalha de Arte" ou "Novo Tema".
        - Se houve um vencedor, parabenize a equipe pela obra de arte.
        - Se n√£o houve men√ß√£o, ignore.
    18. **INSTRU√á√ÉO OBRIGAT√ìRIA SOBRE A LOTERIA:** Verifique o dado fornecido sobre a "LOTERIA √âPICA".
        - Se houver ganhadores, voc√™ DEVE parabeniz√°-los nominalmente e comentar sobre a sorte grande.
        - Se acumulou, voc√™ DEVE comentar que o pr√™mio est√° ficando gigante e incentivar apostas para a pr√≥xima.
        - N√ÉO IGNORE O RESULTADO DA LOTERIA.
  `;

  // --- L√ìGICA DE RETENTATIVAS COM ROTA√á√ÉO DE CHAVE ---
  let analiseTexto = '';

  try {
      console.log(`üßô‚Äç Or√°culo preparando a an√°lise semanal...`);
      // Usa a fun√ß√£o mestre que j√° gerencia rota√ß√£o de chave e erro 429
      analiseTexto = await callGenerativeAIWithRetry(prompt);
  } catch (error) {
      console.error("Erro final ao gerar resumo semanal ap√≥s todas as tentativas:", error);
      analiseTexto = "Meus queridos, a semana foi intensa. Parab√©ns aos vencedores! Que a pr√≥xima semana nos traga ainda mais foco e uni√£o. Descansem bem. ‚Äî Or√°culo.";
  }
  
  // Converte o texto da IA em HTML
  let analiseHtml = analiseTexto.replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>'); 
  analiseHtml = analiseHtml.replace(/\n/g, '<br>');

  analiseOraculoPendente = analiseHtml;
  return analiseHtml; 
}

function mostrarPopupAnaliseOraculo(textoAnalise) {
  // 1. Verifica se o texto da an√°lise foi fornecido.
  if (!textoAnalise) {
    // Se o texto estiver vazio (ex: ainda n√£o foi gerado ou houve erro), n√£o faz nada.
    console.log("Nenhuma an√°lise do Or√°culo para exibir.");
    return;
  }

  // 2. [REMOVIDO] Verifica√ß√£o de sessionStorage removida para exibir sempre

  // 3. Mostra o modal.
  const titulo = "üßô‚Äç A An√°lise Semanal do Or√°culo";
  // Gera um ID √∫nico baseado na semana atual para bloquear apenas a an√°lise DESTA semana hoje
  const semana = getSemanaAtual();
  const idUnico = `oraculo_analise_semana_${semana.numero}`; 
  
  mostrarCardPopup(titulo, textoAnalise, null, 'Or√°culo', idUnico);
  
  // 4. [REMOVIDO] SetItem removido

  // 5. Limpa a vari√°vel global.
  analiseOraculoPendente = null;
}

  function getMedalha(totalDias) {
    const niveis = Object.keys(medalhas).map(Number).sort((a, b) => b - a);
    for (const nivel of niveis) {
      if (totalDias >= nivel) {
        return medalhas[nivel];
      }
    }
    return null;
  }

  async function atualizarMedalhas() {
    // Esta fun√ß√£o agora √© super r√°pida, pois l√™ do cache local, e n√£o do banco de dados.
    for (const nome in streaksCache) {
        if (Object.hasOwnProperty.call(streaksCache, nome)) {
            atualizarStreakVisualMembro(nome, streaksCache[nome]);
        }
    }
  }

  async function atualizarPlacarSemanal() {
    if (document.getElementById("resumo-abelha")) {
      document.getElementById("resumo-abelha").innerHTML = `
        <div>${document.querySelectorAll('#equipe-abelha input:checked').length} focaram hoje!</div>
        <div>${pontosSemanais.abelha} pontos na semana</div>
        <div>M√©dia: <span id="media-abelha">0.00</span></div>
      `;
    }
    
    if (document.getElementById("resumo-joaninha")) {
      document.getElementById("resumo-joaninha").innerHTML = `
        <div>${document.querySelectorAll('#equipe-joaninha input:checked').length} focaram hoje!</div>
        <div>${pontosSemanais.joaninha} pontos na semana</div>
        <div>M√©dia: <span id="media-joaninha">0.00</span></div>
      `;
    }
    
    if (document.getElementById("resumo-vagalume")) {
      document.getElementById("resumo-vagalume").innerHTML = `
        <div>${document.querySelectorAll('#equipe-vagalume input:checked').length} focaram hoje!</div>
        <div>${pontosSemanais.vagalume} pontos na semana</div>
        <div>M√©dia: <span id="media-vagalume">0.00</span></div>
      `;
    }

    // CHAMA A NOVA FUN√á√ÉO PARA ATUALIZAR AS M√âDIAS
    await atualizarMediaEquipes();
}
  
// ATUALIZADA: Agora calcula a "M√©dia Justa" em tempo real.
async function atualizarMediaEquipes() {
  const nomesEquipes = ['abelha', 'joaninha', 'vagalume'];
  const semana = getSemanaAtual();
  const inicioSemanaISO = formatarDataISO(semana.inicio);
  const fimSemanaISO = formatarDataISO(semana.fim);

  try {
  
  // Busca os b√¥nus/penalidades de poder da semana
    const semanaDocId = `semana_${semana.numero}_${semana.inicio.getFullYear()}`;
    const advantageRef = doc(db, "vantagemSemanal", semanaDocId);
    const advantageSnap = await getDoc(advantageRef);
    
    const deducoesPoderes = advantageSnap.exists() ? advantageSnap.data().deducoesPoderes || {} : {};
    const adicoesPoderes = advantageSnap.exists() ? advantageSnap.data().adicoesPoderes || {} : {};
	
    // 1. Busca todas as presen√ßas da semana para obter os pontos individuais.
    const q = query(
      collection(db, "presencas"),
      where('__name__', '>=', inicioSemanaISO),
      where('__name__', '<=', fimSemanaISO)
    );
    const presencasSnap = await getDocs(q);

    // Objeto para armazenar a pontua√ß√£o de cada membro.
    const pontosPorMembro = {};
    todosMembros.forEach(m => {
      pontosPorMembro[m.nome] = 0;
    });

    // Calcula os pontos de cada membro na semana.
    presencasSnap.forEach(doc => {
      const presencasDoDia = doc.data();
      for (const nome in presencasDoDia) {
        if (presencasDoDia[nome] && pontosPorMembro[nome] !== undefined) {
          pontosPorMembro[nome]++;
        }
      }
    });

    // 2. Encontra o tamanho da menor equipe ativa (l√≥gica de nivelamento).
    let minTamanhoEquipe = Infinity;
    nomesEquipes.forEach(equipe => {
      const membrosAtivos = equipes[equipe]?.membros.filter(m => !m.deFerias) || [];
      const numeroMembrosAtivos = membrosAtivos.length;
      if (numeroMembrosAtivos > 0 && numeroMembrosAtivos < minTamanhoEquipe) {
        minTamanhoEquipe = numeroMembrosAtivos;
      }
    });
    if (minTamanhoEquipe === Infinity) {
      minTamanhoEquipe = 0;
    }

    // 3. Calcula e exibe a m√©dia justa para cada equipe.
    nomesEquipes.forEach(equipe => {
      const mediaElement = document.getElementById(`media-${equipe}`);
      if (!mediaElement) return;

      const membrosAtivos = equipes[equipe]?.membros.filter(m => !m.deFerias) || [];
      const numeroMembrosAtivos = membrosAtivos.length;

      if (numeroMembrosAtivos === 0) {
        mediaElement.textContent = "0.00";
        return;
      }

      // Pega a pontua√ß√£o de foco individual de cada membro ativo.
      const pontuacoesIndividuais = membrosAtivos.map(membro => pontosPorMembro[membro.nome] || 0);
      
      // Ordena as pontua√ß√µes da menor para a maior.
      pontuacoesIndividuais.sort((a, b) => a - b);
      
      // Descarta as piores pontua√ß√µes para nivelar com a menor equipe.
      const pontosADescartar = numeroMembrosAtivos - minTamanhoEquipe;
      let pontuacoesParaMedia = [...pontuacoesIndividuais];
      if (pontosADescartar > 0) {
        pontuacoesParaMedia = pontuacoesIndividuais.slice(pontosADescartar);
      }
      
      // Calcula a m√©dia com as pontua√ß√µes niveladas.
      const somaDasPontuacoes = pontuacoesParaMedia.reduce((acc, score) => acc + score, 0);
      const numeroMembrosParaMedia = pontuacoesParaMedia.length;
      let mediaDeFoco = (numeroMembrosParaMedia > 0) ? (somaDasPontuacoes / numeroMembrosParaMedia) : 0;
      
      // ===== IN√çCIO DA MODIFICA√á√ÉO (PASSO 3 de 3) =====
      // Aplica os b√¥nus/penalidades de poder em tempo real
      if (adicoesPoderes[equipe] && adicoesPoderes[equipe].length > 0) {
          const totalAdicao = adicoesPoderes[equipe].reduce((acc, poder) => acc + (poder.valor || 0), 0);
          mediaDeFoco += totalAdicao;
      }
      if (deducoesPoderes[equipe] && deducoesPoderes[equipe].length > 0) {
          const totalDeducao = deducoesPoderes[equipe].reduce((acc, poder) => acc + (poder.valor || 0), 0);
          mediaDeFoco += totalDeducao; // O valor j√° √© negativo
      }
      // ===== FIM DA MODIFICA√á√ÉO =====

      mediaElement.textContent = mediaDeFoco.toFixed(2);
    });

  } catch (error) {
    console.error("Erro ao atualizar m√©dias em tempo real:", error);
    // Em caso de erro, exibe 0.00 para n√£o quebrar a interface.
    nomesEquipes.forEach(equipe => {
      const mediaElement = document.getElementById(`media-${equipe}`);
      if (mediaElement) mediaElement.textContent = "0.00";
    });
  }
}

  function atualizarRankingGeral() {
    if (document.getElementById("ranking-abelha")) {
      document.getElementById("ranking-abelha").textContent = rankingGeral.abelha;
    }
    if (document.getElementById("ranking-joaninha")) {
      document.getElementById("ranking-joaninha").textContent = rankingGeral.joaninha;
    }
    if (document.getElementById("ranking-vagalume")) {
      document.getElementById("ranking-vagalume").textContent = rankingGeral.vagalume;
    }
	atualizarPodioEquipes()
  }
  
  // NOVA FUN√á√ÉO: Ouve as mudan√ßas no documento de presen√ßas do dia e atualiza as checkboxes na tela.
function configurarOuvintePresencaTempoReal() {
  const hojeISO = getHojeISO();
  const presencaRef = doc(db, "presencas", hojeISO);

  // Inicia o ouvinte em tempo real (onSnapshot)
  onSnapshot(presencaRef, (docSnap) => {
    console.log("Sincroniza√ß√£o em tempo real: O documento de presen√ßas foi atualizado.");

    let presencasDoDia = {};
    if (docSnap.exists()) {
      presencasDoDia = docSnap.data();
    }

    // Itera por todos os membros para verificar e atualizar o estado de cada checkbox
    todosMembros.forEach(membro => {
      const checkbox = document.getElementById(membro.nome);
      if (!checkbox) return; // Se o elemento n√£o existir na tela, pula para o pr√≥ximo

      // Verifica se o membro tem um registro de presen√ßa no banco de dados
      // O '!!' transforma o valor (que pode ser um timestamp ou undefined) em um booleano (true/false)
      const deveriaEstarMarcado = !!presencasDoDia[membro.nome];

      // Apenas altera a checkbox se o estado dela na tela for diferente do que deveria ser.
      // Isso evita atualiza√ß√µes desnecess√°rias e poss√≠veis loops.
      if (checkbox.checked !== deveriaEstarMarcado) {
        checkbox.checked = deveriaEstarMarcado;
      }
    });

    // Ap√≥s sincronizar todas as checkboxes, chamamos a fun√ß√£o para atualizar
    // os contadores e as barras de progresso, garantindo que tudo fique consistente.
    atualizarResumo();
  });
}

window.atualizarResumo = async function () {
    if (todosMembros.length === 0) return;

    // Contagem de elementos visuais para seguran√ßa
    const checkboxesNaTela = document.querySelectorAll('.membro input[type="checkbox"]').length;
    
    // Se n√£o h√° nada na tela, n√£o faz nada
    if (checkboxesNaTela === 0) return;

    filaAtualizacao = filaAtualizacao.then(async () => {
    const hoje = getHoje();
    const hojeISO = getHojeISO(); 
    
    // 1. Conta quem marcou o checkbox (Foco Real)
      const totalFocaram = todosMembros.filter(membro => document.getElementById(membro.nome)?.checked).length;
      
      // 2. Conta quem est√° ausente (F√©rias ou Sa√∫de)
      const totalAbonados = todosMembros.filter(membro => membro.deFerias).length;

      // 3. Soma total para a mec√¢nica da √Årvore e Barra de Progresso
      const membrosAtivos = todosMembros.filter(m => !m.deFerias);
      const totalAtivosFocaram = membrosAtivos.filter(m => document.getElementById(m.nome)?.checked).length;
      
      const totalParaContagem = totalAtivosFocaram + totalAbonados;
      const totalMembrosContagem = todosMembros.length;
      
      // --- ATUALIZA√á√ÉO VISUAL (RODA SEMPRE) ---
      if (document.getElementById("contadorGeral")) {
        document.getElementById("contadorGeral").textContent = `${totalParaContagem} √©picos focaram hoje!`;

        const porcentagem = totalMembrosContagem > 0 ? (totalParaContagem / totalMembrosContagem) * 100 : 0;
        const barraProgresso = document.getElementById("progresso-barra");
        barraProgresso.style.width = `${porcentagem}%`;
        
        const marcadorArvore = document.getElementById('marcador-arvore');
        if (marcadorArvore && totalMembrosContagem > 0) {
          const posicaoMeta = (10 / totalMembrosContagem) * 100;
          if (posicaoMeta <= 100) {
            marcadorArvore.style.left = `${posicaoMeta}%`;
            marcadorArvore.style.display = 'flex';
          } else {
            marcadorArvore.style.display = 'none';
          }
        }

        const todosFocados = totalParaContagem === totalMembrosContagem;
        const globalStats = document.querySelector(".global-stats");
        const mensagemTodosFocados = document.getElementById("mensagem-todos-focados");
        
        // --- CORRE√á√ÉO BUG VISUAL √ÅRVORE ---
        const statusFocadoEl = document.getElementById("status-focado");
        const statusNaoFocadoEl = document.getElementById("status-nao-focado");
        if (statusFocadoEl) statusFocadoEl.textContent = `‚úÖ ${totalParaContagem} √©picos focaram hoje`;
        if (statusNaoFocadoEl) statusNaoFocadoEl.textContent = `‚ùå ${totalMembrosContagem - totalParaContagem} √©picos ainda n√£o focaram`;
        // ----------------------------------

        if (todosFocados) {
          barraProgresso.classList.add("rainbow-progress");
          globalStats.classList.add("rainbow-border");
          if (mensagemTodosFocados) {
              mensagemTodosFocados.textContent = "Todos focaram (ou est√£o justificados) hoje, parab√©ns!!";
              mensagemTodosFocados.classList.remove("hidden");
          }
        } else {
          barraProgresso.classList.remove("rainbow-progress");
          globalStats.classList.remove("rainbow-border");
          if (mensagemTodosFocados) {
              mensagemTodosFocados.classList.add("hidden");
          }
        }
      }
      
      atualizarPlacarSemanal();
      verificarEquipeCompleta();
      
      // --- PROTE√á√ÉO DE SEGURAN√áA DA √ÅRVORE ---
      // S√≥ processa a l√≥gica sens√≠vel da √°rvore se a quantidade de checkboxes na tela
      // bater com a quantidade de membros no banco. Isso evita bugs de "perda de for√ßa" falsa.
      if (checkboxesNaTela >= todosMembros.length) {
          await verificarArvoreEpica(totalParaContagem);
      } else {
          console.warn(`[Prote√ß√£o] √Årvore n√£o processada devido a discrep√¢ncia visual (${checkboxesNaTela}/${todosMembros.length}), mas a barra foi atualizada.`);
      }
      
      await carregarTop5Semana();

    }).catch(error => {
      console.error("Erro na atualiza√ß√£o:", error);
    });
    
    await filaAtualizacao;
}

// Verificar se todos os membros de uma equipe est√£o focados
  function verificarEquipeCompleta() {
    for (const equipeNome in equipes) {
      const grupo = document.getElementById(`equipe-${equipeNome}`);
      const mensagemEl = document.getElementById(`msg-equipe-${equipeNome}`);
      if (!grupo || !mensagemEl) continue;

      // ===== ALTERA√á√ÉO AQUI =====
      // Filtra os membros que n√£o est√£o de f√©rias ANTES de verificar se todos focaram.
      const membrosAtivos = equipes[equipeNome].membros.filter(m => !m.deFerias);
      const todosFocados = membrosAtivos.every(membroObj => 
        document.getElementById(membroObj.nome)?.checked
      );
      
      // --- IN√çCIO DA MODIFICA√á√ÉO: Aplicar/Remover brilho dos membros ---
      const classeBrilho = `membro-completo-${equipeNome}`;
      equipes[equipeNome].membros.forEach(membroObj => {
        const membroEl = document.getElementById(membroObj.nome)?.parentElement; // Pega o <div class="membro">
        if (membroEl) {
          if (todosFocados && membrosAtivos.length > 0) {
            membroEl.classList.add(classeBrilho);
          } else {
            membroEl.classList.remove(classeBrilho);
          }
        }
      });
      // --- FIM DA MODIFICA√á√ÉO ---
      
      mensagemEl.classList.remove('abelha', 'joaninha', 'vagalume');

      if (todosFocados && membrosAtivos.length > 0) {
        grupo.classList.add('equipe-completa', equipeNome); // Mant√©m o brilho no container da equipe
        const nomeCapitalizado = equipeNome.charAt(0).toUpperCase() + equipeNome.slice(1);
        mensagemEl.textContent = `Parab√©ns, equipe ${nomeCapitalizado}!! Voc√™s gabaritaram hoje!!!`;
        mensagemEl.classList.add(equipeNome);
        mensagemEl.classList.remove('hidden');
      } else {
        grupo.classList.remove('equipe-completa', equipeNome); // Remove o brilho do container da equipe
        mensagemEl.classList.add('hidden');
      }
    }
  }

// FUN√á√ÉO ATUALIZADA: Agora aceita ID √∫nico para bloqueio di√°rio
function mostrarCardPopup(titulo, mensagem, onCloseCallback = null, assinatura = 'Grupo √âpicos', uniqueId = null) {
  // 1. OTIMIZA√á√ÉO: Verifica no cache local se este popup est√° bloqueado para hoje
  if (uniqueId && currentUser) {
      const membroAtual = todosMembros.find(m => m.nome === currentUser);
      if (membroAtual && membroAtual.bloqueiosPopups) {
          const hojeISO = getHojeISO();
          // Chave do bloqueio: ID_DATA (ex: msg_oraculo_2025-10-20)
          const chaveBloqueio = `${uniqueId}_${hojeISO}`;
          
          if (membroAtual.bloqueiosPopups[chaveBloqueio]) {
              console.log(`Popup '${uniqueId}' bloqueado pelo usu√°rio para hoje.`);
              return; // N√£o adiciona √† fila e n√£o mostra
          }
      }
  }

  // Adiciona o popup √† fila com o uniqueId
  cardPopupQueue.push({ titulo, mensagem, onCloseCallback, assinatura, uniqueId });
  
  // Tenta processar a fila
  processarFilaCardPopup();
}

// NOVA FUN√á√ÉO: Processa a fila de Cards Popups um por um
async function processarFilaCardPopup() {
  // --- CORRE√á√ÉO DE SEGURAN√áA VISUAL ---
  // Verifica se o elemento do popup j√° est√° vis√≠vel na tela.
  // Se estiver, for√ßamos a vari√°vel de controle para true e paramos aqui.
  // Isso impede que um novo popup atropele o conte√∫do do atual antes dele fechar.
  const overlay = document.getElementById('custom-card-popup');
  if (overlay && overlay.classList.contains('show')) {
      isCardPopupShowing = true; // Auto-corrige o estado se estiver errado
      return; // Sai da fun√ß√£o e espera o fechamento natural
  }
  // ------------------------------------

  // 1. Verifica se j√° tem um Card gen√©rico aberto (via vari√°vel) OU se a fila est√° vazia
  if (isCardPopupShowing || cardPopupQueue.length === 0) return;

  // 2. Verifica se algum Popup Especial (Pix, Medalha, Recompensa) est√° aberto.
  const popupsEspeciaisAbertos = document.querySelector(
      '#pix-recebido-popup.show, ' +
      '#medalha-ganha-popup.show, ' +
      '#recompensa-recebida-popup.show, ' +
      '#popup-envio-diario-moedas.show, ' +
      '#popup-resultado-loteria.show, ' +
      '#recompensa-lideres-modal.show, ' +
      '#recompensa-equipe-modal.show, ' +
      '#fim-temporada-popup.show'
  );

  if (popupsEspeciaisAbertos) {
      // Se tiver um especial aberto, espera 500ms e tenta processar a fila novamente
      setTimeout(processarFilaCardPopup, 500); 
      return;
  }

  // Marca que est√° ocupado
  isCardPopupShowing = true;

  // Pega o pr√≥ximo item da fila
  const dadosPopup = cardPopupQueue.shift();
  
  const popupTitle = document.getElementById('card-popup-title');
  const popupMessage = document.getElementById('card-popup-message');
  // SELECIONA A ASSINATURA TAMB√âM
  const popupSignature = document.querySelector('.card-popup-signature'); 
  const closeBtn = document.getElementById('card-popup-close-btn');

  // Configura o conte√∫do
  popupTitle.textContent = dadosPopup.titulo;
  popupMessage.innerHTML = dadosPopup.mensagem;
  
  // Atualiza a assinatura se o elemento existir
    if (popupSignature) {
        if (dadosPopup.assinatura === null) {
            // Se for explicitamente null, esconde a assinatura para ganhar espa√ßo
            popupSignature.style.display = 'none';
        } else {
            popupSignature.style.display = 'block';
            popupSignature.innerText = `‚Äî ${dadosPopup.assinatura || 'Grupo √âpicos'}`;
        }
    }

  // --- L√ìGICA DO BOT√ÉO "N√ÉO VER NOVAMENTE" ---
  const btnDontShow = document.getElementById('card-popup-dont-show-btn');
  if (btnDontShow) {
      // Clona o bot√£o para remover listeners antigos
      const novoBtnDontShow = btnDontShow.cloneNode(true);
      btnDontShow.parentNode.replaceChild(novoBtnDontShow, btnDontShow);

      if (dadosPopup.uniqueId) {
          novoBtnDontShow.classList.remove('hidden');
          novoBtnDontShow.onclick = async () => {
              // 1. Fecha visualmente primeiro (UX r√°pida)
              document.getElementById('card-popup-close-btn').click();
              
              // 2. Salva o bloqueio no Firestore e no Cache
              if (currentUser) {
                  const hojeISO = getHojeISO();
                  const chaveBloqueio = `${dadosPopup.uniqueId}_${hojeISO}`;
                  const membroRef = doc(db, "membros", currentUser);
                  
                  try {
                      // Atualiza Firestore (usando nota√ß√£o de ponto para Map)
                      await updateDoc(membroRef, {
                          [`bloqueiosPopups.${chaveBloqueio}`]: true
                      });
                      
                      // Atualiza Cache Local (para funcionar na mesma sess√£o sem reload)
                      const membroIndex = todosMembros.findIndex(m => m.nome === currentUser);
                      if (membroIndex !== -1) {
                          if (!todosMembros[membroIndex].bloqueiosPopups) {
                              todosMembros[membroIndex].bloqueiosPopups = {};
                          }
                          todosMembros[membroIndex].bloqueiosPopups[chaveBloqueio] = true;
                      }
                      
                      console.log(`Bloqueio salvo para: ${chaveBloqueio}`);
                  } catch (error) {
                      console.error("Erro ao salvar bloqueio de popup:", error);
                  }
              }
          };
      } else {
          novoBtnDontShow.classList.add('hidden');
      }
  }
  // ---------------------------------------------

  // --- L√≥gica de Tema ---
  const bodyClass = document.body.className;
  overlay.classList.remove('tema-noite', 'tema-manha', 'tema-tarde');
  if (bodyClass.includes('tema-noite')) overlay.classList.add('tema-noite');
  else if (bodyClass.includes('tema-manha')) overlay.classList.add('tema-manha');
  else if (bodyClass.includes('tema-tarde')) overlay.classList.add('tema-tarde');
  
  // Exibe o modal
  overlay.classList.add('show');
  
  // Define a a√ß√£o de fechar
  const acaoFechar = async () => {
    overlay.classList.remove('show');
    
    // Executa callback espec√≠fico deste popup (ex: confete), se houver
    if (dadosPopup.onCloseCallback) {
      dadosPopup.onCloseCallback();
    }
    
    // Aguarda a anima√ß√£o de sa√≠da (350ms)
    await new Promise(resolve => setTimeout(resolve, 350));
    
    // Libera a trava
    isCardPopupShowing = false;

    // CORRE√á√ÉO: Prioriza a fila de cards.
    if (cardPopupQueue.length > 0) {
        processarFilaCardPopup();
    } 
  };

  // Clona o bot√£o para garantir que listeners de mousedown/mouseup anteriores sejam removidos
  const novoBtn = closeBtn.cloneNode(true);
  closeBtn.parentNode.replaceChild(novoBtn, closeBtn);

  // Atribui a a√ß√£o de fechar ao NOVO bot√£o limpo
  novoBtn.onclick = acaoFechar;

  // Configura o clique no overlay (fundo escuro)
  overlay.onclick = (event) => {
    if (event.target === overlay) {
      acaoFechar();
    }
  };
}

// =======================================================
// ===== BLOCO DE C√ìDIGO CORRIGIDO E DEFINITIVO =====
// (Substitua as 3 fun√ß√µes antigas por estas)
// =======================================================

// Mostra a tela de progresso do Or√°culo (VERS√ÉO CORRIGIDA)
function showOracleProgressOverlay() {
  const overlay = document.getElementById('oracle-progress-overlay');
  if (overlay) {
    // Primeiro, remove a classe 'hidden' para garantir que o elemento ocupe espa√ßo
    overlay.classList.remove('hidden');
    // Em seguida, adiciona a classe 'show' para iniciar a transi√ß√£o de opacidade
    // O setTimeout garante que o navegador processe a remo√ß√£o do 'hidden' antes de adicionar o 'show'
    setTimeout(() => {
        overlay.classList.add('show');
    }, 10); // Um pequeno atraso √© suficiente
    updateOracleProgress(0, 'Iniciando processo...');
  }
}

// Esconde a tela de progresso (VERS√ÉO CORRIGIDA)
function hideOracleProgressOverlay() {
  const overlay = document.getElementById('oracle-progress-overlay');
  if (overlay) {
    // Primeiro, remove a classe 'show' para iniciar a transi√ß√£o de desaparecimento
    overlay.classList.remove('show');
    // Ap√≥s a transi√ß√£o de 300ms do CSS, adiciona a classe 'hidden' para remover o elemento do layout
    setTimeout(() => {
        overlay.classList.add('hidden');
    }, 300);
  }
}

// Atualiza a barra de progresso e o texto de status (sem altera√ß√µes, mas inclu√≠da para garantir)
function updateOracleProgress(percentage, statusText) {
  const progressBar = document.getElementById('oracle-progress-bar');
  const statusEl = document.getElementById('oracle-status-text');
  if (progressBar) {
    progressBar.style.width = `${percentage}%`;
  }
  if (statusEl) {
    statusEl.textContent = statusText;
  }
}

// Fun√ß√µes para controlar o novo overlay de carregamento
function showLoadingOverlay(message) {
  const overlay = document.getElementById('loading-overlay');
  const textElement = document.getElementById('loading-text');
  if (overlay && textElement) {
    textElement.textContent = message;
    overlay.classList.remove('hidden');
    // For√ßa a transi√ß√£o de CSS
    setTimeout(() => overlay.classList.add('show'), 10);
  }
}

function updateLoadingOverlayText(newMessage) {
  const textElement = document.getElementById('loading-text');
  if (textElement) {
    textElement.textContent = newMessage;
  }
}

function hideLoadingOverlay() {
  const overlay = document.getElementById('loading-overlay');
  if (overlay) {
    overlay.classList.remove('show');
    // Aguarda a transi√ß√£o de fade-out terminar antes de esconder completamente
    setTimeout(() => overlay.classList.add('hidden'), 300);
  }
}

// --- FUN√á√ÉO REINSERIDA AQUI ---
function mostrarPopup(titulo, mensagem, duracao = 3000) {
    popupQueue.push({ titulo, mensagem, duracao });
    processPopupQueue();
}
// Torna a fun√ß√£o global para corrigir o erro "window.mostrarPopup is not a function"
window.mostrarPopup = mostrarPopup;
// ------------------------------

function processPopupQueue() {
    // Se a fila estiver vazia ou um popup j√° estiver na tela, n√£o faz nada
    if (popupQueue.length === 0 || isPopupShowing) {
        return;
    }

    // Marca que um popup est√° ativo
    isPopupShowing = true;
    
    // CORRE√á√ÉO: Cria a vari√°vel popupData pegando o primeiro item da fila
    const popupData = popupQueue.shift();
    
    const popup = document.getElementById("popup-message");
    if (!popup) {
        isPopupShowing = false; // Reseta se o elemento n√£o existir
        return;
    }
    
    // Exibe o popup usando os dados da vari√°vel criada
    popup.innerHTML = `<strong>${popupData.titulo}</strong><br>${popupData.mensagem}`;
    popup.classList.add("show");
    
    // Agenda o desaparecimento do popup
    setTimeout(() => {
        popup.classList.remove("show");
        
        // Aguarda a anima√ß√£o de sa√≠da terminar para processar o pr√≥ximo
        setTimeout(() => {
            isPopupShowing = false; // Libera a fila
            processPopupQueue(); // Chama o pr√≥ximo popup da fila, se houver
        }, 500); // 500ms √© um tempo seguro para a anima√ß√£o CSS

    }, popupData.duracao);
}

// NOVA FUN√á√ÉO: Para exibir o popup de ganho de moedas
function mostrarPopupMoedas(quantidade) {
    if (quantidade > 0) {
        const mensagem = `Voc√™ ganhou <strong>${quantidade} üí∞ moedas</strong>!`;
        mostrarPopup("üéâ Recompensa!", mensagem, 3500);
    }
}

  const medalhasConcedidas = {};
  
  
  function atualizarStreakVisualMembro(nome, streak) {
    const diasElement = document.getElementById(`dias-${nome}`);
    if (diasElement) {
        diasElement.textContent = streak;
        diasElement.title = `${streak} dias de foco consecutivos`;
    }

    const medalhaElement = document.getElementById(`medalha-${nome}`);
    if (medalhaElement) {
        const medalha = getMedalha(streak);
        if (medalha) {
            medalhaElement.innerHTML = medalha.emoji;
            medalhaElement.title = `${medalha.nome} - ${streak} dias de foco consecutivos`;
            medalhaElement.classList.add('com-medalha');
            medalhaElement.classList.remove('escondido');
        } else {
            medalhaElement.innerHTML = '';
            medalhaElement.classList.remove('com-medalha');
            medalhaElement.classList.add('escondido');
        }
    }
  }

  function dispararConfete() {
    const confettiCanvas = document.getElementById("confetti-canvas");
    if (!confettiCanvas) return;
    
    const confettiCtx = confettiCanvas.getContext('2d');
    confettiCanvas.width = window.innerWidth;
    confettiCanvas.height = window.innerHeight;
    const confettiParticles = [];
    const particleCount = 200; // Mais part√≠culas para um efeito mais cheio
    const colors = ["#FFD700", "#FF6B6B", "#2ECC71", "#3498DB", "#9B59B6", "#FAD390"];

    for (let i = 0; i < particleCount; i++) {
      confettiParticles.push({
        x: Math.random() * confettiCanvas.width,
        y: -Math.random() * confettiCanvas.height, // Come√ßam de alturas variadas acima da tela
        w: Math.random() * 8 + 5,  // Largura do ret√¢ngulo
        h: Math.random() * 15 + 8, // Altura do ret√¢ngulo
        color: colors[Math.floor(Math.random() * colors.length)],
        angle: Math.random() * Math.PI * 2, // √Çngulo inicial de rota√ß√£o
        speed: Math.random() * 4 + 2,       // Velocidade de queda
        spin: Math.random() * 0.4 - 0.2,    // Velocidade de rota√ß√£o
        drift: Math.random() * 2 - 1        // Movimento lateral (deriva)
      });
    }
    
    let lastTime = 0;
    function animateConfetti(time) {
      const deltaTime = time - lastTime;
      lastTime = time;

      confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
      
      let particlesAlive = 0;
      for (let i = 0; i < confettiParticles.length; i++) {
        const p = confettiParticles[i];
        
        // Atualiza a posi√ß√£o e rota√ß√£o
        p.y += p.speed;
        p.x += p.drift;
        p.angle += p.spin;

        // Desenha o ret√¢ngulo rotacionado
        confettiCtx.save(); // Salva o estado atual do canvas
        confettiCtx.translate(p.x + p.w / 2, p.y + p.h / 2); // Move o ponto de origem para o centro da part√≠cula
        confettiCtx.rotate(p.angle); // Rotaciona o canvas
        confettiCtx.fillStyle = p.color;
        confettiCtx.fillRect(-p.w / 2, -p.h / 2, p.w, p.h); // Desenha o ret√¢ngulo a partir do centro
        confettiCtx.restore(); // Restaura o estado original do canvas

        // Verifica se a part√≠cula ainda est√° na tela
        if (p.y < confettiCanvas.height) {
          particlesAlive++;
        }
      }
      
      if (particlesAlive > 0) {
        requestAnimationFrame(animateConfetti);
      } else {
        confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
      }
    }
    
    requestAnimationFrame(animateConfetti);
  }
  
  function iniciarConfeteAniversarioContinuo() {
    // Se j√° estiver rodando, n√£o faz nada
    if (animacaoConfeteAniversarioId) return;

    const canvas = document.getElementById("confetti-canvas");
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    const colors = ["#FFD700", "#FF6B6B", "#2ECC71", "#3498DB", "#9B59B6", "#FAD390"];

    // 1. GERADOR DE PART√çCULAS: Cria 1 nova part√≠cula a cada 200ms
    geradorDeParticulasId = setInterval(() => {
      particulasAniversario.push({
        x: Math.random() * canvas.width,
        y: -20, // Come√ßa um pouco acima da tela
        w: Math.random() * 6 + 4,  // Tamanho um pouco menor
        h: Math.random() * 12 + 6, // Tamanho um pouco menor
        color: colors[Math.floor(Math.random() * colors.length)],
        angle: Math.random() * Math.PI * 2,
        speed: Math.random() * 2 + 1, // Velocidade de queda menor
        spin: Math.random() * 0.2 - 0.1,
        drift: Math.random() * 1 - 0.5 
      });
    }, 200); // Intervalo maior para menos part√≠culas

    // 2. LOOP DE ANIMA√á√ÉO: Apenas desenha e move as part√≠culas existentes
    function animarConfeteContinuo() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Itera de tr√°s para frente para poder remover itens do array sem problemas
      for (let i = particulasAniversario.length - 1; i >= 0; i--) {
        const p = particulasAniversario[i];
        
        p.y += p.speed;
        p.x += p.drift;
        p.angle += p.spin;

        ctx.save();
        ctx.translate(p.x + p.w / 2, p.y + p.h / 2);
        ctx.rotate(p.angle);
        ctx.fillStyle = p.color;
        ctx.fillRect(-p.w / 2, -p.h / 2, p.w, p.h);
        ctx.restore();

        // Remove a part√≠cula se ela j√° saiu da tela
        if (p.y > canvas.height + 20) {
          particulasAniversario.splice(i, 1);
        }
      }
      
      // Continua o loop de anima√ß√£o
      animacaoConfeteAniversarioId = requestAnimationFrame(animarConfeteContinuo);
    }

    // Inicia a anima√ß√£o
    animarConfeteContinuo();
  }
  
  function pararConfeteAniversarioContinuo() {
    if (geradorDeParticulasId) {
      clearInterval(geradorDeParticulasId);
      geradorDeParticulasId = null;
    }
    if (animacaoConfeteAniversarioId) {
      cancelAnimationFrame(animacaoConfeteAniversarioId);
      animacaoConfeteAniversarioId = null;
    }
    // Limpa o array e o canvas para garantir que tudo pare
    particulasAniversario = [];
    const canvas = document.getElementById("confetti-canvas");
    if (canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    }
  }

async function executarMarcacaoAutomaticaDeFolgasDoDia() {
  const hojeISO = getHojeISO();
  const taskRef = doc(db, "appState", "dailyTasks");

  console.log(`[FOLGAS HOJE] Verificando se a marca√ß√£o autom√°tica para ${hojeISO} j√° foi executada.`);

  try {
    // Leitura inicial fora da transa√ß√£o (r√°pida)
    const taskDoc = await getDoc(taskRef);
    const folgasJaMarcadasHoje = taskDoc.exists() && taskDoc.data().folgasMarcadasPara === hojeISO;

    if (folgasJaMarcadasHoje) {
      console.log(`[FOLGAS HOJE] Tarefa de marca√ß√£o para ${hojeISO} j√° foi conclu√≠da. Nenhuma a√ß√£o.`);
      return;
    }

    console.log("[FOLGAS HOJE] Buscando lista de membros atualizada do Firestore...");
    const membrosSnapshot = await getDocs(collection(db, "membros"));
    const listaCompletaMembros = [];
    membrosSnapshot.forEach(doc => {
        listaCompletaMembros.push({ nome: doc.id, ...doc.data() });
    });

    const hojeString = getDiaSemanaString(getHoje())
      .toLowerCase()
      .replace(/-feira$/, "")
      .normalize('NFD').replace(/[\u0300-\u036f]/g, "");

    // Filtra membros (Mantendo sua l√≥gica original de f√©rias)
    const membrosDeFolga = listaCompletaMembros.filter(membro => {
      if (!membro.folga || membro.deFerias) return false; 
      const diaFolgaNormalizado = membro.folga.toLowerCase()
        .replace(/-feira$/, "")
        .normalize('NFD').replace(/[\u0300-\u036f]/g, "");
      return diaFolgaNormalizado === hojeString;
    });
    
    if (membrosDeFolga.length === 0) {
      console.log("[FOLGAS HOJE] Nenhum membro de folga hoje. Definindo trava.");
      await setDoc(taskRef, { folgasMarcadasPara: hojeISO }, { merge: true });
      return;
    }

    console.log(`%c[FOLGAS HOJE] ${membrosDeFolga.length} membro(s) de folga encontrados. Preparando opera√ß√£o blindada...`, 'color: #8e44ad; font-weight: bold;');

    const presencaRef = doc(db, "presencas", hojeISO);
    const pontosSemanaisRef = doc(db, "semanas", "pontosSemanais");
    const isDomingo = getHoje().getDay() === 0;
    
    // --- TRANSA√á√ÉO BLINDADA ---
    await runTransaction(db, async (transaction) => {
        // LEITURA OBRIGAT√ìRIA
        const presencaSnap = await transaction.get(presencaRef);
        const existePresenca = presencaSnap.exists();
        
        // Acumulador para o update √∫nico
        const updatesParaPresenca = {};

        for (const membro of membrosDeFolga) {
            const nome = membro.nome;
            const equipe = membro.equipe;
            const membroRef = doc(db, "membros", nome);

            // Prepara o dado para o documento de presen√ßas
            updatesParaPresenca[nome] = new Date();
            
            // Atualiza membro
            transaction.update(membroRef, { 
              streak: increment(1),
              moedas: increment(recompensasConfig.focoDiario || 100)
            });

            // Atualiza pontos da equipe
            if (equipe && !isDomingo && pontosSemanais.hasOwnProperty(equipe)) {
                transaction.update(pontosSemanaisRef, { [equipe]: increment(1) });
            }
        }
        
        // ESCRITA INTELIGENTE (BLINDAGEM)
        if (Object.keys(updatesParaPresenca).length > 0) {
            if (existePresenca) {
                // Se j√° existe, UPDATE (n√£o apaga ningu√©m)
                transaction.update(presencaRef, updatesParaPresenca);
            } else {
                // Se n√£o existe, SET (cria)
                transaction.set(presencaRef, updatesParaPresenca, { merge: true });
            }
        }
        
        // Trava a tarefa
        transaction.set(taskRef, { folgasMarcadasPara: hojeISO }, { merge: true });
    });

    console.log(`[FOLGAS HOJE] Lote de dados conclu√≠do com sucesso.`);
    
    // --- SUA L√ìGICA DE FEED E CACHE (MANTIDA ORIGINAL) ---
    const pontosDocDepois = await getDoc(pontosSemanaisRef);
    const pontosFeed = pontosDocDepois.exists() ? pontosDocDepois.data() : { abelha: 0, joaninha: 0, vagalume: 0 };
    
    for (const membro of membrosDeFolga) {
      const nome = membro.nome;
      const equipe = membro.equipe;

      const streakAntes = streaksCache[nome] || 0;
      const streakDepois = streakAntes + 1;
      streaksCache[nome] = streakDepois;

      const niveisMedalha = Object.keys(medalhas).map(Number).sort((a, b) => a - b);
      for (const nivel of niveisMedalha) {
          if (streakDepois >= nivel && streakAntes < nivel) {
              const medalha = medalhas[nivel];
              await adicionarEventoAoFeed(
                  'medalha',
                  'üèÖ Nova Conquista!',
                  `<strong>${nome}</strong> alcan√ßou <strong>${streakDepois} dias</strong> de foco e ganhou a medalha ${medalha.emoji} <strong>${medalha.nome}</strong>!`,
                  { nomeMembro: nome, medalha: medalha.nome }
              );
              break; 
          }
      }

      let textoFeed;
      if (equipe && !isDomingo && Object.keys(equipes).includes(equipe)) {
          const nomeEquipeCapitalizado = equipe.charAt(0).toUpperCase() + equipe.slice(1);
          textoFeed = `A caixa de sele√ß√£o de <strong>${nome}</strong> foi marcada automaticamente, pois hoje √© o seu dia de folga. Isso garante +1 ponto para a equipe <strong>${nomeEquipeCapitalizado}</strong>, totalizando <strong>${pontosFeed[equipe]}</strong> pontos! Bom descanso <strong>${nome}</strong>!!`;
      } else {
          textoFeed = `A caixa de sele√ß√£o de <strong>${nome}</strong> foi marcada automaticamente, pois hoje √© o seu dia de folga. Bom descanso!`;
      }

      await adicionarEventoAoFeed(
          'geral',
          'üå¥ Dia de Descanso Merecido!',
          textoFeed,
          { nomeMembro: nome }
      );
    }
    
    membrosDeFolga.forEach(membro => {
        const checkbox = document.getElementById(membro.nome);
        if (checkbox && !checkbox.checked) checkbox.checked = true;
        if (membro.equipe && !isDomingo) pontosSemanais[membro.equipe]++;
    });

  } catch (error) {
    console.error(`[FOLGAS HOJE] Erro cr√≠tico na opera√ß√£o de folgas para ${hojeISO}.`, error);
  }
}

// --- NOVA FUN√á√ÉO: Gerencia o fluxo ap√≥s marcar o foco ---
async function gerenciarFluxoPosFoco() {
    if (!currentUser) return;

    try {
        // Lista de tipos que j√° t√™m popups pr√≥prios (ignorar aqui)
        const tiposExcluidos = ["moedas", "recompensa_lider", "recompensa_membro", "medalha-presente"];

        const q = query(
            collection(db, "notificacoes"),
            where("destinatarioId", "==", currentUser),
            where("lida", "==", false),
            where("tipo", "not-in", tiposExcluidos)
        );

        const querySnapshot = await getDocs(q);

        if (!querySnapshot.empty) {
            console.log("Foco registrado. Notifica√ß√µes encontradas. Abrindo modal...");
            
            // ATIVA A TRAVA
            fluxoNotificacaoFoco = true; 

            // 1. Muda o texto e AGUARDA 2 SEGUNDOS
            updateLoadingOverlayText("Aproveite para ler suas notifica√ß√µes");
            
            // Pausa a execu√ß√£o por 2000 milissegundos (2 segundos)
            await new Promise(resolve => setTimeout(resolve, 2000)); 
            
            // 2. Abre o modal de notifica√ß√µes (s√≥ depois da pausa)
            openModal('notificacoes-modal');
            
        } else {
            console.log("Foco registrado. Sem notifica√ß√µes. Verificando Loteria...");
            // Se n√£o tem notifica√ß√µes, verifica a loteria imediatamente (com um pequeno delay visual)
            setTimeout(verificarNudgeLoteria, 1500);
        }

    } catch (error) {
        console.error("Erro ao verificar notifica√ß√µes p√≥s-foco:", error);
    }
}

window.marcarCheckbox = async function (nome) {
    const membroInfo = todosMembros.find(m => m.nome === nome);
    if (membroInfo && membroInfo.deFerias) {
        mostrarPopup("üå¥ Em F√©rias", "Membros de f√©rias n√£o podem registrar o foco. Aproveite seu descanso!", 4000);
        const checkbox = document.getElementById(nome);
        if (checkbox) checkbox.checked = false;
        return;
    }
    if (checkboxLocks[nome]) {
        const checkboxOriginal = document.getElementById(nome);
        if (checkboxOriginal) checkboxOriginal.checked = !checkboxOriginal.checked;
        return;
    }
    checkboxLocks[nome] = true;

    const checkbox = document.getElementById(nome);
    const membroAlvo = todosMembros.find(m => m.nome === nome);
    if (!checkbox || !membroAlvo) {
        checkboxLocks[nome] = false;
        return;
    }

    const podeMarcar = () => {
        if (userRole === 'lider') return true;
        if (userRole === 'lider-equipe' && membroAlvo.equipe === userTeam) return true;
        if (userRole === 'membro' && currentUser === nome) return true;
        return false;
    };

    if (!podeMarcar()) {
        checkbox.checked = !checkbox.checked;
        mostrarPopup("üö´ Acesso Negado", "Voc√™ n√£o tem permiss√£o para alterar o foco de outro membro.", 4000);
        checkboxLocks[nome] = false;
        return;
    }

    // 1. MOSTRA O OVERLAY IMEDIATAMENTE AO CLICAR
    showLoadingOverlay("Aguarde um segundo...");

    const streakAntes = streaksCache[nome] || 0;
    const hoje = getHoje();
    const isDomingo = hoje.getDay() === 0;
    const acao = checkbox.checked ? 'adicionar' : 'remover';
    const equipeDoMembro = membroAlvo.equipe;

    const diaDaSemanaString = getDiaSemanaString(hoje);
    if (acao === 'remover' && membroAlvo.folga === diaDaSemanaString) {
        folgasManualmenteRemovidas[nome] = true;
    }

    // Fila para guardar os popups que ser√£o exibidos DEPOIS
    let popupsParaMostrar = [];

    try {
        // --- IN√çCIO DO PROCESSO ASS√çNCRONO ---
        const { streakAtual, novosPontosEquipe } = await verificarConquista(nome, acao, equipeDoMembro, isDomingo);
        
        streaksCache[nome] = streakAtual;
        if (equipeDoMembro && pontosSemanais.hasOwnProperty(equipeDoMembro)) {
            pontosSemanais[equipeDoMembro] = novosPontosEquipe;
        }
        
        atualizarStreakVisualMembro(nome, streakAtual);
      
        if (acao === 'adicionar') {
            const niveisMedalha = Object.keys(medalhas).map(Number).sort((a, b) => a - b);
            let novaMedalhaConquistada = false;
            for (const nivel of niveisMedalha) {
                if (streakAtual >= nivel && streakAntes < nivel) {
                    const medalha = medalhas[nivel];
                    const mensagem = `Parab√©ns, ${nome}! Voc√™ alcan√ßou ${streakAtual} dias de foco e conquistou a medalha ${medalha.emoji} ${medalha.nome}!`;
                    
                    if (currentUser === nome) {
                        popupsParaMostrar.push({ tipo: 'medalha', titulo: "üèÖ Nova Medalha!", mensagem: mensagem, duracao: 6000 });
                        popupsParaMostrar.push({ tipo: 'confete' });
                        novaMedalhaConquistada = true;
                    }

                    await adicionarEventoAoFeed(
                        'medalha',
                        'üèÖ Nova Conquista!',
                        `<strong>${nome}</strong> alcan√ßou <strong>${streakAtual} dias</strong> de foco e ganhou a medalha ${medalha.emoji} <strong>${medalha.nome}</strong>!`,
                        { nomeMembro: nome, medalha: medalha.nome }
                    );
                    break; 
                }
            }

            if (currentUser === nome) {
                const atraso = novaMedalhaConquistada ? 1000 : 0;
                popupsParaMostrar.push({ tipo: 'foco', titulo: "üéâ Foco Registrado", mensagem: `${nome}, parab√©ns por ter focado hoje!`, duracao: 3000, atraso: atraso });
                popupsParaMostrar.push({ tipo: 'moedas', quantidade: recompensasConfig.focoDiario || 100, atraso: atraso });
            }
            // REMOVIDO: setTimeout(verificarNudgeLoteria, 2000); 
            // A chamada da loteria agora ser√° gerenciada pela fun√ß√£o abaixo:
            await gerenciarFluxoPosFoco(); 
        } else {
            popupsParaMostrar.push({ tipo: 'removido', titulo: "‚ÑπÔ∏è Foco Removido", mensagem: `${nome}, seu foco de hoje foi removido`, duracao: 3000 });
        }

        // 1. Gera o evento no Feed (O c√≥digo VAI ESPERAR isso terminar antes de prosseguir)
        if (acao === 'adicionar' && !isDomingo) {
            if (equipeDoMembro && pontosSemanais.hasOwnProperty(equipeDoMembro)) {
                await gerarEventoDeFoco(nome, equipeDoMembro, streakAtual, novosPontosEquipe);
            } else {
                await gerarEventoDeFocoIndividual(nome, streakAtual);
            }
        }
        
        // 2. Atualiza a √Årvore e Barras
		await atualizarResumo();

        // 3. Feedback Visual e Sonoro (COM L√ìGICA DE TRAVA)
        if (!fluxoNotificacaoFoco) {
            // S√≥ mostra a mensagem final se N√ÉO tiver notifica√ß√µes pendentes
            if (acao === 'adicionar') {
                updateLoadingOverlayText("Maravilha, o foco foi registrado!");
                if (currentUser === nome) tocarSom('som-check');
            } else {
                updateLoadingOverlayText("Tudo bem, foco removido!");
            }
            // Pequena pausa apenas se for fechar agora
            await new Promise(resolve => setTimeout(resolve, 500));
        } 
        // O bloco 'else' foi removido para n√£o tocar o som enquanto o modal abre

    } catch (error) {
        console.error("Erro no fluxo principal de marcarCheckbox:", error);
        checkbox.checked = !checkbox.checked;
        // Em caso de erro, for√ßa o fechamento e reseta a trava
        fluxoNotificacaoFoco = false;
        hideLoadingOverlay(); 
        
    } finally {
        // S√ì fecha o overlay se a trava N√ÉO estiver ativa
        if (!fluxoNotificacaoFoco) {
            hideLoadingOverlay();
        }
        checkboxLocks[nome] = false;
    }

    // O c√≥digo abaixo, que mostra os popups de medalha e moedas, continua o mesmo.
    if (popupsParaMostrar.length > 0) {
        // Aguarda um pequeno instante para a anima√ß√£o de fade-out do overlay terminar
        await new Promise(resolve => setTimeout(resolve, 350)); 

        popupsParaMostrar.forEach(popupData => {
            const executarPopup = () => {
                switch (popupData.tipo) {
                    case 'moedas':
                        mostrarPopupMoedas(popupData.quantidade);
                        break;
                    case 'confete':
                        dispararConfete();
                        tocarSom('som-conquista');
                        break;
                    default:
                        mostrarPopup(popupData.titulo, popupData.mensagem, popupData.duracao);
                }
            };

            if (popupData.atraso) {
                setTimeout(executarPopup, popupData.atraso);
            } else {
                executarPopup();
            }
        });
    }
}

// CORRIGIDO E FINAL: Usa o card popup e verifica o usu√°rio logado.
// VERS√ÉO CORRIGIDA (v2) - L√≥gica de folga inteligente
async function verificarEProcessarFolgaDoDiaAtual() {
  if (!currentUser) return;

  try {
    const membroAtual = todosMembros.find(m => m.nome === currentUser);
    if (!membroAtual || !membroAtual.folga) return;

    // 1. Normaliza o dia de hoje (ex: "sexta-feira" -> "sexta")
    const hojeNormalizado = getDiaSemanaString()
      .toLowerCase()
      .replace(/-feira$/, "")
      .normalize('NFD').replace(/[\u0300-\u036f]/g, "");

    // 2. Normaliza o dia de folga salvo no banco de dados
    const folgaMembroNormalizada = membroAtual.folga
      .toLowerCase()
      .replace(/-feira$/, "")
      .normalize('NFD').replace(/[\u0300-\u036f]/g, "");
    
    // 3. Compara os dois valores j√° normalizados
    if (folgaMembroNormalizada === hojeNormalizado) {
      const mensagem = "Como hoje √© sua folga, sua caixa de sele√ß√£o foi marcada automaticamente para voc√™. Aproveite!";
      // ID √öNICO ADICIONADO: 'aviso_hoje_folga'
      mostrarCardPopup("üå¥ Bom Descanso!", mensagem, null, "Grupo √âpicos", "aviso_hoje_folga");
    }
  } catch (error) {
    console.error("Erro ao verificar popup de folga do dia atual:", error);
  }
}

async function marcarFolgaAutomatica(membro) {
  if (!membro || !membro.nome) return;

  const nome = membro.nome;
  const hojeISO = getHojeISO();
  const membroRef = doc(db, "membros", nome);
  const presencaRef = doc(db, "presencas", hojeISO);
  const pontosSemanaisRef = doc(db, "semanas", "pontosSemanais");

  try {
    // --- TRANSA√á√ÉO BLINDADA ---
    const { novoStreak, novosPontosEquipe } = await runTransaction(db, async (transaction) => {
      // 1. LEITURAS
      const membroSnap = await transaction.get(membroRef);
      const presencaSnap = await transaction.get(presencaRef); // Leitura essencial
      
      if (!membroSnap.exists()) throw "Membro n√£o encontrado.";
      
      let pontosSnap;
      const equipeDoMembro = membroSnap.data().equipe;
      if (equipeDoMembro && getHoje().getDay() !== 0) {
        pontosSnap = await transaction.get(pontosSemanaisRef);
      }

      // 2. C√ÅLCULOS
      const streakAtual = (membroSnap.data().streak || 0) + 1;
      
      let pontosAtuaisEquipe = 0;
      if (equipeDoMembro && getHoje().getDay() !== 0) {
        if (pontosSnap && pontosSnap.exists()) {
          pontosAtuaisEquipe = pontosSnap.data()[equipeDoMembro] || 0;
        }
      }
      const novosPontos = pontosAtuaisEquipe + 1;

      // 3. ESCRITAS BLINDADAS
      
      // Verifica se o documento existe ANTES de escrever
      if (presencaSnap.exists()) {
          transaction.update(presencaRef, { [nome]: new Date() });
      } else {
          transaction.set(presencaRef, { [nome]: new Date() }, { merge: true });
      }

      transaction.update(membroRef, { streak: streakAtual });

      if (equipeDoMembro && getHoje().getDay() !== 0) {
        transaction.set(pontosSemanaisRef, { [equipeDoMembro]: novosPontos }, { merge: true });
        return { novoStreak: streakAtual, novosPontosEquipe: novosPontos };
      }
      
      return { novoStreak: streakAtual, novosPontosEquipe: pontosAtuaisEquipe };
    });

    // --- L√ìGICA VISUAL/FEED ORIGINAL ---
    streaksCache[nome] = novoStreak;
    atualizarStreakVisualMembro(nome, novoStreak);

    if (membro.equipe && getHoje().getDay() !== 0) {
      pontosSemanais[membro.equipe] = novosPontosEquipe;
    }

    let textoFeed;
    if (membro.equipe && Object.keys(equipes).includes(membro.equipe) && getHoje().getDay() !== 0) {
      const nomeEquipeCapitalizado = membro.equipe.charAt(0).toUpperCase() + membro.equipe.slice(1);
      textoFeed = `A caixa de sele√ß√£o de <strong>${nome}</strong> foi marcada automaticamente, pois hoje √© o seu dia de folga. Isso garante +1 ponto para a equipe <strong>${nomeEquipeCapitalizado}</strong>, totalizando <strong>${novosPontosEquipe}</strong> pontos! Bom descanso <strong>${nome}</strong>!!`;
    } else {
      textoFeed = `A caixa de sele√ß√£o de <strong>${nome}</strong> foi marcada automaticamente, pois hoje √© o seu dia de folga. Bom descanso!`;
    }

    await adicionarEventoAoFeed(
      'geral',
      'üå¥ Dia de Descanso Merecido!',
      textoFeed,
      { nomeMembro: nome }
    );
    
    console.log(`Folga de ${nome} marcada com sucesso.`);

  } catch (error) {
    console.error(`Erro ao marcar folga autom√°tica para ${nome}:`, error);
  }
}
  
  window.resetarTudo = async function() {
    if (!confirm('‚ö†Ô∏è ATEN√á√ÉO: Voc√™ est√° prestes a resetar TODOS os dados!\nIsso apagar√° todo o hist√≥rico e pontos.\n\nDeseja continuar?')) return;
    try {
      // Resetar dados no Firebase
      const presencasSnapshot = await getDocs(collection(db, "presencas"));
      for (const doc of presencasSnapshot.docs) await deleteDoc(doc.ref);
      
      // Apagar documento de pontos semanais
      const pontosRef = doc(db, "semanas", "pontosSemanais");
      const pontosSnap = await getDoc(pontosRef);
      if (pontosSnap.exists()) {
        await deleteDoc(pontosRef);
      }
      
      // ADICIONAR RESET DO RANKING GERAL
      const rankingRef = doc(db, "ranking", "geral");
      await setDoc(rankingRef, { abelha: 0, joaninha: 0, vagalume: 0 });
      
      // Resetar √Årvore √âpica
      const arvoreRef = doc(db, "arvoreEpica", "progresso");
      await deleteDoc(arvoreRef);
      
      // Resetar streaks
      const streaksSnapshot = await getDocs(collection(db, "streak"));
      for (const doc of streaksSnapshot.docs) await deleteDoc(doc.ref);
      
      // Resetar vari√°veis locais
      pontosSemanais.abelha = 0;
      pontosSemanais.joaninha = 0;
      pontosSemanais.vagalume = 0;
      
      // RESETAR RANKING GERAL LOCAL
      rankingGeral.abelha = 0;
      rankingGeral.joaninha = 0;
      rankingGeral.vagalume = 0;
      
      // Recarregar dados atualizados
      await carregarPresenca();
      await carregarTotalDias();
      await carregarPontosSemanais();
      await carregarRankingGeral();
      await carregarArvoreEpica();
      
      // Atualizar UI
      atualizarPlacarSemanal();
      atualizarRankingGeral();
      atualizarMedalhas();
      atualizarExibicaoArvore();
      
      mostrarPopup("‚úÖ Reset Completo", "Todos os dados foram resetados com sucesso!", 5000);
    } catch (error) {
      console.error("Erro ao resetar dados:", error);
      mostrarPopup("‚ùå Erro no Reset", "Ocorreu um erro ao tentar resetar os dados.", 5000);
    }
  }

  window.resetarDia = async function(automatico = false) {
    if (resetEmAndamento) return;
    resetEmAndamento = true;
    
    // Se for manual, pede confirma√ß√£o
    if (!automatico && !confirm('‚ö†Ô∏è ATEN√á√ÉO: Voc√™ est√° prestes a desmarcar TODOS os checkboxes do dia atual e zerar o contador do dia.\n\nIsso n√£o afetar√° os pontos semanais ou streaks.\n\nDeseja continuar?')) {
      resetEmAndamento = false;
      return;
    }
    
    try {
      // Desmarcar todas as checkboxes VISUALMENTE
      todosMembros.forEach(membro => { 
        const nome = membro.nome;
        const checkbox = document.getElementById(nome);
        if (checkbox) {
          checkbox.checked = false;
          const label = checkbox.nextElementSibling;
          if (label) {
            label.classList.remove('checked');
          }
        }
      });
      
      // --- CORRE√á√ÉO CR√çTICA AQUI ---
      // S√≥ apagamos o documento do banco de dados se for um RESET MANUAL.
      // Na virada de dia autom√°tica, n√£o precisamos apagar, pois o sistema
      // passar√° a usar um novo ID de documento (a data de amanh√£).
      if (!automatico) {
          const hojeISO = getHojeISO();
          const presencaRef = doc(db, "presencas", hojeISO);
          await deleteDoc(presencaRef);
          console.log("Documento de presen√ßa apagado MANUALMENTE.");
          
          mostrarPopup("‚úÖ Dia Resetado", "Todos os checkboxes foram desmarcados e o dia foi zerado.", 5000);
      } else {
          console.log("Rotina de virada de dia: Interface limpa, aguardando carregamento da nova data.");
      }
      
      // Atualizar a interface
      if (document.getElementById("contadorGeral")) {
        document.getElementById("contadorGeral").textContent = "0 √©picos focaram hoje!";
        document.getElementById("progresso-barra").style.width = "0%";
      }
      
      // Atualizar resumos das equipes
      atualizarPlacarSemanal();
      
      await Promise.all([
        carregarStreaks(),
      ]);
      
    } catch (error) {
      console.error("Erro ao resetar o dia:", error);
      if (!automatico) mostrarPopup("‚ùå Erro", "Ocorreu um erro ao resetar o dia.", 5000);
    } finally {
        resetEmAndamento = false;
    }
  }
  
  async function limparColecaoSemanas() {
    try {
      const semanasRef = collection(db, "semanas");
      const querySnapshot = await getDocs(semanasRef);
      querySnapshot.forEach(async (docSnap) => {
        if (docSnap.id !== "pontosSemanais") {
          console.warn(`Apagando documento indesejado na cole√ß√£o 'semanas': ${docSnap.id}`);
          await deleteDoc(doc(db, "semanas", docSnap.id));
        }
      });
    } catch (error) {
      console.error("Erro ao limpar cole√ß√£o 'semanas':", error);
    }
  }

  async function limparMuralSemanal() {
    try {
      // Verificar se √© segunda-feira
      const hoje = getHoje();
      if (hoje.getDay() !== 1) return;

      // Obter a semana passada
      const semanaPassada = new Date(hoje);
      semanaPassada.setDate(semanaPassada.getDate() - 7);
      const numeroSemanaPassada = getSemanaAtual(semanaPassada).numero;

      // Buscar mensagens antigas
      const q = query(collection(db, "mural"), 
                    where("semana", "<", numeroSemanaPassada));
      
      const querySnapshot = await getDocs(q);
      const batch = writeBatch(db);
      
      querySnapshot.forEach(doc => {
        batch.delete(doc.ref);
      });

      await batch.commit();
      console.log(`Mural limpo: ${querySnapshot.size} mensagens antigas removidas`);
    } catch (error) {
      console.error("Erro ao limpar mural:", error);
    }
  }

  // ===== FUN√á√ïES PARA A √ÅRVORE √âPICA =====
  const fasesArvore = [
    { dias: 1, nome: "Semente", emoji: "üå±", desc: "A jornada come√ßa com um √∫nico dia de foco. Vamos plantar nossa semente e cultivar nossa dedica√ß√£o di√°ria!" },
    { dias: 15, nome: "Broto", emoji: "üåø", desc: "Com 15 dias consecutivos, nosso esfor√ßo come√ßa a brotar. Vamos continuar regando nossa determina√ß√£o!" },
    { dias: 60, nome: "√Årvore", emoji: "üå≥", desc: "60 dias de foco ininterrupto! Nossa √°rvore cresce forte, simbolizando nossa consist√™ncia e perseveran√ßa." },
    { dias: 180, nome: "Flores", emoji: "üå∏", desc: "180 dias de dedica√ß√£o fazem florescer resultados. Cada flor representa uma conquista em nossa jornada!" },
    { dias: 365, nome: "Frutos", emoji: "üçé", desc: "365 dias de foco cont√≠nuo! Agora colhemos os frutos do nosso trabalho √°rduo e da nossa dedica√ß√£o inabal√°vel." }
  ];
  
  let arvoreEpica = {
    consecutivos: 0,
    ultimoDia: null,
    faseAtual: 0
  };
  
  async function carregarEstadoArvore() {
    const arvoreRef = doc(db, "arvoreEpica", "progresso");
    const docSnap = await getDoc(arvoreRef);
    
    if (docSnap.exists()) {
      arvoreEpica = docSnap.data();
    } else {
      arvoreEpica = {
        consecutivos: 0,
        ultimoDia: null,
        faseAtual: 0
      };
      await setDoc(arvoreRef, arvoreEpica);

      // Salvamento da Trava para evitar duplica√ß√£o do evento "Cresceu!"
      const hojeISO = getHojeISO();
      const lockRef = doc(db, "appState", `lock_arvore_${hojeISO}`);
      await setDoc(lockRef, { processadoSucesso: true, dia: hojeISO }, { merge: true });
    }
  }
  
  // FUN√á√ÉO BLINDADA: Previne duplica√ß√£o de eventos da √Årvore
async function verificarArvoreEpica(totalCheckins) {
    if (resetEmAndamento) return;

    const hojeISO = getHojeISO();
    // Refer√™ncias do Firestore
    const lockRef = doc(db, "appState", `lock_arvore_${hojeISO}`);
    const arvoreRef = doc(db, "arvoreEpica", "progresso");
    const ontem = new Date(getHoje());
    ontem.setDate(ontem.getDate() - 1);
    const ontemISO = formatarDataISO(ontem);

    // IDs √öNICOS para o feed deste dia (A Chave da Solu√ß√£o)
    // Isso garante que s√≥ exista UM card de "Cresceu" por dia no banco de dados.
    const idFeedCresceu = `arvore_cresceu_${hojeISO}`;
    const idFeedPerdeu = `arvore_perdeu_${hojeISO}`;

    let acaoParaExecutar = null; 
    let dadosParaFeed = null;

    try {
        await runTransaction(db, async (transaction) => {
            // 1. LEITURA AT√îMICA: L√™ o Lock E o Estado da √Årvore ao mesmo tempo
            const lockSnap = await transaction.get(lockRef);
            const arvoreSnap = await transaction.get(arvoreRef);
            
            const jaProcessadoHoje = lockSnap.exists();
            let estadoArvore = arvoreSnap.exists() ? arvoreSnap.data() : { consecutivos: 0, ultimoDia: null, faseAtual: 0 };
            
            // CEN√ÅRIO A: Atingiu a meta (>= 10)
            if (totalCheckins >= 10) {
                // S√≥ processa se AINDA N√ÉO tem a trava de hoje
                if (!jaProcessadoHoje) {
                    // L√≥gica de crescimento DENTRO da transa√ß√£o
                    let novosDias = estadoArvore.consecutivos;
                    let titulo, corpo;

                    // --- CORRE√á√ÉO BUG RESET √ÅRVORE ---
                    // Verifica se √© o primeiro dia
                    if (!estadoArvore.ultimoDia) {
                        novosDias = 1;
                        titulo = 'üå≥ A √Årvore Come√ßou a Crescer!';
                        corpo = `Com a for√ßa de ${totalCheckins} membros hoje, plantamos nossa semente. Estamos com <strong>1 dia</strong>.`;
                    } 
                    // Verifica se cresceu ONTEM (Fluxo Normal)
                    else if (estadoArvore.ultimoDia === ontemISO) {
                        novosDias++;
                        titulo = 'üå≥ A √Årvore Cresceu!';
                        corpo = `Com a for√ßa de ${totalCheckins} membros hoje, nossa √°rvore avan√ßou! Estamos com <strong>${novosDias} dias</strong> consecutivos.`;
                    } 
                    // PROTE√á√ÉO DE SEGURAN√áA: Se por algum motivo o banco diz que o √∫ltimo dia J√Å √â HOJE
                    // (Ex: Concorr√™ncia com Po√ß√£o), N√ÉO reseta. Apenas mant√©m ou ajusta.
                    else if (estadoArvore.ultimoDia === hojeISO) {
                        console.log("Prote√ß√£o de √Årvore: Tentativa de crescimento duplicada detectada e evitada. Mantendo sequ√™ncia.");
                        // N√£o faz nada (sai da l√≥gica de altera√ß√£o), pois j√° cresceu hoje.
                        return; 
                    }
                    // Caso contr√°rio, a√≠ sim reseta
                    else {
                        novosDias = 1;
                        titulo = 'üå± Novo Plantio!';
                        corpo = `A sequ√™ncia anterior foi quebrada, mas hoje atingimos a meta novamente! A √Årvore √âpica recome√ßa sua jornada com <strong>1</strong> dia.`;
                    }
                    // ----------------------------------

                    // Prepara atualiza√ß√µes
                    transaction.set(lockRef, { processadoSucesso: true, dia: hojeISO });
                    transaction.update(arvoreRef, { 
                        consecutivos: novosDias,
                        ultimoDia: hojeISO
                    });

                    // Define dados para postar no feed DEPOIS da transa√ß√£o
                    acaoParaExecutar = 'cresceu';
                    dadosParaFeed = { titulo, corpo, dias: novosDias };
                    
                    // Atualiza vari√°vel local para refletir na UI imediatamente
                    arvoreEpica.consecutivos = novosDias;
                    arvoreEpica.ultimoDia = hojeISO;
                }
            } 
            // CEN√ÅRIO B: Perdeu a meta (< 10)
            else {
                // S√≥ processa a perda se a trava EXISTIA (significa que tinha crescido e caiu)
                if (jaProcessadoHoje) {
                    // Prote√ß√£o contra bug de carregamento
                    if (totalCheckins < 5 && todosMembros.length > 5) return;

                    // Recalcula dias (perde o de hoje)
                    const diasAntes = estadoArvore.consecutivos;
                    const diasCorrigidos = Math.max(0, diasAntes - 1);
                    const novoUltimoDia = (diasCorrigidos > 0) ? ontemISO : null;

                    transaction.delete(lockRef); // Remove a trava para permitir crescer de novo se recuperarem
                    transaction.update(arvoreRef, { 
                        consecutivos: diasCorrigidos,
                        ultimoDia: novoUltimoDia
                    });

                    acaoParaExecutar = 'perdeu';
                    dadosParaFeed = { 
                        diasAntes, 
                        diasDepois: diasCorrigidos,
                        totalCheckins
                    };
                    
                    // Atualiza vari√°vel local
                    arvoreEpica.consecutivos = diasCorrigidos;
                    arvoreEpica.ultimoDia = novoUltimoDia;
                }
            }
        });
    } catch (e) {
        console.error("Transa√ß√£o da √Årvore falhou:", e);
        return;
    }

    // EXECU√á√ÉO DO FEED (FORA DA TRANSA√á√ÉO, MAS COM ID √öNICO)
    if (acaoParaExecutar && dadosParaFeed) {
        
        // Espera 2.5s para dar tempo de outros processos (como ponto da equipe) aparecerem
        await new Promise(resolve => setTimeout(resolve, 2500));

        if (acaoParaExecutar === 'cresceu') {
            // Usa o ID PERSONALIZADO (idFeedCresceu)
            // Se j√° existir um card "Cresceu" hoje, ele apenas atualiza o texto, n√£o cria outro!
            await adicionarEventoAoFeed(
                'arvore', 
                dadosParaFeed.titulo, 
                dadosParaFeed.corpo, 
                { dias: dadosParaFeed.dias },
                idFeedCresceu // <--- AQUI EST√Å A M√ÅGICA
            );
            
            // Verifica evolu√ß√£o de fase (mantido igual)
            verificarEvolucaoFase(arvoreEpica.consecutivos);

            // Remove qualquer card de "Perdeu For√ßa" de hoje para limpar o feed
            try { await deleteDoc(doc(db, "resumoSemanalFeed", idFeedPerdeu)); } catch(e){}

        } else if (acaoParaExecutar === 'perdeu') {
            const textoPerdeu = `O n√∫mero de focos confirmados caiu para <strong>${dadosParaFeed.totalCheckins}</strong> (o m√≠nimo √© 10). A contagem de hoje foi cancelada e voltamos para <strong>${dadosParaFeed.diasDepois} dias</strong>.`;

            // Usa o ID PERSONALIZADO (idFeedPerdeu)
            await adicionarEventoAoFeed(
                'arvore',
                'üçÇ A √Årvore Perdeu For√ßa...',
                textoPerdeu,
                { diasAntes: dadosParaFeed.diasAntes, diasDepois: dadosParaFeed.diasDepois },
                idFeedPerdeu // <--- AQUI TAMB√âM
            );
            
            // Remove o card de "Cresceu" de hoje, pois n√£o √© mais v√°lido
            try { await deleteDoc(doc(db, "resumoSemanalFeed", idFeedCresceu)); } catch(e){}
            
            verificarEvolucaoFase(arvoreEpica.consecutivos);
        }
        
        atualizarExibicaoArvore();
    } 
    // Sincroniza√ß√£o passiva (caso outro cliente tenha atualizado)
    else {
        if (totalCheckins >= 10 && arvoreEpica.ultimoDia !== hojeISO) {
             const arvoreStateRef = doc(db, "arvoreEpica", "progresso");
             const snap = await getDoc(arvoreStateRef);
             if (snap.exists()) {
                 arvoreEpica = snap.data();
                 atualizarExibicaoArvore();
             }
        }
    }
}

// Fun√ß√£o auxiliar para verificar evolu√ß√£o (CORRIGIDA: Compara hoje vs ontem)
function verificarEvolucaoFase(diasAtuais) {
    // Helper interno para descobrir o √≠ndice da fase com base num n√∫mero de dias
    const calcularIndiceFase = (dias) => {
        for (let i = fasesArvore.length - 1; i >= 0; i--) {
            if (dias >= fasesArvore[i].dias) {
                return i;
            }
        }
        return 0;
    };

    const faseHoje = calcularIndiceFase(diasAtuais);
    const faseOntem = calcularIndiceFase(diasAtuais - 1);

    // S√≥ dispara o evento se a fase de HOJE for maior que a fase que ter√≠amos ONTEM.
    // Isso garante que o evento s√≥ ocorra na transi√ß√£o exata (ex: dia 59 -> 60).
    if (faseHoje > faseOntem) {
        const novaFaseObj = fasesArvore[faseHoje];
        
        const somConquista = document.getElementById("som-conquista");
        if (somConquista) { somConquista.currentTime = 0; somConquista.play(); }
        
        mostrarPopup("üå≥ √Årvore √âpica", `Parab√©ns! A √°rvore evoluiu para: ${novaFaseObj.nome} ${novaFaseObj.emoji}`, 5000);
        dispararConfete();
        
        adicionarEventoAoFeed(
            'arvore',
            '‚ú®üå≥ A √Årvore Evoluiu!',
            `Com o esfor√ßo de todos, nossa √Årvore √âpica alcan√ßou a fase de ${novaFaseObj.emoji} <strong>${novaFaseObj.nome}</strong>! Continuem focando!`,
            { fase: novaFaseObj.nome }
        );
    }
    
    // Atualiza a vari√°vel global para manter a interface (desenho da √°rvore) correta
    arvoreEpica.faseAtual = faseHoje;
}
  
  async function carregarArvoreEpica() {
    await carregarEstadoArvore();
    atualizarExibicaoArvore();
  }
  
  function criarEstrelas() {
  const allStarsContainers = document.querySelectorAll('.stars-container');
  if (allStarsContainers.length === 0) return;

  allStarsContainers.forEach(starsContainer => {
    // Verifica se as estrelas j√° foram criadas para este cont√™iner
    if (starsContainer.children.length > 0) return;

    const starCount = 150;
    starsContainer.innerHTML = '';

    for (let i = 0; i < starCount; i++) {
      const star = document.createElement('div');
      star.classList.add('star');

      const size = Math.random() * 3 + 1;
      star.style.width = `${size}px`;
      star.style.height = `${size}px`;

      star.style.left = `${Math.random() * 100}%`;
      star.style.top = `${Math.random() * 100}%`;

      star.style.animationDelay = `${Math.random() * 4}s`;
      star.style.animationDuration = `${2 + Math.random() * 3}s`;

      starsContainer.appendChild(star);
    }
  });
}
  
  function atualizarExibicaoArvore() {
  if (!document.getElementById("stage-name")) return;

  const fase = fasesArvore[arvoreEpica.faseAtual];
  document.getElementById("stage-name").textContent = fase.nome + " " + fase.emoji;
  document.getElementById("stage-desc").textContent = fase.desc;
  document.getElementById("dias-consecutivos").textContent = arvoreEpica.consecutivos;

  const imagens = ["seed", "sprout", "tree", "flowers", "fruits"];
  imagens.forEach((img, index) => {
    const el = document.getElementById(img);
    if (el) {
      if (index === arvoreEpica.faseAtual) {
        el.style.display = "block";
      } else {
        el.style.display = "none";
      }
    }
  });

  const proximaFase = arvoreEpica.faseAtual < fasesArvore.length - 1 ? fasesArvore[arvoreEpica.faseAtual + 1] : null;
  const proximaFaseEl = document.getElementById("proxima-fase");
  if (proximaFaseEl) {
    if (proximaFase) {
      const diasFaltando = proximaFase.dias - arvoreEpica.consecutivos;
      proximaFaseEl.textContent = `Faltam ${diasFaltando} dias para ${proximaFase.nome} ${proximaFase.emoji}`;
    } else {
      proximaFaseEl.textContent = "Voc√™ alcan√ßou o n√≠vel m√°ximo!";
    }
  }

  const agora = getHoje();
  const horas = agora.getHours();
  const modoNoite = horas >= 18 || horas < 6;

  const treeSky = document.querySelector("#secao-arvore-epica .tree-sky");
  if (treeSky) {
    // CORRE√á√ÉO: Busca o cont√™iner de estrelas espec√≠fico desta se√ß√£o
    const starsArvore = treeSky.querySelector('.stars-container');

    if (modoNoite) {
      treeSky.classList.add("night-mode");
      treeSky.classList.remove("day-mode");

      criarEstrelas(); // Garante que as estrelas sejam criadas se n√£o existirem

      if (starsArvore) {
        starsArvore.style.opacity = "1"; // <--- CORRIGIDO
      }
    } else {
      treeSky.classList.remove("night-mode");
      treeSky.classList.add("day-mode");
      if (starsArvore) {
        starsArvore.style.opacity = "0"; // <--- CORRIGIDO
      }
    }
  }

  const solEl = document.getElementById("sol");
  const luaEl = document.getElementById("lua");
  if (solEl && luaEl) {
    solEl.style.opacity = modoNoite ? "0" : "1";
    luaEl.style.opacity = modoNoite ? "1" : "0";
  }
}
  
  // FUN√á√ÉO ATUALIZADA: Agora apenas detecta a mudan√ßa e chama a rotina principal.
  async function verificarMudancaData() {
    const novaData = getHojeISO();
    
    // Se dataAtual estiver vazia (primeiro carregamento), apenas define e sai.
    // Isso impede que a rotina rode no F5 (refresh) da p√°gina.
    if (dataAtual === '') {
        dataAtual = novaData;
        return;
    }

    // Verifica se a data do sistema mudou desde a √∫ltima checagem.
    if (dataAtual !== novaData) {
      // O dia mudou! Atualiza a vari√°vel de controle.
      dataAtual = novaData;
      
      console.log(`üìÖ Mudan√ßa de data detectada: ${dataAtual} -> ${novaData}`);
      
      // Chama a nossa nova fun√ß√£o "mestre" para fazer todo o trabalho pesado.
      await executarRotinaDeMeiaNoite();

    } else {
      // Se o dia n√£o mudou, apenas garantimos que o cabe√ßalho de data est√° vis√≠vel.
      atualizarDataCabecalho();
    }
  }
  
  let resetEmAndamento = false;

async function marcarFolgaColetivaDeDomingo() {
  // A fun√ß√£o s√≥ continua se for domingo (dia 0)
  if (getHoje().getDay() !== 0) {
    return;
  }

  const hojeISO = getHojeISO();
  const taskRef = doc(db, "appState", "dailyTasks");

  try {
    const taskDoc = await getDoc(taskRef);
    const domingoJaMarcado = taskDoc.exists() && taskDoc.data().domingoColetivoMarcadoPara === hojeISO;

    if (domingoJaMarcado) {
      console.log(`[DOMINGO COLETIVO] Marca√ß√£o para ${hojeISO} j√° foi feita. Apenas atualizando a tela.`);
      todosMembros.forEach(membro => {
        const checkbox = document.getElementById(membro.nome);
        if (checkbox && !checkbox.checked) {
          checkbox.checked = true;
        }
      });
      await atualizarResumo();
      return;
    }

    console.log("üåû Domingo! Executando marca√ß√£o de folga coletiva para todos os membros...");

    const batch = writeBatch(db);

    todosMembros.forEach(membro => {
      const nome = membro.nome;
      const membroRef = doc(db, "membros", nome);
      const presencaRef = doc(db, "presencas", hojeISO);

      batch.set(presencaRef, { [nome]: new Date() }, { merge: true });
      
      // <<< IN√çCIO DA ALTERA√á√ÉO (1/2): Concess√£o de Moedas >>>
      // Agora, a opera√ß√£o em lote tamb√©m incrementa as moedas de foco di√°rio.
      batch.update(membroRef, { 
        streak: increment(1),
        moedas: increment(recompensasConfig.focoDiario || 100) 
      });
      // <<< FIM DA ALTERA√á√ÉO (1/2) >>>
    });

    batch.set(taskRef, { domingoColetivoMarcadoPara: hojeISO }, { merge: true });

    await batch.commit();
    console.log(`‚úÖ Folga coletiva de domingo SALVA para ${todosMembros.length} membros.`);

    await adicionarEventoAoFeed(
        'geral',
        'üå¥ Folga Coletiva de Domingo!',
        'Hoje √© nosso dia de descanso coletivo! Todas as caixas de sele√ß√£o foram marcadas automaticamente para garantir o streak de todos. Bom descanso, √âpicos!',
        {}
    );
    
    // <<< IN√çCIO DA ALTERA√á√ÉO (2/2): L√≥gica de Verifica√ß√£o de Medalhas >>>
    // Este novo bloco de c√≥digo roda AP√ìS o salvamento no banco de dados.
    for (const membro of todosMembros) {
        const nome = membro.nome;
        // Pegamos o streak ANTES do incremento, que ainda est√° no cache local.
        const streakAntes = streaksCache[nome] || 0;
        // O novo streak √© simplesmente o anterior + 1.
        const streakDepois = streakAntes + 1;

        // Copiamos a l√≥gica exata da fun√ß√£o marcarCheckbox para verificar a conquista.
        const niveisMedalha = Object.keys(medalhas).map(Number).sort((a, b) => a - b);
        for (const nivel of niveisMedalha) {
            // Se o novo streak atingiu ou ultrapassou um n√≠vel de medalha que o streak antigo n√£o tinha,
            // ent√£o uma nova medalha foi conquistada.
            if (streakDepois >= nivel && streakAntes < nivel) {
                const medalha = medalhas[nivel];
                // Cria o evento no feed do resumo semanal.
                await adicionarEventoAoFeed(
                    'medalha',
                    'üèÖ Nova Conquista!',
                    `<strong>${nome}</strong> alcan√ßou <strong>${streakDepois} dias</strong> de foco e ganhou a medalha ${medalha.emoji} <strong>${medalha.nome}</strong>!`,
                    { nomeMembro: nome, medalha: medalha.nome }
                );
                console.log(`[DOMINGO COLETIVO] ${nome} ganhou a medalha ${medalha.nome} (${streakDepois} dias).`);
                break; // Para o loop assim que a primeira nova medalha √© encontrada.
            }
        }
    }
    // <<< FIM DA ALTERA√á√ÉO (2/2) >>>

    // Atualiza a interface visual AP√ìS salvar os dados
    todosMembros.forEach(membro => {
        const checkbox = document.getElementById(membro.nome);
        if (checkbox) {
            checkbox.checked = true;
        }
        if (streaksCache[membro.nome] !== undefined) {
            streaksCache[membro.nome]++;
        }
    });

    await atualizarResumo();

  } catch (error) {
    console.error("Erro cr√≠tico ao marcar a folga coletiva de domingo:", error);
  }
}

// NOVA FUN√á√ÉO: Processa feriados (Fixos ou Manuais)
async function processarFeriadoDoDia() {
  const hoje = getHoje();
  // Esta fun√ß√£o agora √© async, ent√£o usamos await
  const nomeFeriado = await verificarDataEspecial(hoje);

  if (!nomeFeriado) return; // Se n√£o for feriado, sai.

  const hojeISO = getHojeISO();
  const taskRef = doc(db, "appState", "dailyTasks");

  try {
    const taskDoc = await getDoc(taskRef);
    const feriadoJaProcessado = taskDoc.exists() && taskDoc.data().feriadoProcessadoPara === hojeISO;

    // L√ìGICA DO POPUP (Executa sempre, mesmo se j√° processado no banco)
    if (currentUser) {
        // Trava removida: Aparecer√° sempre se for feriado
        const mensagem = `Hoje √© <strong>${nomeFeriado}</strong>! O dia foi considerado um feriado no Grupo √âpicos.<br><br>Sua caixa de sele√ß√£o foi marcada automaticamente. Aproveite o dia para descansar ou celebrar!`;
        
        // Pequeno delay para n√£o atropelar outros popups de login
        setTimeout(() => {
            // ADICIONADO: Assinatura "Grupo √âpicos" e ID √∫nico "feriado_hoje"
            mostrarCardPopup(`üéâ Feriado: ${nomeFeriado}`, mensagem, dispararConfete, "Grupo √âpicos", "feriado_hoje");
        }, 2500);
    }

    if (feriadoJaProcessado) {
      console.log(`[FERIADO] Processamento para ${nomeFeriado} (${hojeISO}) j√° realizado.`);
      // Atualiza visualmente caso a tela tenha sido recarregada
      todosMembros.forEach(membro => {
        const checkbox = document.getElementById(membro.nome);
        if (checkbox && !checkbox.checked) checkbox.checked = true;
      });
      await atualizarResumo();
      return;
    }

    console.log(`üéâ Processando Feriado: ${nomeFeriado}...`);

    const batch = writeBatch(db);
    const presencaRef = doc(db, "presencas", hojeISO);

    // Marca presen√ßa para todos
    todosMembros.forEach(membro => {
      const nome = membro.nome;
      const membroRef = doc(db, "membros", nome);

      // Marca presen√ßa
      batch.set(presencaRef, { [nome]: new Date() }, { merge: true });
      
      // D√° moedas e streak (regras de folga)
      batch.update(membroRef, { 
        streak: increment(1),
        moedas: increment(recompensasConfig.focoDiario || 100) 
      });
    });

    // Trava a tarefa
    batch.set(taskRef, { feriadoProcessadoPara: hojeISO }, { merge: true });

    await batch.commit();

    // Gera o evento no Feed
    await adicionarEventoAoFeed(
        'geral',
        `üéâ Feriado: ${nomeFeriado}!`,
        `Hoje celebramos o <strong>${nomeFeriado}</strong>! Todas as caixas de sele√ß√£o foram marcadas automaticamente. Aproveitem o descanso, √âpicos!`,
        { feriado: true }
    );
    
    // Atualiza√ß√£o Visual Imediata (para quem est√° online na hora que o l√≠der apertar o bot√£o ou na virada do dia)
    todosMembros.forEach(membro => {
        if (streaksCache[membro.nome] !== undefined) streaksCache[membro.nome]++;
        const checkbox = document.getElementById(membro.nome);
        if (checkbox) checkbox.checked = true;
    });
    
    await atualizarResumo();
    atualizarMedalhas();

    console.log(`‚úÖ Feriado ${nomeFeriado} processado com sucesso.`);

  } catch (error) {
    console.error("Erro ao processar feriado:", error);
  }
}

// Rotina de Sorteio da Loteria (Executa apenas na Quarta-feira)
async function executarSorteioLoteria() {
    const hoje = getHoje();
    // Verifica se √© Quarta-feira (dia 3)
    if (hoje.getDay() !== 3) return;

    const lockRef = doc(db, "appState", "loteriaLock");
    const hojeISO = getHojeISO();

    try {
        // Trava de Seguran√ßa Avan√ßada
        const lockDoc = await getDoc(lockRef);
        
        if (lockDoc.exists()) {
            const dadosLock = lockDoc.data();
            
            // 1. Verifica se j√° foi CONCLU√çDO com sucesso hoje
            if (dadosLock.ultimoSorteio === hojeISO && dadosLock.status === 'concluido') {
                console.log("Sorteio da loteria j√° realizado e conclu√≠do hoje.");
                verificarPopupResultadoLoteria(); 
                return;
            }

            // 2. Verifica se est√° travado em "processando" (Crash Recovery)
            if (dadosLock.ultimoSorteio === hojeISO && dadosLock.status === 'processando') {
                 const agoraMs = new Date().getTime();
                 const inicioMs = dadosLock.timestampInicio ? dadosLock.timestampInicio.toDate().getTime() : 0;
                 
                 // Se faz menos de 5 minutos que come√ßou, respeita o processo atual (evita duplicidade)
                 if (agoraMs - inicioMs < 5 * 60 * 1000) {
                     console.log("Sorteio em andamento por outra inst√¢ncia. Aguardando...");
                     return;
                 }
                 // Se faz mais de 5 minutos, assume que travou e roda de novo
                 console.warn("‚ö†Ô∏è Detectado sorteio interrompido anteriormente. Reiniciando processo de seguran√ßa...");
            }
        }

        // Define estado como "processando" no Firestore IMEDIATAMENTE
        await setDoc(lockRef, { 
            ultimoSorteio: hojeISO, 
            status: 'processando',
            timestampInicio: new Date()
        }, { merge: true });

        console.log("üé≤ Iniciando sorteio da Loteria √âpica...");

        // 1. Sorteia 4 n√∫meros √∫nicos (1-30)
        const numerosSorteados = [];
        while (numerosSorteados.length < 4) {
            const n = Math.floor(Math.random() * 30) + 1;
            if (!numerosSorteados.includes(n)) numerosSorteados.push(n);
        }
        numerosSorteados.sort((a, b) => a - b);

        const loteriaRef = doc(db, "loteria", "estadoAtual");
        const apostasRef = collection(loteriaRef, "apostasDaEdicao");

        let ganhadores = [];
        let premioTotal = 0;
        let novaEdicao = 0;

        await runTransaction(db, async (transaction) => {
            const loteriaDoc = await transaction.get(loteriaRef);
            premioTotal = loteriaDoc.data().premioAcumulado;
            novaEdicao = loteriaDoc.data().edicao;
        });

        // Filtra apenas as apostas da edi√ß√£o atual para o sorteio
// Isso impede que apostas antigas (que n√£o foram apagadas) ganhem de novo
const qApostas = query(apostasRef, where("edicao", "==", novaEdicao));
const apostasSnap = await getDocs(qApostas);
        
        apostasSnap.forEach(doc => {
            const aposta = doc.data();
            const numerosAposta = aposta.numeros;
            
            // Verifica se acertou os 4
            const acertou = numerosAposta.every(n => numerosSorteados.includes(n));
            if (acertou) {
                ganhadores.push(aposta.membro);
            }
        });

        // Atualiza Banco de Dados
        const batch = writeBatch(db);

        if (ganhadores.length > 0) {
            // Dividir o pr√™mio
            const premioPorPessoa = Math.floor(premioTotal / ganhadores.length);
            ganhadores.forEach(ganhador => {
                const membroRef = doc(db, "membros", ganhador);
                batch.update(membroRef, { moedas: increment(premioPorPessoa) });
                
                // Notifica√ß√£o
                const notifRef = doc(collection(db, "notificacoes"));
                batch.set(notifRef, {
                    destinatarioId: ganhador,
                    remetenteNome: "Loteria",
                    tipo: 'moedas', // Reutiliza popup de moedas
                    conteudo: 'üí∞',
                    acao: `PARAB√âNS! Voc√™ acertou na Loteria e ganhou <strong>${premioPorPessoa}</strong> moedas!`,
                    lida: false,
                    timestamp: new Date()
                });
            });
            // Zera o pr√™mio para o pr√≥ximo
            batch.update(loteriaRef, { premioAcumulado: 0 });
        } else {
            // Acumula
            console.log("Nenhum ganhador. Pr√™mio acumulado.");
        }

        // =======================================================
        // ===== IN√çCIO DA ADI√á√ÉO: POSTAR RESULTADO NO FEED =====
        // =======================================================
        
        // 1. Formata os n√∫meros para ficar bonito (ex: 05 - 12 - 23 - 30)
        const numerosFormatados = numerosSorteados.map(n => String(n).padStart(2, '0')).join(' - ');
        
        let textoFeedLoteria = "";
        
        if (ganhadores.length > 0) {
            const listaNomes = ganhadores.map(g => `<strong>${g}</strong>`).join(', ');
            const premioFormatado = premioTotal.toLocaleString('pt-BR');
            
            textoFeedLoteria = `üî¢ N√∫meros sorteados: <strong>${numerosFormatados}</strong>.<br><br>üéâ <strong>TEMOS GANHADORES!</strong> Parab√©ns a ${listaNomes} que acertaram os 4 n√∫meros e dividiram o pr√™mio de <strong>üí∞ ${premioFormatado} moedas</strong>!`;
        } else {
            textoFeedLoteria = `üî¢ N√∫meros sorteados: <strong>${numerosFormatados}</strong>.<br><br>üê¢ <strong>ACUMULOU!</strong> Ningu√©m acertou os 4 n√∫meros desta vez. O pr√™mio continua crescendo para a pr√≥xima semana!`;
        }

        // 2. Cria o evento no feed (O Or√°culo ler√° isso depois)
        // Nota: O await aqui √© seguro pois adicionarEventoAoFeed cria seu pr√≥prio doc separado do batch atual
        await adicionarEventoAoFeed(
            'geral', 
            `üçÄ Resultado da Loteria (Ed. ${novaEdicao})`, 
            textoFeedLoteria, 
            { 
                subtipo: 'loteria',
                ganhadores: ganhadores,
                numeros: numerosSorteados,
                premio: premioTotal
            }
        );
        // =======================================================
        // ===== FIM DA ADI√á√ÉO =====
        // =======================================================

        // Salva Hist√≥rico e Reseta
        batch.update(loteriaRef, {
            historico: arrayUnion({
                edicao: novaEdicao,
                numeros: numerosSorteados,
                data: new Date(),
                ganhadores: ganhadores,
                premio: premioTotal
            }),
            edicao: increment(1),
            totalApostas: 0 // Reseta contador
        });

        // Salva Resultado para Popup de Hoje
        const resultadoDiaRef = doc(db, "loteria", "resultadoUltimo");
        batch.set(resultadoDiaRef, {
            numeros: numerosSorteados,
            ganhadores: ganhadores,
            premio: premioTotal,
            dataSorteio: hojeISO,
            totalApostasNaEdicao: apostasSnap.size
        });

        // Trava o sorteio como CONCLU√çDO
        batch.set(lockRef, { 
            ultimoSorteio: hojeISO,
            status: 'concluido', // <--- Importante: Marca como sucesso
            timestampFim: new Date()
        }, { merge: true });

        await batch.commit();
        console.log("‚úÖ Sorteio conclu√≠do com sucesso. N√∫meros:", numerosSorteados);

        // Mostra popup para quem est√° online no momento
        verificarPopupResultadoLoteria();

    } catch (error) {
        console.error("Erro no sorteio:", error);
    }
}

// Fun√ß√£o para mostrar o popup de resultado (Quarta-Feira)
async function verificarPopupResultadoLoteria() {
    const hojeISO = getHojeISO();
    
    // CORRE√á√ÉO V2: Usa vari√°vel vol√°til (window) em vez de sessionStorage.
    // Assim, se recarregar a p√°gina, ele aparece de novo. Mas impede duplicidade imediata.
    if (window.resultadoLoteriaExibidoAgora) {
        return;
    }
    // Marca que j√° tentou exibir nesta execu√ß√£o de p√°gina
    window.resultadoLoteriaExibidoAgora = true;

    try {
        const resultadoRef = doc(db, "loteria", "resultadoUltimo");
        const docSnap = await getDoc(resultadoRef);

        if (docSnap.exists() && docSnap.data().dataSorteio === hojeISO) {
            const data = docSnap.data();
            
            const titulo = document.getElementById('titulo-resultado-loteria');
            const corpo = document.getElementById('corpo-resultado-loteria');
            const canvasConfete = document.getElementById('confetti-loteria');

            let bolasHtml = '';
            data.numeros.forEach(n => {
                bolasHtml += `<span class="bola-loteria selecionada" style="display:inline-flex; width:40px; height:40px; font-size:1.2rem; margin:5px; cursor:default;">${n}</span>`;
            });

            let textoGanhadores = '';
            if (data.ganhadores.length > 0) {
                textoGanhadores = `<p style="color:#2ecc71; font-size:1.2rem; margin-top:15px;">üéâ <strong>GANHADORES:</strong> ${data.ganhadores.join(', ')}!</p>
                                   <p>Pr√™mio: üí∞ ${data.premio.toLocaleString('pt-BR')}</p>`;
                // Ativa confete
                if(canvasConfete) {
                    const ctx = canvasConfete.getContext('2d');
                    // (Reutilize sua fun√ß√£o de confete aqui ou crie uma simples)
                    // Vou simplificar chamando a global
                    dispararConfete(); 
                }
            } else {
                textoGanhadores = `<p style="color:#e67e22; margin-top:15px;">Ningu√©m acertou! üò≤</p>
                                   <p>O pr√™mio de <strong>üí∞ ${data.premio.toLocaleString('pt-BR')}</strong> ACUMULOU!</p>
                                   <p style="font-style:italic; margin-top:10px;">N√£o desista! Sua sorte pode mudar na pr√≥xima quarta.</p>`;
            }

            corpo.innerHTML = `
                <p>N√∫meros sorteados hoje:</p>
                <div style="display:flex; justify-content:center; margin:10px 0;">${bolasHtml}</div>
                <p style="font-size:0.9rem; color:#7f8c8d;">Total de apostas: ${data.totalApostasNaEdicao}</p>
                ${textoGanhadores}
            `;

            openModal('popup-resultado-loteria');
            sessionStorage.setItem(`resultadoLoteriaVisto_${hojeISO}`, 'true');
        }
    } catch (e) {
        console.error("Erro ao ver resultado loteria:", e);
    }
}

async function verificarPopupVesperaSorteio() {
    const hoje = getHoje();
    // Verifica se √© Ter√ßa-feira (dia 2)
    if (hoje.getDay() !== 2) return;

    // Trava de sess√£o removida: Aparecer√° sempre nas ter√ßas-feiras ao logar/atualizar

    const mensagem = `
      Amanh√£ (quarta-feira) ocorrer√° o sorteio da <strong>loteria √©pica</strong>! <br><br>
      N√£o se esque√ßa de entrar na p√°gina para conferir o resultado do sorteio e ver se voc√™ ganhou o grande pr√™mio ou se pelo menos acertou algum dos n√∫meros sorteados.
    `;
    
    mostrarCardPopup("üçÄ Sorteio Amanh√£!", mensagem, null, "Grupo √âpicos", "aviso_vespera_loteria");
}

// === FIM DO C√ìDIGO NOVO ===

// Fun√ß√£o de "Nudge" (Incentivo) - Quinta a Ter√ßa
async function verificarNudgeLoteria() {
    const hoje = getHoje();
    const diaSemana = hoje.getDay(); 
    // S√≥ mostra de Quinta (4) a Ter√ßa (2). N√£o mostra na Quarta (3) nem Domingo (0) se quiser evitar conflito
    if (diaSemana === 3) return; 

    // Verifica se o usu√°rio J√Å APOSTOU (Isso continua valendo)
    if (minhasApostasEdicao > 0) return;

    // Se n√£o apostou, mostra o incentivo

    // --- C√ÅLCULO DA DATA DO SORTEIO ---
    const diasAteQuarta = (3 - diaSemana + 7) % 7;
    const diasFaltam = diasAteQuarta === 0 ? 7 : diasAteQuarta; // Se for quarta (e a fun√ß√£o rodou), joga pra pr√≥xima
    
    const dataSorteio = new Date(hoje);
    dataSorteio.setDate(hoje.getDate() + diasFaltam);
    const dataFormatada = dataSorteio.toLocaleDateString('pt-BR');
    
    const textoData = `<strong>O sorteio ocorrer√° no dia ${dataFormatada}, faltam ${diasFaltam} dia(s)!!</strong>`;
    // ----------------------------------

    showConfirmationPopup(
        "üçÄ A Sorte est√° chamando!",
        `Voc√™ ainda n√£o fez sua aposta desta semana na Loteria √âpica.<br>
         O pr√™mio est√° acumulado em <strong>üí∞ ${dadosLoteria.premioAcumulado.toLocaleString('pt-BR')}</strong>!<br>
         ${textoData}<br>
         Vai deixar essa chance passar?`,
        () => { 
            // A√ß√£o do bot√£o "Confirmar" (Apostar Agora)
            const secao = document.getElementById('secao-loteria');
            secao.scrollIntoView({ behavior: 'smooth' });
            setTimeout(abrirModalAposta, 500);
        }
    );
    
    // Personaliza o bot√£o de cancelar
    const btnCancel = document.querySelector('#confirm-action-modal .btn-cancelar');
    if(btnCancel) btnCancel.textContent = "Quem sabe depois...";
    const btnConfirm = document.querySelector('#confirm-action-modal .auth-btn');
    if(btnConfirm) {
        btnConfirm.textContent = "Apostar Agora!";
        btnConfirm.style.backgroundColor = "#27ae60";
    }
}

async function executarRotinaDeMeiaNoite() {
  console.log(`üïõ Executando rotina da meia-noite (Executor: ${currentUser || "Sistema"})...`);

  // 1. ATIVA O BLOQUEIO GLOBAL
  await setGlobalLock(true, "üïõ Virada de dia: Atualizando sorteios e premia√ß√µes...");

  try { // Try/Catch para garantir que o bloqueio seja removido mesmo se der erro
  
  await executarResetDeTemporada();
  
  await executarSorteioLoteria();

  // =======================================================
  // ===== IN√çCIO DA CORRE√á√ÉO =====
  // =======================================================

  // PASSO 1: Premia√ß√£o de ONTEM. Deve ser a primeira coisa a rodar,
  // antes que qualquer ponto do novo dia seja computado.
  await verificarEConcederPremiacaoDiaria();

  // PASSO 2: Rodar o agendador do Or√°culo (que N√ÉO mexe em pontos).
  await gerenciarEventosAgendadosDoOraculo();

  // PASSO 3: Processar juros (tamb√©m n√£o mexe em pontos de foco).
  await processarJurosEAutolimpezaBancos();
  
  // PASSO 3.1: Limpar mensagens do dia anterior
  await limparMensagensDiariasAntigas();
  
  // PASSO 3.2: Limpar locks da √°rvore de dias passados
  await limparLocksAntigosDaArvore();

  folgasManualmenteRemovidas = {};

  const hoje = getHoje();
  const diaDaSemanaString = getDiaSemanaString(hoje);
  const isDomingo = hoje.getDay() === 0;

  // PASSO 4: Limpar os checkboxes do dia anterior.
  await resetarDia(true);

  // PASSO 5: Finalizar a competi√ß√£o da semana passada (s√≥ roda no domingo).
  await finalizarSemana();
  
  // PASSO 6.1: Verificar se √© feriado e aplicar folga
  await processarFeriadoDoDia();
  
  // --- IN√çCIO DO BLOCO DA BATALHA DE DESENHOS (BLINDADO) ---
  const diaSemanaHoje = hoje.getDay(); // 0=Dom, 1=Seg, ... 4=Qui

  try {
      // QUINTA-FEIRA (00:00) -> Novo Tema
      if (diaSemanaHoje === 4) {
          // Verifica se j√° gerou hoje
          const taskRef = doc(db, "appState", `dailyTasks_${hojeISO}`);
          const taskDoc = await getDoc(taskRef);
          
          if (!taskDoc.exists() || !taskDoc.data().temaDesenhoGerado) {
              await limparTodasAsTelasDeDesenho(); 
              const novoTema = await gerarNovoTemaDesenho();
              
              if (novoTema) {
                  await setDoc(taskRef, { temaDesenhoGerado: true }, { merge: true });
                  await setDoc(doc(db, "appState", "status"), { 
                      avisoNovoTema: { tema: novoTema, data: hojeISO } 
                  }, { merge: true });
              }
          }
      }

      // TER√áA-FEIRA (00:00) -> Julgamento
      if (diaSemanaHoje === 2) {
          // Usa o meio-dia de ontem para garantir que pegamos a semana correta sem erro de fuso
          const ontemMeioDia = new Date(hoje.getTime() - 24 * 60 * 60 * 1000);
          ontemMeioDia.setHours(12, 0, 0, 0); 
          const semanaPassada = getSemanaAtual(ontemMeioDia);
          
          const idResultado = `desenho_sem_${semanaPassada.numero}_${semanaPassada.inicio.getFullYear()}`;
          const resultadoRef = doc(db, "resultadosDesenho", idResultado);
          
          const resSnap = await getDoc(resultadoRef);
          if (!resSnap.exists()) {
              console.log("üïõ Executando julgamento de desenhos (Autom√°tico)...");
              await executarJulgamentoDesenhos();
          } else {
              console.log("üïõ Julgamento j√° realizado para esta semana.");
          }
      }
  } catch (errDesenho) {
      console.error("Erro cr√≠tico no bloco de Desenhos da meia-noite:", errDesenho);
      // O catch garante que o restante da rotina (folga coletiva, etc) continue rodando
  }
  // --- FIM DO BLOCO DA BATALHA DE DESENHOS ---

  // PASSO 6: Marcar a folga coletiva do NOVO DIA (s√≥ roda no domingo).
  await marcarFolgaColetivaDeDomingo();
  
  // PASSO 7 (NOVO): Marcar as folgas individuais do NOVO DIA (roda nos outros dias).
  // Isso garante que todas as folgas autom√°ticas sejam processadas JUNTAS.
  if (!isDomingo) {
      await executarMarcacaoAutomaticaDeFolgasDoDia();
  }

  // =======================================================
  // ===== FIM DA CORRE√á√ÉO =====
  // =======================================================

  // 4. RECARREGA E ATUALIZA TODOS OS COMPONENTES DA INTERFACE
  // Esta parte j√° estava correta. Ela vai ler as novas presen√ßas e atualizar tudo.
  atualizarDataCabecalho();
  atualizarInfoSemana();
  await carregarPontosSemanais();
  atualizarPlacarSemanal();
  await carregarArvoreEpica();
  
  // PASSO 8: AGORA, `atualizarResumo` (e `carregarTop5Semana` dentro dele)
  // s√≥ roda UMA VEZ, depois que TODAS as folgas do dia j√° foram marcadas.
  await atualizarResumo(); 

  // A fun√ß√£o verificarArvoreEpica √© chamada dentro de atualizarResumo, ent√£o a √ÅRVORE tamb√©m ser√° atualizada.

  console.log("‚úÖ Rotina da meia-noite conclu√≠da. A interface foi atualizada.");
  
  } catch (erro) {
    console.error("Erro na rotina da meia-noite:", erro);
  } finally {
    // 2. DESATIVA O BLOQUEIO GLOBAL (Sempre executa, mesmo com erro)
    await setGlobalLock(false);
  }
}

// =======================================================
// ===== FUN√á√ÉO AUXILIAR: CALEND√ÅRIO BRASILEIRO E MANUAL =====
// =======================================================
let cacheFeriadosManuais = {}; // Cache simples para evitar leituras repetidas

async function verificarDataEspecial(data) {
  const dia = String(data.getDate()).padStart(2, '0');
  const mes = String(data.getMonth() + 1).padStart(2, '0');
  const ano = data.getFullYear();
  const dataFormatada = `${dia}/${mes}`;
  const dataCompletaISO = `${ano}-${mes}-${dia}`;

  const feriadosFixos = {
    "01/01": "Confraterniza√ß√£o Universal",
    "08/03": "Dia Internacional da Mulher",
    "21/04": "Tiradentes",
    "01/05": "Dia do Trabalhador",
    "12/06": "Dia dos Namorados",
    "07/09": "Independ√™ncia do Brasil",
    "12/10": "Nossa Senhora Aparecida / Dia das Crian√ßas",
    "15/10": "Dia dos Professores",
    "02/11": "Dia de Finados",
    "15/11": "Proclama√ß√£o da Rep√∫blica",
    "20/11": "Dia da Consci√™ncia Negra",
    "24/12": "V√©spera de Natal",
    "25/12": "Natal",
    "31/12": "V√©spera de Ano Novo"
  };

  // 1. Verifica Feriados Fixos
  if (feriadosFixos[dataFormatada]) {
      return feriadosFixos[dataFormatada];
  }

  // 2. Verifica Feriados Manuais (Agendados pelo L√≠der)
  // Primeiro tenta o cache
  if (cacheFeriadosManuais[dataCompletaISO]) {
      return cacheFeriadosManuais[dataCompletaISO];
  }

  // Se n√£o estiver no cache, tenta buscar rapidinho (√∫til para chamadas ass√≠ncronas)
  try {
      const docRef = doc(db, "configuracoes", "feriadosManuais");
      const docSnap = await getDoc(docRef);
      if (docSnap.exists()) {
          const lista = docSnap.data();
          // Atualiza cache
          Object.assign(cacheFeriadosManuais, lista);
          if (lista[dataCompletaISO]) {
              return lista[dataCompletaISO];
          }
      }
  } catch (e) {
      console.warn("Erro ao verificar feriados manuais:", e);
  }

  return null;
}

async function gerarConteudoMuralComIA(periodo) {
  if (!genAI) {
    return {
      texto: "A const√¢ncia √© a ponte entre o desejo e a realiza√ß√£o. Mantenham o foco. ‚Äî Or√°culo.",
      cor: "#A0C4FF"
    };
  }

  const hoje = getHoje();
  const diaDaSemana = getDiaSemanaString(hoje);
  const diaDaSemanaNum = hoje.getDay(); // 0 = Domingo, 6 = S√°bado
  const isDomingo = diaDaSemanaNum === 0;
  const isTerca = diaDaSemanaNum === 2; // 2 = Ter√ßa-feira
  const isQuinta = diaDaSemanaNum === 4; // Quinta (Novo Tema Desenho)
  
  // CORRE√á√ÉO: Adicionado 'await' para esperar a verifica√ß√£o do feriado
  const nomeFeriado = await verificarDataEspecial(hoje);
  
  // --- NOVA L√ìGICA DE ANIVERS√ÅRIO (Prioridade M√°xima na Manh√£) ---
  let cenarioAniversario = null;
  let aniversariantesDoDia = [];

  if (periodo === 'manha') {
      const diaAtual = hoje.getDate();
      const mesAtual = hoje.getMonth() + 1;
      
      aniversariantesDoDia = todosMembros.filter(m => {
          if (!m.aniversario) return false;
          const [dia, mes] = m.aniversario.split('/').map(Number);
          return dia === diaAtual && mes === mesAtual;
      });

      if (aniversariantesDoDia.length > 0) {
          console.log("Or√°culo: Aniversariante(s) detectado(s)! Modo Celebra√ß√£o Ativado üéâ");
          const nomes = aniversariantesDoDia.map(m => m.nome).join(' e ');
          
          // Prepara dados extras para a IA usar na homenagem
          const detalhesExtras = aniversariantesDoDia.map(m => {
              let info = `${m.nome} (G√™nero: ${m.genero || 'Indefinido'})`;
              if (m.sonho) info += ` - Sonho: ${m.sonho}`;
              if (m.apelido) info += ` - Apelido: ${m.apelido}`;
              return info;
          }).join('; ');

          cenarioAniversario = {
              id: 'aniversario_especial',
              alvo: 'geral', // Posta para todos verem
              desc: `HOJE √â ANIVERS√ÅRIO DE: ${detalhesExtras}. Escreva uma mensagem emocionante e inspiradora de parab√©ns em nome de todo o Grupo √âpicos. Destaque a import√¢ncia dessa pessoa para o grupo. Deseje que o novo ciclo traga a realiza√ß√£o de seus sonhos. Seja carinhoso e festivo.`,
              nomesAniversariantes: nomes
          };
      }
  }
  // -------------------------------------------------------------

  // --- Defini√ß√£o de Cen√°rios ---
  let cenarios = {
    manha: [
        { id: 'elogio_foco_matinal', alvo: 'unico', dadoNecessario: ['filme', 'sonho', 'musica', 'curiosidade', 'apelido'], desc: "ELOGIO PESSOAL: Elogie um membro que tem sido constante, mas focando na personalidade dele." },
        { id: 'incentivo_geral_manha', alvo: 'geral', desc: "BOM DIA GERAL: Mensagem curta e energ√©tica para o grupo acordar. Foco em renova√ß√£o e oportunidade." },
        { id: 'curiosidade_membro', alvo: 'unico', dadoNecessario: ['curiosidade'], desc: "CURIOSIDADE: Comente sobre a curiosidade pessoal de um membro. Crie uma analogia motivacional baseada nessa curiosidade." },
        { id: 'desafio_do_dia', alvo: 'geral', desc: "DESAFIO R√ÅPIDO: Proponha uma mini-meta filos√≥fica para o dia (ex: sorrir mais, beber √°gua, um ato de gentileza)." },
        { id: 'foco_competicao_manha', alvo: 'geral', desc: "FOCO NA COMPETI√á√ÉO: Incentive as equipes a come√ßarem o dia pontuando." },
    ],
    tarde: [
        { id: 'reflexao_tarde', alvo: 'geral', desc: "REFLEX√ÉO TARDE: Incentive a persist√™ncia p√≥s-almo√ßo. O dia ainda n√£o acabou." },
        { id: 'analise_placar_tarde', alvo: 'geral', desc: "AN√ÅLISE DO PLACAR: Comente brevemente sobre como as m√©dias das equipes est√£o." },
        { id: 'foco_top5_tarde', alvo: 'geral', desc: "FOCO NO TOP 5: Mencione que a disputa pelo Top 5 da semana est√° acirrada." },
        { id: 'lembrete_pendente_tarde_geral', alvo: 'geral', desc: "LEMBRETE DE APOIO (TARDE): Mande uma mensagem gentil para o @todos." },
		{ id: 'comentar_desenho', desc: "COMENTAR DESENHO: Comente sobre o progresso de um dos desenhos das equipes." },
    ],
    noite: [
        { id: 'agradecimento_noite', alvo: 'geral', desc: "BOA NOITE: Agrade√ßa o esfor√ßo do grupo. Destaque um acontecimento positivo da semana." },
        { id: 'elogio_aleatorio', alvo: 'unico', dadoNecessario: ['apelido', 'me chamo'], desc: "SURPRESA: Escolha um membro aleat√≥rio e fale sobre o quanto ele √© importante para o grupo." },
        { id: 'incentivo_amanha_geral', alvo: 'geral', desc: "INCENTIVO PARA AMANH√É: Envie uma mensagem de esperan√ßa para quem teve um dia dif√≠cil." },
        { id: 'parabens_focaram_hoje_geral', alvo: 'geral', desc: "PARAB√âNS GERAL: D√™ os parab√©ns a todos que conseguiram focar hoje." },
        { id: 'reflexao_noturna', desc: "REFLEX√ÉO NOTURNA: Uma mensagem curta sobre descanso e prepara√ß√£o para o dia seguinte." },
    ]
  };
  
  // --- L√ìGICA DE QUARTA-FEIRA (LOTERIA) ---
  if (isTerca) {
      const premioAtual = dadosLoteria.premioAcumulado ? dadosLoteria.premioAcumulado.toLocaleString('pt-BR') : "Muitas";
      const cenarioLoteria = { 
          id: 'lembrete_loteria', 
          alvo: 'geral', 
          desc: `AMANH√É √â DIA DE SORTEIO DA LOTERIA: O pr√™mio est√° em üí∞ ${premioAtual} moedas! Lembre os membros de fazerem suas apostas antes do sorteio. Deseje boa sorte a todos.` 
      };
      // Adiciona o cen√°rio da loteria como op√ß√£o para todos os per√≠odos
      if(cenarios[periodo]) cenarios[periodo].push(cenarioLoteria);
  }
  
  // --- L√ìGICA DE TER√áA-FEIRA (RESULTADO DESENHO) ---
  if (isTerca) {
      const cenarioResultadoDesenho = {
          id: 'comentario_resultado_desenho',
          alvo: 'geral',
          desc: "RESULTADO DA BATALHA DE ARTE: Hoje √© dia de resultado! Comente brevemente que voc√™ analisou as obras de arte das equipes com muito cuidado. Diga que a criatividade foi impressionante (ou que precisam melhorar, seja sincero). Parabenize a equipe vencedora, diga para todos apreciarem as telas de desenho, e informe que quinta-feira ser√° divulgado o tema da pr√≥xima batalha de desenhos."
      };
      if(cenarios[periodo]) cenarios[periodo].push(cenarioResultadoDesenho);
  }

  // --- L√ìGICA DE QUINTA-FEIRA (NOVO TEMA DESENHO) ---
  if (isQuinta) {
      const cenarioNovoTema = {
          id: 'aviso_novo_tema_desenho',
          alvo: 'geral',
          desc: "NOVO TEMA DE DESENHO: Hoje √© Quinta-feira, dia de novo tema na Batalha de Desenhos! Incentive as equipes a correrem para a tela de pintura. Diga que est√° ansioso para ver o que a imagina√ß√£o deles vai criar."
      };
      if(cenarios[periodo]) cenarios[periodo].push(cenarioNovoTema);
  }
  
  // --- L√ìGICA DE DOMINGO (Substitui cen√°rios de competi√ß√£o por descanso) ---
  if (isDomingo) {
      console.log("Or√°culo: Modo Domingo Ativado üåû");
      // Limpa cen√°rios competitivos e adiciona cen√°rios de domingo
      cenarios = {
          manha: [
              { id: 'domingo_bom_dia', alvo: 'geral', desc: "DOMINGO DE PAZ: Deseje um bom dia de descanso. Lembre que hoje √© dia de recarregar as energias e que a folga coletiva √© merecida." },
              { id: 'domingo_reflexao', alvo: 'geral', desc: "REFLEX√ÉO DE DOMINGO: Diga aos membros o quanto √© importante e necess√°rio se conectar com o descanso de hoje." }
          ],
          tarde: [
              { id: 'domingo_tarde_leve', alvo: 'geral', desc: "TARDE LEVE: Sugira que aproveitem a tarde para hobbies, fam√≠lia ou apenas n√£o fazer nada." },
              { id: 'domingo_preparacao', alvo: 'geral', desc: "MENTALIDADE: Comente que o descanso de hoje √© o combust√≠vel para a vit√≥ria de amanh√£." }
          ],
          noite: [
              { id: 'domingo_boa_semana', alvo: 'geral', desc: "PREPARA√á√ÉO PARA SEGUNDA: Deseje uma √≥tima semana que vai come√ßar. Diga que est√° ansioso para ver o foco de todos amanh√£." },
              { id: 'domingo_gratidao', alvo: 'geral', desc: "GRATID√ÉO: Agrade√ßa pela semana que passou e pela uni√£o do grupo." }
          ]
      };
  }
  
  // --- L√ìGICA DE FERIADO (Prioridade M√°xima) ---
  if (nomeFeriado) {
      // CORRE√á√ÉO: O bloco inteiro s√≥ √© executado se o per√≠odo for 'manha'.
      // Isso impede que o modo feriado ative √† noite e cause o loop de tarefa abandonada.
      if (periodo === 'manha') {
          console.log(`Or√°culo: Modo Feriado Ativado (${nomeFeriado}) üéâ`);
          
          const cenarioFeriado = { 
              id: 'feriado_especial', 
              alvo: 'geral', // For√ßa o alvo geral
              dadoNecessario: [], // N√£o precisa de dados de membros
              desc: `DATA COMEMORATIVA MUITO IMPORTANTE: Hoje √© ${nomeFeriado}. 
              INSTRU√á√ÉO ESPECIAL: Escreva uma mensagem profunda, educativa e inspiradora sobre a import√¢ncia hist√≥rica e cultural deste dia. 
              N√£o seja superficial. Dedique 2 a 3 par√°grafos para falar sobre o tema.
              Fale DIRETAMENTE e OBRIGATORIAMENTE para o grupo todo (utilizando '@todos'), sem mencionar membros individuais espec√≠ficos para n√£o desviar o foco da causa.
              Termine com uma mensagem de reflex√£o sobre como esse dia nos torna humanos melhores.` 
          };
          
          // For√ßa o feriado OBRIGATORIAMENTE e EXCLUSIVAMENTE na manh√£
          cenarios[periodo] = [cenarioFeriado];
      }
  }
  
  // --- Carregamento de Hist√≥rico ---
  let coresRecentes = [];
  try {
    const qCores = query(collection(db, "mural"), where("userId", "==", "Or√°culo"), orderBy("timestamp", "desc"), limit(10));
    const coresSnapshot = await getDocs(qCores);
    coresSnapshot.forEach(doc => coresRecentes.push(doc.data().cor));
  } catch (e) { console.warn("Erro ao buscar cores recentes:", e); }

  const semanaAtual = getSemanaAtual();
  const docIdHistoricoTopicos = `oraculoTopics_${semanaAtual.numero}_${semanaAtual.inicio.getFullYear()}`;
  const historicoTopicosRef = doc(db, "appState", docIdHistoricoTopicos);
  let cenariosJaUsados = [];
  try {
    const historicoTopicosSnap = await getDoc(historicoTopicosRef);
    if (historicoTopicosSnap.exists()) {
      cenariosJaUsados = historicoTopicosSnap.data().cenariosUsados || [];
    }
  } catch (e) { console.warn("Erro ao buscar hist√≥rico de t√≥picos:", e); }

  const docIdHistoricoMencoes = `oraculoHistory_semana_${semanaAtual.numero}_${semanaAtual.inicio.getFullYear()}`;
  const historicoMencoesRef = doc(db, "appState", docIdHistoricoMencoes);
  let membrosJaMencionados = [];
  try {
    const historicoMencoesSnap = await getDoc(historicoMencoesRef);
    if (historicoMencoesSnap.exists()) {
      membrosJaMencionados = historicoMencoesSnap.data().mencionados || [];
    }
  } catch (e) { console.warn("Erro ao buscar hist√≥rico de men√ß√µes:", e); }
  
  // Busca quem j√° focou no dia
  const hojeISO = getHojeISO();
  const hojeNormalizado = getDiaSemanaString().toLowerCase().replace(/-feira$/, "").normalize('NFD').replace(/[\u0300-\u036f]/g, "");
  
  let focaramHojeNomes = [];
  try {
      const presencasSnap = await getDoc(doc(db, "presencas", hojeISO));
      if (presencasSnap.exists()) {
          focaramHojeNomes = Object.keys(presencasSnap.data());
      }
  } catch (e) { console.warn("Erro ao buscar quem focou hoje:", e); }

  // --- Carregamento de Contexto Din√¢mico ---
  let rankingVantagemTexto = "Ningu√©m completou ainda.";
  try {
      const semana = getSemanaAtual();
      const docId = `semana_${semana.numero}_${semana.inicio.getFullYear()}`;
      const advantageRef = doc(db, "vantagemSemanal", docId);
      const advantageSnap = await getDoc(advantageRef);
      if (advantageSnap.exists() && advantageSnap.data().completadoPor) {
          const completadoPor = advantageSnap.data().completadoPor;
          const ranking = Object.entries(completadoPor)
              .map(([nome, timestamp]) => ({ nome, tempo: timestamp.toDate() }))
              .sort((a, b) => a.tempo - b.tempo);
          if (ranking.length > 0) {
              rankingVantagemTexto = ranking.map((item, index) => `${index + 1}¬∫: ${item.nome}`).join(', ');
          }
      }
  } catch (e) { console.warn("Erro ao buscar dados do Jogo da Vantagem:", e); }
  
  let resumoSemanalFeedTexto = "Nenhum evento importante registrado ainda.";
  if (feedEventosCache && feedEventosCache.length > 0) {
      resumoSemanalFeedTexto = feedEventosCache.slice(0, 5).map(evento => {
        const textoLimpo = evento.texto.replace(/<[^>]*>/g, " ");
        return `- ${evento.titulo}: ${textoLimpo.trim()}`;
      }).join('\n');
  }

  const mediaAbelha = document.getElementById('media-abelha')?.textContent || 'N/A';
  const mediaJoaninha = document.getElementById('media-joaninha')?.textContent || 'N/A';
  const mediaVagalume = document.getElementById('media-vagalume')?.textContent || 'N/A';
  
  // FILTRA os membros
  const membrosDisponiveis = todosMembros.filter(m => !membrosJaMencionados.includes(m.nome));

  const listaMembrosDisponiveisTexto = membrosDisponiveis.map(m => {
      let statusFoco = "(Pendente)";
      const folgaMembroNormalizada = m.folga ? m.folga.toLowerCase().replace(/-feira$/, "").normalize('NFD').replace(/[\u0300-\u036f]/g, "") : "";
      
      if (m.deFerias) {
          // --- ALTERA√á√ÉO AQUI: Verifica o motivo ---
          if (m.motivoAusencia === 'saude') {
              statusFoco = "(EM RECUPERA√á√ÉO DE SA√öDE - Deseje melhoras!)";
          } else {
              statusFoco = "(De F√©rias)";
          }
          // ----------------------------------------
      } else if (folgaMembroNormalizada === hojeNormalizado) {
          statusFoco = "(De Folga)"; 
      } else if (focaramHojeNomes.includes(m.nome)) {
          statusFoco = "(Focou Hoje)";
      }
      
      return `- ${m.nome} (G√™nero: ${m.genero || 'Indefinido'}, Nome Real: ${m['me chamo'] || 'N/A'}, Equipe: ${m.equipe || 'N/A'}, Status: ${statusFoco})`;
}).join('\n');
  
  const contextoGeral = `
---
INFORMA√á√ïES EM TEMPO REAL (ESTADO ATUAL DO GRUPO):
- Data de Hoje: ${diaDaSemana}

Lista de Membros DISPON√çVEIS PARA MEN√á√ÉO (Use o 'Nome Real' para g√™nero e o 'Status' para l√≥gica):
${listaMembrosDisponiveisTexto || "Ningu√©m dispon√≠vel para mencionar."}
---
Placar da Competi√ß√£o Semanal (M√âDIA NIVELADA):
- Equipe Abelha: ${mediaAbelha} pontos de m√©dia.
- Equipe Joaninha: ${mediaJoaninha} pontos de m√©dia.
- Equipe Vaga-lume: ${mediaVagalume} pontos de m√©dia.
Ranking Geral de Vit√≥rias:
- Equipe Abelha: ${rankingGeral.abelha} vit√≥rias.
- Equipe Joaninha: ${rankingGeral.joaninha} vit√≥rias.
- Equipe Vaga-lume: ${rankingGeral.vagalume} vit√≥rias.
Status do Jogo da Vantagem (quem terminou primeiro):
- ${rankingVantagemTexto}
Acontecimentos Recentes (Resumo da Semana):
${resumoSemanalFeedTexto}
---
- Voc√™ s√≥ tem acesso aos membros que ainda n√£o foram mencionados esta semana.
---
  `;

  // --- L√≥gica de Sele√ß√£o de Cen√°rio e Alvo ---
  let cenarioEscolhido = null;
  let membroAlvo = null;
  let dadoEspecifico = null; 

  // [CORRE√á√ÉO] Prioridade absoluta para Anivers√°rio
  if (cenarioAniversario) {
      cenarioEscolhido = cenarioAniversario;
      // N√£o definimos 'membroAlvo' aqui para evitar conflito com a l√≥gica de 'dadoEspecifico'
      // O prompt de anivers√°rio j√° lida com os nomes diretamente.
  } else {
      // S√ì ENTRA AQUI SE N√ÉO FOR ANIVERS√ÅRIO
      let cenariosDisponiveis = cenarios[periodo] || [];
      
      let cenariosUnicosNaoUsados = cenariosDisponiveis.filter(
        c => c.alvo === 'unico' && !cenariosJaUsados.includes(c.id)
      );
      
      cenariosUnicosNaoUsados.sort(() => 0.5 - Math.random());

      let membrosElegiveis = membrosDisponiveis.filter(m => m.papel !== 'lider');

      embaralharArray(membrosElegiveis);

      for (const cenario of cenariosUnicosNaoUsados) {
        for (const membro of membrosElegiveis) {
          const dadoEncontrado = cenario.dadoNecessario.find(dadoKey => 
            membro[dadoKey] && membro[dadoKey].trim() !== ""
          );

          if (dadoEncontrado) {
            cenarioEscolhido = cenario;
            membroAlvo = membro;
            dadoEspecifico = {
              tipo: dadoEncontrado, 
              valor: membro[dadoEncontrado] 
            };
            break; 
          }
        }
        if (cenarioEscolhido) break; 
      }
      
      if (!cenarioEscolhido) {
        let cenariosGerais = cenariosDisponiveis.filter(
          c => c.alvo === 'geral' && !cenariosJaUsados.includes(c.id)
        );
        
        if (cenariosGerais.length === 0) {
          cenariosGerais = cenariosDisponiveis.filter(c => c.alvo === 'geral');
        }
        
        cenarioEscolhido = cenariosGerais[Math.floor(Math.random() * cenariosGerais.length)];
      }
  }
  
  const dadoLabels = {
    'me chamo': 'Eu me chamo',
    'apelido': 'Meu apelido √©',
    'filme': 'Meu filme favorito',
    'sonho': 'Meu maior sonho atualmente',
    'musica': 'Uma m√∫sica que gosto muito',
    'curiosidade': 'Uma curiosidade aleat√≥ria sobre mim'
  };

  // --- Constru√ß√£o do Prompt ---
  let prompt = `
    Voc√™ √© o "Or√°culo", o mentor s√°bio (cerca de 50 anos), acolhedor e carinhoso do "Grupo √âpicos".
    Sua tarefa √© escrever uma mensagem curta para o mural do grupo para o per√≠odo da '${periodo}'.

    REGRAS DE PERSONALIDADE (MENTOR ACOLHEDOR):
    1.  Use um tom que demonstre cuidado e apoio.
    2.  NUNCA se revele como uma IA. Aja 100% como uma pessoa.
    3.  Assine sempre com "‚Äî Or√°culo".
    4.  **N√ÉO SEJA REPETITIVO:** Evite come√ßar suas frases com "Lembrei...". Varie suas introdu√ß√µes.

    REGRAS DE FORMATA√á√ÉO E CONTE√öDO (OBRIGAT√ìRIAS):
    1.  **ENDERE√áAMENTO:** Use o "Nome de Usu√°rio" (o nome ANTES do par√™ntese).
    2.  **FORMATA√á√ÉO:** Use @NomeDoMembro. (Ex: @Max)
    3.  **PROIBI√á√ÉO:** NUNCA use o "Nome Real" diretamente na mensagem.
    4.  **G√äNERO:** Verifique o campo "G√™nero" ao lado do nome. Se for "Masculino", use pronomes masculinos (o, ele). Se for "Feminino", use femininos (a, ela). Use o "Nome Real" apenas como desempate se o g√™nero for Indefinido.
    5.  **3¬™ PESSOA (REGRA DE OURO):** No Mural, voc√™ fala **SOBRE** o membro para o grupo, nunca **COM** o membro.
        -   ERRADO: "Parab√©ns @Max, voc√™ mandou bem!" (Isso √© 2¬™ pessoa).
        -   CERTO: "O @Max mandou muito bem hoje!" (Isso √© 3¬™ pessoa).
        -   SEMPRE use: "Ele fez", "A @Ana conseguiu", "O foco dele". NUNCA use "Voc√™".
	6.  **CONTEXTUALIZA√á√ÉO:** Contextualize a informa√ß√£o pessoal na frase.
	7.  **L√ìGICA DE DOMINGO (MUITO IMPORTANTE):** ${isDomingo ? "HOJE √â DOMINGO (FOLGA COLETIVA). Voc√™ est√° ESTRITAMENTE PROIBIDO de falar sobre 'come√ßar o dia focando', 'pontuar para a equipe' ou 'disputa no Top 5'. Fale apenas sobre descanso, repor energias, paz, fam√≠lia e prepara√ß√£o mental para a segunda-feira." : ""}
    8.  **L√ìGICA DE FERIADO:** ${nomeFeriado ? `Hoje √© feriado de ${nomeFeriado}. Se o cen√°rio escolhido permitir, mencione o esp√≠rito desta data.` : ""}
    7.  **L√ìGICA DE FOCO:** Verifique o Status (Focou, Pendente, F√©rias, Folga) antes de elogiar o foco.
    8.  **MEN√á√ïES DE EQUIPE:** Use @equipeAbelha, @equipeJoaninha, ou @equipeVagalume.
	9.  **MEMBROS DOENTES:** Se escolher mencionar um membro com status "(EM RECUPERA√á√ÉO DE SA√öDE)", sua mensagem DEVE ser de apoio, carinho e desejando melhoras. Diga para ele descansar e n√£o se preocupar com o foco.
    
    CORES USADAS RECENTEMENTE (EVITE USAR ESTAS): ${coresRecentes.join(', ') || "Nenhuma"}
    
    **REGRA DE MEN√á√ÉO OBRIGAT√ìRIA:** Todas as suas postagens devem conter pelo menos uma men√ß√£o (@MembroAlvo ou @todos).
  `;

  if (cenarioAniversario) {
      // Prompt espec√≠fico para anivers√°rio
      prompt += `
---
    üö® TAREFA ESPECIAL DE ANIVERS√ÅRIO üö®
    
    INSTRU√á√ÉO PRIORIT√ÅRIA: ${cenarioEscolhido.desc}
    
    Lembre-se de mencionar os aniversariantes com a formata√ß√£o @NomeDoMembro.
    Esta mensagem deve ser mais longa e elaborada que o normal (3 a 4 paragr√°fos cheios de emo√ß√£o).
    Fa√ßa com que eles se sintam realmente especiais e abra√ßados pelo grupo.
---
      `;
  } else if (membroAlvo) {
    prompt += `
---
    SUA TAREFA DE HOJE (Cen√°rio: ${cenarioEscolhido.id}):
    - Membro Alvo: ${membroAlvo.nome}
    - G√™nero: ${membroAlvo.genero || 'Indefinido'}
    
    INFORMA√á√ÉO PESSOAL:
    - Pergunta: "${dadoLabels[dadoEspecifico.tipo] || dadoEspecifico.tipo}"
    - Resposta: "${dadoEspecifico.valor}"

    INSTRU√á√ÉO: Escreva uma mensagem curta (1-2 frases) baseada na descri√ß√£o: "${cenarioEscolhido.desc}".
    Contexto Adicional:
    ${contextoGeral}
---
    `;
  } else {
    prompt += `
---
    SUA TAREFA DE HOJE (Cen√°rio: ${cenarioEscolhido.id}):
    INSTRU√á√ÉO: Escreva uma mensagem curta (1-3 frases) para todo o grupo, baseada na descri√ß√£o: "${cenarioEscolhido.desc}".
    
    Contexto Geral:
    ${contextoGeral}
---
    `;
  }
  
  prompt += `
    FORMATO DA RESPOSTA (OBRIGAT√ìRIO):
    Sua resposta DEVE ser um JSON v√°lido no formato:
    {
      "texto": "SUA_MENSAGEM_AQUI",
      "cor": "#CODIGO_HEX_DA_COR"
    }
  `;

  // --- Execu√ß√£o ---
  try {
    // Substitu√≠da a chamada direta pela fun√ß√£o com rota√ß√£o de chave
    const text = await callGenerativeAIWithRetry(prompt);

    const match = text.match(/{[\s\S]*}/);
    if (!match) throw new Error("JSON n√£o encontrado na resposta da IA.");
    
    const jsonString = match[0];
    const dadosMensagem = JSON.parse(jsonString);

    if (dadosMensagem.texto && dadosMensagem.cor) {
      
      await setDoc(historicoTopicosRef, { cenariosUsados: arrayUnion(cenarioEscolhido.id) }, { merge: true });
      
      // --- Extra√ß√£o de Men√ß√µes (COM TRAVA DE SEGURAN√áA) ---
      const regexMencoesIA = /@([\w√°√©√≠√≥√∫√Å√â√ç√ì√ö√¢√™√Æ√¥√ª√Ç√ä√é√î√õ√†√®√¨√≤√π√Ä√à√å√í√ô√£√µ√É√ï√ß√á]+)/gu;
      const nomesMencionados = new Set();
      let matchRegex;
      let safetyCounter = 0; // <<< TRAVA CONTRA CONGELAMENTO

      // ADICIONADO: Verifica√ß√£o do safetyCounter dentro do while
      while ((matchRegex = regexMencoesIA.exec(dadosMensagem.texto)) !== null) {
        safetyCounter++;
        if (safetyCounter > 50) { // Se achar mais de 50 men√ß√µes, para o loop for√ßadamente
            console.warn("Or√°culo: Loop de extra√ß√£o de men√ß√µes interrompido por seguran√ßa (Anti-Travamento).");
            break;
        }

        const nome = matchRegex[1];
        if (nome !== 'todos' && nome !== 'Or√°culo' && !nome.startsWith('equipe')) {
             nomesMencionados.add(nome);
        }
      }
      // Se for anivers√°rio, garante que os aniversariantes sejam marcados como mencionados
      if (aniversariantesDoDia.length > 0) {
          aniversariantesDoDia.forEach(m => nomesMencionados.add(m.nome));
      } else if (membroAlvo) {
          nomesMencionados.add(membroAlvo.nome);
      }

      const nomesParaSalvar = Array.from(nomesMencionados);
      if (nomesParaSalvar.length > 0) {
        await setDoc(historicoMencoesRef, { mencionados: arrayUnion(...nomesParaSalvar) }, { merge: true });
      }
      
      // Feed
      let tituloFeed = 'üßô‚Äç Uma Mensagem do Or√°culo';
      let textoFeed;
      let nomeMencionado = nomesParaSalvar.length > 0 ? nomesParaSalvar[0] : null;
	  
	  if (cenarioAniversario) {
          tituloFeed = 'üéâ Homenagem de Anivers√°rio!';
          textoFeed = `O <strong>Or√°culo</strong> deixou uma mensagem muito especial de anivers√°rio no mural para <strong>${aniversariantesDoDia.map(m => m.nome).join(' e ')}</strong>. N√£o deixe de ler!`;

      } else if (nomeMencionado) {
          textoFeed = `O <strong>Or√°culo</strong> compartilhou uma nova mensagem no mural mencionando <strong>${nomeMencionado}</strong>${nomesParaSalvar.length > 1 ? ' e outros' : ''}. D√™ uma olhada!`;
      
	  } else {
          textoFeed = 'O <strong>Or√°culo</strong> compartilhou uma nova mensagem no mural. D√™ uma olhada!';
      }
      
      const feedEventId = await adicionarEventoAoFeed('geral', tituloFeed, textoFeed, { nomeMembro: 'Or√°culo' });

      return {
        texto: dadosMensagem.texto,
        cor: dadosMensagem.cor,
        feedEventId: feedEventId
      };

    } else {
      throw new Error("Formato de JSON inv√°lido.");
    }
  } catch (error) {
    console.error("Erro no Or√°culo:", error);
    // Fallback seguro
    return {
      texto: "A jornada √© longa, mas a companhia de @todos voc√™s a torna mais leve. ‚Äî Or√°culo",
      cor: "#BDB2FF",
      feedEventId: null
    };
  }
}

// =======================================================
// ===== NOVA FUN√á√ÉO: OBT√âM TODAS AS PALAVRAS DA SEMANA (v2.0) ====
// =======================================================

/**
 * Obt√©m o array com as 7 "Palavras da Semana" para as notifica√ß√µes do Or√°culo.
 * Se as palavras ainda n√£o foram geradas, usa a IA para cri√°-las e salv√°-las.
 * @returns {Promise<string[]>} Um array com as 7 palavras positivas da semana.
 */
async function obterPalavrasDaSemanaComIA() {
  if (!genAI) {
    console.warn("IA n√£o inicializada. Usando palavras de fallback.");
    return ["Foco", "Sucesso", "Alegria", "Paz", "Amor", "Luz", "For√ßa"];
  }

  const semana = getSemanaAtual();
  const docId = `palavrasDaSemana_${semana.inicio.getFullYear()}_${semana.numero}`;
  const palavrasRef = doc(db, "appState", docId);

  try {
    const docSnap = await getDoc(palavrasRef);

    if (docSnap.exists()) {
      const palavrasDaSemana = docSnap.data().palavras;
      console.log(`Or√°culo: Palavras da semana j√° existem. Retornando lista completa.`);
      return palavrasDaSemana;
    }

    console.log("Or√°culo: Gerando novas 7 palavras positivas para a semana...");
    const prompt = `
      Sua √∫nica tarefa √© gerar uma lista de 7 palavras positivas e inspiradoras em portugu√™s do Brasil.
      As palavras devem ser curtas e motivacionais, como "Sucesso", "Conquista", "Determina√ß√£o", "Resili√™ncia", etc.
      Sua resposta DEVE ser um JSON v√°lido no formato: {"palavras": ["PALAVRA1", "PALAVRA2", "PALAVRA3", "PALAVRA4", "PALAVRA5", "PALAVRA6", "PALAVRA7"]}.
      N√£o inclua nenhuma outra explica√ß√£o ou formata√ß√£o. Apenas o JSON puro.
    `;
    
    const model = genAI.getGenerativeModel({ model: "gemini-2.5-flash-lite" });
    const result = await model.generateContent(prompt);
    const response = await result.response;
    const text = response.text().trim();
    
    const match = text.match(/{[\s\S]*}/);
    if (!match) {
      throw new Error("A IA n√£o retornou um JSON v√°lido. Resposta recebida: " + text);
    }
    
    const jsonString = match[0];
    const dadosJson = JSON.parse(jsonString);
    const novasPalavras = dadosJson.palavras;

    if (!Array.isArray(novasPalavras) || novasPalavras.length !== 7) {
      throw new Error("A IA n√£o retornou um array com 7 palavras.");
    }

    await setDoc(palavrasRef, { palavras: novasPalavras });
    console.log("Or√°culo: Novas palavras salvas para a semana:", novasPalavras);

    return novasPalavras;

  } catch (error) {
    console.error("Erro ao obter as palavras da semana:", error);
    return ["Supera√ß√£o", "Coragem", "Vit√≥ria", "Inspira√ß√£o", "Energia", "Sonhos", "Conex√£o"];
  }
}

// =======================================================
// ===== NOVA FUN√á√ÉO AJUDANTE: EMBARALHADOR COM SEMENTE ====
// =======================================================

/**
 * Embaralha um array de forma determin√≠stica usando uma semente (um n√∫mero).
 * Garante que a ordem seja a mesma sempre que a mesma semente for usada.
 * @param {Array} array O array a ser embaralhado.
 * @param {number} seed Um n√∫mero para basear o embaralhamento (ex: dia do m√™s).
 * @returns {Array} Um novo array com os elementos em ordem embaralhada.
 */
function embaralharArrayComSemente(array, seed) {
  const newArray = [...array]; // Cria uma c√≥pia para n√£o modificar o original
  for (let i = newArray.length - 1; i > 0; i--) {
    // Usa a semente para gerar um √≠ndice "pseudo-aleat√≥rio" consistente
    const j = ( (i * seed) + (seed % 5) ) % (i + 1);
    [newArray[i], newArray[j]] = [newArray[j], newArray[i]]; // Troca os elementos
  }
  return newArray;
}

  // Fun√ß√£o para atualizar o cabe√ßalho com a data
  function atualizarDataCabecalho() {
    const hoje = getHoje();
    const dataHoje = hoje.toLocaleDateString('pt-BR', { 
      weekday: 'long', 
      day: 'numeric', 
      month: 'long'
    });
    
    const dataHojeEl = document.getElementById("dataHoje");
    if (dataHojeEl) {
      // Corre√ß√£o: Capitaliza a primeira letra corretamente
      dataHojeEl.textContent = dataHoje.charAt(0).toUpperCase() + dataHoje.slice(1);
    }
  }
  
  // --- NOVA FUN√á√ÉO AUXILIAR PARA CALCULAR DATAS DA TEMPORADA ---
function getDatasTemporada(ano) {
    // Regra ISO-8601: A primeira semana do ano √© a que cont√©m 4 de Janeiro
    const d = new Date(ano, 0, 4); 
    const day = d.getDay() || 7; // Transforma Domingo (0) em 7 para facilitar a conta
    
    // Calcula a Segunda-feira dessa semana (In√≠cio da Temporada)
    const inicio = new Date(d);
    inicio.setDate(d.getDate() - day + 1);

    // Calcula o in√≠cio do PR√ìXIMO ano para definir o fim deste
    const dNext = new Date(ano + 1, 0, 4);
    const dayNext = dNext.getDay() || 7;
    const inicioProxima = new Date(dNext);
    inicioProxima.setDate(dNext.getDate() - dayNext + 1);
    
    // O fim desta temporada √© o dia anterior ao in√≠cio da pr√≥xima (Domingo)
    const fim = new Date(inicioProxima);
    fim.setDate(fim.getDate() - 1); 

    // Retorna formatado dd/mm
    return {
        inicio: formatarData(inicio).slice(0, 5),
        fim: formatarData(fim).slice(0, 5)
    };
}
  
  // Fun√ß√£o para atualizar informa√ß√µes da semana
  function atualizarInfoSemana() {
    const semanaAtual = getSemanaAtual();
    const infoSemanaEl = document.getElementById("info-semana");
    if (infoSemanaEl) {
      // 1. Calcula a data do resultado (Domingo = Fim + 1 dia)
      const dataFim = new Date(semanaAtual.fim);
      const dataResultado = new Date(dataFim);
      dataResultado.setDate(dataResultado.getDate() + 1);
      
      const diaResultadoFmt = String(dataResultado.getDate()).padStart(2, '0');
      const mesResultadoFmt = String(dataResultado.getMonth() + 1).padStart(2, '0');
      const resultadoDisplay = `${diaResultadoFmt}/${mesResultadoFmt}`;

      // 2. Define dados da Temporada
      const anoTemporada = semanaAtual.inicio.getFullYear(); // Ex: 2025
      // L√≥gica de virada de ano espec√≠fica do seu c√≥digo
      const anoExibicao = (semanaAtual.numero === 1 && new Date().getMonth() === 11) ? ANO_ATUAL + 1 : ANO_ATUAL;

      // --- CORRE√á√ÉO DEFINITIVA DE DATAS ---
      // Calcula as datas exatas de in√≠cio e fim baseadas na regra da Semana 1
      const datasTemporada = getDatasTemporada(anoExibicao);
      // ----------------------------------

      infoSemanaEl.innerHTML = `
        <div class="info-semana-grid">
            
            <div class="info-semana-block">
                <h3>Temporada ${anoExibicao}</h3>
                <div class="info-semana-datas">${datasTemporada.inicio} a ${datasTemporada.fim}</div>
                <div class="info-semana-detalhe">Ciclo Competitivo</div>
            </div>

            <div class="info-semana-block">
                <h3>Semana Atual</h3>
                <div class="info-semana-destaque">Semana ${semanaAtual.numero}</div>
                <div class="info-semana-datas">${semanaAtual.inicioFormatado} a ${semanaAtual.fimFormatado}</div>
                <div class="info-semana-detalhe">
                    üèÅ Encerra: S√°bado (${semanaAtual.fimCompeticao})<br>
                    üèÜ Resultado: Domingo (${resultadoDisplay})
                </div>
            </div>

        </div>
      `;
    }
    
    // ===== NOVO BLOCO ADICIONADO =====
    const anoAtualEl = document.getElementById('ano-temporada-atual');
    if (anoAtualEl) {
        // Se estamos na semana 1, mas o ano civil ainda √© o anterior (ex: Dez 29), mostramos o ano seguinte
        const anoExibicao = (semanaAtual.numero === 1 && new Date().getMonth() === 11) 
                            ? ANO_ATUAL + 1 
                            : ANO_ATUAL;
        anoAtualEl.textContent = `(Temporada ${anoExibicao})`;
    }
    // =================================
  }
  
  // ===== FUNCIONALIDADES DO MURAL =====
  
  // Fun√ß√£o "ajudante" que verifica se uma cor √© escura ou clara
function isColorDark(hexColor) {
  const color = (hexColor.charAt(0) === '#') ? hexColor.substring(1, 7) : hexColor;
  const r = parseInt(color.substring(0, 2), 16);
  const g = parseInt(color.substring(2, 4), 16);
  const b = parseInt(color.substring(4, 6), 16);
  return (0.299 * r + 0.587 * g + 0.114 * b) < 128;
}

// SUBSTITUA A SUA FUN√á√ÉO openMessageViewer() POR ESTA
async function openMessageViewer(messageId) {
  if (unsubscribeViewerListener) {
    unsubscribeViewerListener();
    unsubscribeViewerListener = null;
  }

  const viewerModal = document.getElementById('message-viewer-modal');
  openModal('message-viewer-modal');
  viewerModal.dataset.activeMessageId = messageId;

  const mensagemRef = doc(db, "mural", messageId);

  unsubscribeViewerListener = onSnapshot(mensagemRef, (docSnap) => {
    if (!docSnap.exists()) {
      closeModal('message-viewer-modal');
      return;
    }

    const mensagem = docSnap.data();
    const viewerCard = document.getElementById('viewer-card');
    const viewerText = document.getElementById('viewer-text');
    const viewerAuthor = document.getElementById('viewer-author');
    const viewerTimestamp = document.getElementById('viewer-timestamp');
    const viewerReacoesContainer = document.getElementById('viewer-reacoes-container');

    const timestampDate = mensagem.timestamp.toDate();
    viewerCard.style.backgroundColor = mensagem.cor;
    viewerAuthor.textContent = mensagem.nome;
    viewerTimestamp.textContent = `${timestampDate.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' })} - ${timestampDate.toLocaleDateString('pt-BR')}`;

    // --- L√ìGICA DE RENDERIZA√á√ÉO DE MEN√á√ïES (IN√çCIO) ---
    let textoMensagem = mensagem.texto || "";
    textoMensagem = textoMensagem.replace(/@([\w√°√©√≠√≥√∫√Å√â√ç√ì√ö√¢√™√Æ√¥√ª√Ç√ä√é√î√õ√†√®√¨√≤√π√Ä√à√å√í√ô√£√µ√É√ï√ß√á]+)/g, '<span class="mention">@$1</span>');
    viewerText.innerHTML = textoMensagem;
    // --- L√ìGICA DE RENDERIZA√á√ÉO DE MEN√á√ïES (FIM) ---

    if (isColorDark(mensagem.cor)) {
      viewerCard.classList.add('text-light');
    } else {
      viewerCard.classList.remove('text-light');
    }

    const reacoes = mensagem.reacoes || {};
    let reacoesHTML = '';
    let temReacoes = false;
    const emojisOrdenados = Object.keys(reacoes).sort((a, b) => (reacoes[b]?.length || 0) - (reacoes[a]?.length || 0));

    for (const emoji of emojisOrdenados) {
      const reagentes = Array.isArray(reacoes[emoji]) ? reacoes[emoji] : [];
      if (reagentes.length > 0) {
        temReacoes = true;
        const userHasReacted = reagentes.includes(currentUser);
        const reactedClass = userHasReacted ? 'reacted' : '';
        const tooltipText = reagentes.length > 0 ? `Reagido por: ${reagentes.join(', ')}` : `Reagir com ${emoji}`;
        reacoesHTML += `<div class="reacao-display ${reactedClass}" title="${tooltipText}" data-emoji="${emoji}" onclick="window.abrirModalReagentes('${messageId}', '${emoji}')">${emoji} <span class="contador-display">${reagentes.length}</span></div>`;
      }
    }
    viewerReacoesContainer.innerHTML = reacoesHTML;
    viewerReacoesContainer.style.display = temReacoes ? 'flex' : 'none';

    const viewerSeletorBar = viewerModal.querySelector('.reacao-seletor-bar');
    viewerSeletorBar.innerHTML = '';
    EMOJIS_MURAL.forEach(emoji => {
      const btn = document.createElement('button');
      btn.textContent = emoji;
      btn.onclick = (e) => { e.stopPropagation(); window.toggleReacao(messageId, emoji, e); };
      viewerSeletorBar.appendChild(btn);
    });
    viewerSeletorBar.classList.remove('hidden');
  });
}

async function confirmDelete() {
  if (!messageIdToDelete) return;
  const mensagemRef = doc(db, "mural", messageIdToDelete);
  
  // CORRE√á√ÉO: Vari√°vel declarada no escopo principal da fun√ß√£o
  let autorDaMensagem = null; 

  try {
    const docSnap = await getDoc(mensagemRef);
    if (docSnap.exists()) {
      const mensagemData = docSnap.data();
      autorDaMensagem = mensagemData.userId; // Atribui valor aqui
      
      const batch = writeBatch(db);

      // Apaga o evento do feed correspondente
      const feedEventId = mensagemData.feedEventId;
      if (feedEventId) {
        batch.delete(doc(db, "resumoSemanalFeed", feedEventId));
      }
      
      // Apaga todas as notifica√ß√µes de men√ß√£o geradas pela mensagem
      const notificationIds = mensagemData.mentionNotificationIds || [];
      if (notificationIds.length > 0) {
        notificationIds.forEach(notifId => {
          batch.delete(doc(db, "notificacoes", notifId));
        });
      }

      // Penalidade de moedas para usu√°rios reais
      if (autorDaMensagem && autorDaMensagem !== "An√¥nimo" && autorDaMensagem !== "Or√°culo") {
        const membroRef = doc(db, "membros", autorDaMensagem);
        batch.update(membroRef, { moedas: increment(-5) });
      }
      
      // Apaga a mensagem principal
      batch.delete(mensagemRef);
      
      await batch.commit();
    }
    
    mostrarPopup("‚úÖ Sucesso", "Mensagem e notifica√ß√µes relacionadas foram exclu√≠das!", 3000);
	
	// LINHA CORRIGIDA: Adicionado 'await' e verifica√ß√£o
    if (autorDaMensagem === currentUser) {
        console.log("Removendo progresso de postagem para:", currentUser);
        await reverterProgressoProtecao('postar', messageIdToDelete);
    }

  } catch (error) {
    mostrarPopup("‚ùå Erro", "Falha ao excluir a mensagem.", 3000);
    console.error("Erro ao excluir:", error);
  } finally {
    closeModal('confirm-delete-modal');
    messageIdToDelete = null;
  }
}

// Abre o compositor para criar ou editar uma mensagem
function openMessageComposer(messageData = null) {
  const sendBtn = document.getElementById('composer-send-btn');

  if (messageData) { // Modo Edi√ß√£o
    document.getElementById('composer-textarea').value = messageData.texto;
    const isAnon = messageData.nome === "An√¥nimo";
    document.getElementById('composer-anonymous-check').checked = isAnon;
    document.getElementById('composer-author').textContent = isAnon ? "An√¥nimo" : currentUser;
    selectComposerColor(messageData.cor);
    sendBtn.textContent = 'Salvar Altera√ß√µes';
  } else { // Modo Cria√ß√£o
    document.getElementById('composer-textarea').value = '';
    document.getElementById('composer-anonymous-check').checked = false;
    document.getElementById('composer-author').textContent = currentUser;
    selectComposerColor('#CAFFBF'); // Cor padr√£o
    sendBtn.textContent = 'Enviar';
    composerEditMode = false;
    editingMessageId = null;
  }

  updateComposerTimestamp();
  composerTimestampInterval = setInterval(updateComposerTimestamp, 1000);
  openModal('message-composer-modal');
}

function closeMessageComposer() {
  clearInterval(composerTimestampInterval);
  closeModal('message-composer-modal');
  composerEditMode = false;
  editingMessageId = null;
}

// Fun√ß√£o principal que aplica a formata√ß√£o ao texto selecionado
window.formatText = function(command) {
  // document.execCommand √© a fun√ß√£o nativa do navegador para manipular conte√∫do edit√°vel
  document.execCommand(command, false, null);
  
  // Foca de volta na √°rea de texto ap√≥s clicar em um bot√£o
  document.getElementById('composer-textarea').focus();
}

function updateComposerTimestamp() {
  const agora = new Date();
  const hora = agora.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });
  const data = agora.toLocaleDateString('pt-BR');
  document.getElementById('composer-timestamp').textContent = `${hora} - ${data}`;
}

function selectComposerColor(color) {
  composerSelectedColor = color;
  const composerCard = document.getElementById('composer-card');
  const colorBtn = document.getElementById('composer-color-btn');

  composerCard.style.backgroundColor = color;
  colorBtn.style.backgroundColor = color;

  if (isColorDark(color)) {
    composerCard.classList.add('text-light');
    colorBtn.classList.add('text-light');
  } else {
    composerCard.classList.remove('text-light');
    colorBtn.classList.remove('text-light');
  }
  document.getElementById('composer-color-palette').classList.add('hidden');
}

// SUBSTITUA A SUA FUN√á√ÉO ANTIGA POR ESTA

window.enviarMensagem = async function() {
  // 1. Captura o bot√£o para dar feedback visual
  const sendBtn = document.getElementById('composer-send-btn');
  const textoOriginalBtn = sendBtn.textContent; // Guarda o texto original ("Enviar" ou "Salvar")
  
  const isAnonymous = document.getElementById('composer-anonymous-check').checked;
  const nome = isAnonymous ? "An√¥nimo" : currentUser;
  
  const textarea = document.getElementById('composer-textarea');
  const textoHTML = textarea.innerHTML.trim();
  const textoPuro = textarea.innerText.trim();

  if (!textoPuro || textoHTML === "<br>") {
    mostrarPopup("‚úçÔ∏è Aten√ß√£o", "Digite uma mensagem.", 3000);
    return;
  }

  const dadosMensagem = {
    nome: nome,
    texto: textoHTML,
    cor: composerSelectedColor,
    userId: currentUser
  };

  try {
    // ALTERA√á√ÉO: Muda o texto para algo curto e desabilita
    sendBtn.textContent = '‚è≥';
    sendBtn.disabled = true;

    if (composerEditMode && editingMessageId) {
      // Edi√ß√£o de mensagem
      const mensagemRef = doc(db, "mural", editingMessageId);
      await updateDoc(mensagemRef, dadosMensagem);
      mostrarPopup("‚úÖ Sucesso", "Mensagem editada!", 3000);
    } else {
      // Cria√ß√£o de nova mensagem
      if (userRole !== 'lider') {
          const q = query(collection(db, "mural"), where("userId", "==", currentUser));
          const querySnapshot = await getDocs(q);
          if (querySnapshot.size >= 3) {
            mostrarPopup("üö´ Limite Atingido", "Voc√™ j√° postou o m√°ximo de 3 mensagens. Apague uma antiga para poder postar uma nova.", 5000);
            return;
          }
      }
      
      // =======================================================
      // ===== IN√çCIO DA CORRE√á√ÉO DEFINITIVA =====
      // =======================================================
      // A linha abaixo foi corrigida para incluir caracteres com acento
      const mencoesRegex = /@([\w√°√©√≠√≥√∫√Å√â√ç√ì√ö√¢√™√Æ√¥√ª√Ç√ä√é√î√õ√†√®√¨√≤√π√Ä√à√å√í√ô√£√µ√É√ï√ß√á]+)/g;
      // =======================================================
      // ===== FIM DA CORRE√á√ÉO DEFINITIVA =====
      // =======================================================

      const mencoesEncontradas = textoPuro.match(mencoesRegex)?.map(m => m.substring(1)) || [];
      const destinatariosNotificacao = new Set();
      
      if (mencoesEncontradas.length > 0) {
        mencoesEncontradas.forEach(mencao => {
          if (mencao.toLowerCase() === 'todos') {
            todosMembros.forEach(m => {
              if (m.nome !== currentUser) destinatariosNotificacao.add(m.nome);
            });
          } else if (mencao.toLowerCase().startsWith('equipe')) {
            const nomeEquipe = mencao.substring(6).toLowerCase();
            if (equipes[nomeEquipe]) {
              equipes[nomeEquipe].membros.forEach(m => {
                if (m.nome !== currentUser) destinatariosNotificacao.add(m.nome);
              });
            }
          } else {
            const membroMencionado = todosMembros.find(m => m.nome.toLowerCase() === mencao.toLowerCase());
            if (membroMencionado && membroMencionado.nome !== currentUser) {
              destinatariosNotificacao.add(membroMencionado.nome);
            }
          }
        });
      }

      let tituloFeed = '‚úçÔ∏è Nova Mensagem no Mural!';
      let textoFeed;

      if (destinatariosNotificacao.size > 0) {
        const nomesMencionados = Array.from(destinatariosNotificacao).slice(0, 2);
        let nomesTexto = `<strong>${nomesMencionados.join('</strong> e <strong>')}</strong>`;
        if (destinatariosNotificacao.size > 2) {
          nomesTexto += ` e outros`;
        }
        textoFeed = `<strong>${nome}</strong> compartilhou uma nova mensagem mencionando ${nomesTexto}. D√™ uma olhada!`;
      } else {
        textoFeed = isAnonymous 
          ? '<strong>Um an√¥nimo</strong> compartilhou uma nova mensagem no mural. D√™ uma olhada!'
          : `<strong>${nome}</strong> compartilhou uma nova mensagem no mural. D√™ uma olhada!`;
      }
      
      const feedEventId = await adicionarEventoAoFeed('geral', tituloFeed, textoFeed, { nomeMembro: nome });
      if (feedEventId) {
        dadosMensagem.feedEventId = feedEventId;
      }
      
      dadosMensagem.timestamp = new Date();
      dadosMensagem.reacoes = EMOJIS_MURAL.reduce((acc, emoji) => ({...acc, [emoji]: []}), {});
      dadosMensagem.semana = getSemanaAtual().numero;
      
      const batch = writeBatch(db);
      const mensagemRef = doc(collection(db, "mural"));
      batch.set(mensagemRef, dadosMensagem);

      if (destinatariosNotificacao.size > 0) {
          const resumoMensagem = `"${textoPuro.substring(0, 30)}..."`;
          destinatariosNotificacao.forEach(destinatario => {
              const notificacaoRef = doc(collection(db, "notificacoes"));
              batch.set(notificacaoRef, {
                  destinatarioId: destinatario,
                  remetenteNome: currentUser,
                  tipo: 'mural-mention',
                  conteudo: 'üí¨',
                  acao: `mencionou voc√™ em uma mensagem: ${resumoMensagem}`,
                  lida: false,
                  timestamp: new Date()
              });
          });
      }

      const membroRef = doc(db, "membros", currentUser);
      batch.update(membroRef, { moedas: increment(recompensasConfig.postarMural || 5) });
      await batch.commit();
  
      mostrarPopup("‚úÖ Sucesso", "Mensagem enviada!", 3000);
	  atualizarProgressoProtecao('postar', mensagemRef.id);
      tocarSom('som-envio');
      mostrarPopupMoedas(recompensasConfig.postarMural || 5);

      // ALTERA√á√ÉO: O Or√°culo agora interage sempre, independentemente de men√ß√£o
      setTimeout(() => {
        executarInteracaoImediataOraculo(mensagemRef.id, textoPuro, currentUser);
      }, 3000);

    }
    closeMessageComposer();
  } catch (error) {
    console.error("Erro:", error);
    mostrarPopup("‚ùå Erro", "Ocorreu um erro.", 3000);
  } finally {
    // ALTERA√á√ÉO: Restaura o bot√£o ao estado original
    if (sendBtn) {
        sendBtn.textContent = textoOriginalBtn;
        sendBtn.disabled = false;
    }
    composerEditMode = false;
    editingMessageId = null;
  }
}

// =======================================================
// ===== NOVAS FUN√á√ïES: ASSISTENTE DE ESCRITA DO OR√ÅCULO =====
// =======================================================

window.abrirAssistenteOraculo = function() {
  openModal('oracle-assistant-modal');
}

window.executarAcaoAssistenteIA = async function(acao) {
  if (!genAI) {
    mostrarPopup("‚ùå Erro", "O assistente de IA n√£o est√° dispon√≠vel no momento.", 4000);
    return;
  }

  const textarea = document.getElementById('composer-textarea');
  const textoAtual = textarea.innerText; // Usamos innerText para pegar o texto puro
  let prompt = '';

  // Define a instru√ß√£o para a IA com base na a√ß√£o escolhida
  switch (acao) {
    case 'sugerir':
      if (!textoAtual) {
        mostrarPopup("‚úçÔ∏è Aten√ß√£o", "Escreva algo primeiro para que eu possa sugerir uma continua√ß√£o.", 4000);
        return;
      }
      // ESTE √â O NOVO PROMPT, MUITO MAIS ESPEC√çFICO
      prompt = `Sua √∫nica tarefa √© completar o texto a seguir, agindo como o Or√°culo (s√°bio, direto, po√©tico). Continue a escrita EXATAMENTE de onde o texto parou.

REGRAS IMPORTANTES:
- N√ÉO ofere√ßa m√∫ltiplas op√ß√µes.
- N√ÉO escreva nenhuma introdu√ß√£o, explica√ß√£o ou coment√°rio ("Aqui est√° uma continua√ß√£o...", "Op√ß√£o 1:", etc.).
- Sua resposta deve ser APENAS a continua√ß√£o direta do texto, sem repetir a parte que j√° foi escrita.

Texto para completar:
"${textoAtual}"`;
      break;
    case 'resumir':
      if (!textoAtual) {
        mostrarPopup("‚úçÔ∏è Aten√ß√£o", "N√£o h√° texto para resumir.", 3000);
        return;
      }
      prompt = `Resuma o seguinte texto em uma ou duas frases curtas e objetivas:\n\n"${textoAtual}"`;
      break;
    case 'corrigir':
      if (!textoAtual) {
        mostrarPopup("‚úçÔ∏è Aten√ß√£o", "N√£o h√° texto para corrigir.", 3000);
        return;
      }
      prompt = `Corrija a ortografia e a gram√°tica do texto a seguir, mantendo a inten√ß√£o original. Retorne apenas o texto corrigido:\n\n"${textoAtual}"`;
      break;
    case 'tonalizar':
       if (!textoAtual) {
        mostrarPopup("‚úçÔ∏è Aten√ß√£o", "Escreva algo primeiro para que eu possa alterar o tom.", 4000);
        return;
      }
      prompt = `Reescreva o texto a seguir com a personalidade do Or√°culo: s√°bio, um pouco misterioso e direto. Retorne apenas o texto reescrito:\n\n"${textoAtual}"`;
      break;
    default:
      return;
  }
  
  closeModal('oracle-assistant-modal');
  mostrarPopup("üßô‚Äç Or√°culo", "O Or√°culo est√° conjurando as palavras...", 3000);

  try {
    const model = genAI.getGenerativeModel({ model: "gemini-2.5-flash-lite" });
    const result = await model.generateContent(prompt);
    const response = await result.response;
    let textoGerado = response.text();

    // Se a a√ß√£o foi de sugest√£o, adicionamos o novo texto ao final
    if (acao === 'sugerir') {
      // Adiciona um espa√ßo ou quebra de linha antes de inserir a sugest√£o
      textarea.innerHTML += `<br><br>${textoGerado.replace(/\n/g, '<br>')}`;
    } else {
      // Para as outras a√ß√µes, substitu√≠mos o texto existente
      textarea.innerHTML = textoGerado.replace(/\n/g, '<br>');
    }
    
    mostrarPopup("‚úÖ Pronto!", "A sugest√£o do Or√°culo foi aplicada.", 3000);

  } catch (error) {
    console.error("Erro na a√ß√£o do assistente de IA:", error);
    mostrarPopup("‚ùå Erro", "O Or√°culo n√£o conseguiu processar sua solicita√ß√£o.", 4000);
  }
}

// Nova fun√ß√£o de EDI√á√ÉO que abre o compositor
window.editarMensagem = async function(event, messageId) {
  document.getElementById('global-options-menu').classList.add('hidden'); // ADICIONE ESTA LINHA
  event.stopPropagation();
  composerEditMode = true;
  editingMessageId = messageId;
  try {
    const docSnap = await getDoc(doc(db, "mural", messageId));
    if (docSnap.exists()) {
      openMessageComposer(docSnap.data());
    }
  } catch (error) {
    console.error("Erro ao buscar mensagem para editar:", error);
  }
}

// Nova fun√ß√£o de EXCLUS√ÉO que abre o modal de confirma√ß√£o
window.excluirMensagem = function(event, messageId) {
  document.getElementById('global-options-menu').classList.add('hidden'); // ADICIONE ESTA LINHA
  event.stopPropagation();
  messageIdToDelete = messageId;
  openModal('confirm-delete-modal');
}

function createColorPalette() {
  const colors = [
     // Tons Past√©is e Claros
    '#FFFFFF', '#FADADD', '#FFD6A5', '#FDFFB6', '#CAFFBF', '#9BF6FF', 
    '#A0C4FF', '#BDB2FF', '#FFC6FF', '#EAE4E9', '#D4E09B', '#C3E0E5',
    '#F7D6E0', '#F3E9DD', '#D3E4CD',
    // Tons Vibrantes e Saturados
    '#FF1744', '#F50057', '#D500F9', '#651FFF', '#3D5AFE', '#2979FF',
    '#00B0FF', '#00E5FF', '#1DE9B6', '#00E676', '#76FF03', '#C6FF00',
    '#FFEA00', '#FFC400', '#FF9100', '#FF3D00',
    // Tons S√≥brios e Escuros
    '#F38375', '#FBC42C', '#57C479', '#57C5C8', '#578DC8', '#8A57C8',
    '#C857B2', '#4B4A49', '#ACACAC', '#795548', '#607D8B', '#000000',
    // Paleta Adicional
    '#E57373', '#BA68C8', '#7986CB', '#4FC3F7', '#4DB6AC', '#AED581',
    '#FFF176', '#FFB74D', '#A1887F', '#90A4AE', '#008F93', '#F08080',
    '#20B2AA', '#87CEEB', '#9370DB', '#DA70D6'
  ];

  const palette = document.getElementById('composer-color-palette');
  if (!palette) return;

  palette.innerHTML = ''; // Limpa a paleta para evitar duplicatas

  colors.forEach(color => {
    const colorOption = document.createElement('div');
    colorOption.className = 'composer-color-option';
    colorOption.style.backgroundColor = color;
    colorOption.title = color; // Mostra o c√≥digo da cor ao passar o mouse
    
    // Adiciona o evento de clique que chama a fun√ß√£o j√° existente
    colorOption.onclick = () => selectComposerColor(color);
    
    palette.appendChild(colorOption);
  });
}

// SUBSTITUA A SUA FUN√á√ÉO criarElementoMensagem() POR ESTA
function criarElementoMensagem(mensagem) {
  const cor = mensagem.cor || "#ffdde1";
  const timestampDate = mensagem.timestamp; 
  const hora = timestampDate.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });
  const data = timestampDate.toLocaleDateString('pt-BR');

  const mensagemEl = document.createElement('div');
  mensagemEl.className = 'mensagem';
  mensagemEl.style.backgroundColor = cor;
  mensagemEl.dataset.id = mensagem.id;
  mensagemEl.dataset.fullText = mensagem.texto || "";
  mensagemEl.style.setProperty('--card-bg-color', cor);

  if (isColorDark(cor)) {
    mensagemEl.classList.add('text-light');
  }

  // --- L√ìGICA DE RENDERIZA√á√ÉO DE MEN√á√ïES (IN√çCIO) ---
  let textoMensagem = mensagem.texto || "";
  textoMensagem = textoMensagem.replace(/@([\w√°√©√≠√≥√∫√Å√â√ç√ì√ö√¢√™√Æ√¥√ª√Ç√ä√é√î√õ√†√®√¨√≤√π√Ä√à√å√í√ô√£√µ√É√ï√ß√á]+)/g, '<span class="mention">@$1</span>');
  // --- L√ìGICA DE RENDERIZA√á√ÉO DE MEN√á√ïES (FIM) ---

  const reacoes = mensagem.reacoes || {};
  let reacoesVisiveisHTML = '';
  let temReacoes = false;
  const emojisOrdenados = Object.keys(reacoes).sort((a, b) => (reacoes[b]?.length || 0) - (reacoes[a]?.length || 0));

  for (const emoji of emojisOrdenados) {
    const reagentes = Array.isArray(reacoes[emoji]) ? reacoes[emoji] : [];
    if (reagentes.length > 0) {
      temReacoes = true;
      const userHasReacted = reagentes.includes(currentUser);
      const reactedClass = userHasReacted ? 'reacted' : '';
      const tooltipText = reagentes.length > 0 ? `Reagido por: ${reagentes.join(', ')}` : `Seja o primeiro a reagir com ${emoji}`;
      reacoesVisiveisHTML += `<div class="reacao-display ${reactedClass}" title="${tooltipText}" data-emoji="${emoji}" onclick="window.abrirModalReagentes('${mensagem.id}', '${emoji}')">${emoji} <span class="contador-display">${reagentes.length}</span></div>`;
    }
  }
  const reacoesDisplayContainer = temReacoes ? `<div class="reacoes-display-container">${reacoesVisiveisHTML}</div>` : '';

  let optionsHTML = '';
  if (mensagem.userId === currentUser || userRole === 'lider') {
    optionsHTML = `<div class="message-options-container"><button class="options-btn" onclick="window.openOptionsMenu(event, 'message', '${mensagem.id}')">‚ãÆ</button></div>`;
  }

  const tempDiv = document.createElement('div');
  tempDiv.innerHTML = textoMensagem;
  const textoPuro = tempDiv.textContent || tempDiv.innerText || "";
  const deveTruncar = textoPuro.length > 100;
  const classeDeTruncamento = deveTruncar ? 'texto-truncado' : '';

   mensagemEl.innerHTML = `
    <div class="mensagem-texto ${classeDeTruncamento}"><span class="texto-mascarado">${textoMensagem}</span></div>
    ${reacoesDisplayContainer}
    <div class="mensagem-info">
      <div>
        <div class="mensagem-autor">${mensagem.nome}</div>
        <div class="mensagem-data">${hora} - ${data}</div>
      </div>
      <div class="mensagem-actions">
        <div class="comment-indicator" title="Coment√°rios">
          üí¨ <span class="comment-count">${mensagem.commentCount || 0}</span>
        </div>
        ${optionsHTML}
      </div>
    </div>
    <div class="reacao-seletor-bar hidden">
      ${EMOJIS_MURAL.map(emoji => `<button onclick="event.stopPropagation(); window.toggleReacao('${mensagem.id}', '${emoji}', event)">${emoji}</button>`).join('')}
    </div>
  `;
  
  const commentIndicator = mensagemEl.querySelector('.comment-indicator');
  if (commentIndicator) {
    commentIndicator.addEventListener('click', (event) => {
      event.stopPropagation();
      window.openCommentsModal(mensagem.id);
    });
  }

  let pressTimer = null, longPressTriggered = false, hasScrolled = false;
  const startPress = (e) => {
    if (e.target.closest('button, a, .reacao-display, .mention')) return;
    longPressTriggered = false;
    hasScrolled = false;
    pressTimer = setTimeout(() => {
      longPressTriggered = true;
      const seletorBar = mensagemEl.querySelector('.reacao-seletor-bar');
      if (seletorBar) {
        seletorBar.classList.remove('hidden');
        const closeReactionBar = (event) => {
          if (!mensagemEl.contains(event.target) || event.target.closest('.reacao-seletor-bar button')) {
            seletorBar.classList.add('hidden');
            document.removeEventListener('click', closeReactionBar);
          }
        };
        setTimeout(() => document.addEventListener('click', closeReactionBar), 100);
      }
    }, 500);
  };
  const cancelPress = () => clearTimeout(pressTimer);
  const endPress = (e) => {
    clearTimeout(pressTimer);
    if (!longPressTriggered && !hasScrolled) {
      if (!e.target.closest('button, a, .reacao-display, .comment-indicator, .mention')) {
        openMessageViewer(mensagem.id);
      }
    }
  };
  const handleTouchMove = () => { clearTimeout(pressTimer); hasScrolled = true; };

  mensagemEl.addEventListener('mousedown', startPress);
  mensagemEl.addEventListener('mouseup', endPress);
  mensagemEl.addEventListener('mouseleave', cancelPress);
  mensagemEl.addEventListener('touchstart', startPress, { passive: true });
  mensagemEl.addEventListener('touchend', endPress);
  mensagemEl.addEventListener('touchmove', handleTouchMove);

  return mensagemEl;
}
  
  function configurarMuralTempoReal() {
    const muralContainer = document.getElementById('mural-mensagens');
    if (!muralContainer) return;

    muralContainer.innerHTML = '<div class="carregando">Carregando mensagens...</div>';

    const q = collection(db, "mural");
    
    // Ouvinte em tempo real
    onSnapshot(q, (querySnapshot) => {
      const mensagens = [];
      
      querySnapshot.forEach(doc => {
        const data = doc.data();
        mensagens.push({
          id: doc.id,
          ...data,
          timestamp: data.timestamp.toDate ? data.timestamp.toDate() : new Date(data.timestamp.seconds * 1000)
        });
      });

      // Ordenar por data (mais recente primeiro)
      mensagens.sort((a, b) => b.timestamp - a.timestamp);
      
      muralContainer.innerHTML = '';
      
      if (mensagens.length === 0) {
        muralContainer.innerHTML = '<div class="sem-mensagens">Nenhuma mensagem ainda. Seja o primeiro a escrever!</div>';
        return;
      }

      // Exibir todas as mensagens
      mensagens.forEach(msg => {
        muralContainer.appendChild(criarElementoMensagem(msg));
      });
    });
  }
  
  // COLE ESTA NOVA FUN√á√ÉO NO SEU C√ìDIGO
async function adicionarReacaoComoOraculo(messageId, emoji) {
  console.log(`Or√°culo: Reagindo com ${emoji} √† mensagem ${messageId}`);
  const mensagemRef = doc(db, "mural", messageId);

  try {
    await runTransaction(db, async (transaction) => {
      const docSnap = await transaction.get(mensagemRef);
      if (!docSnap.exists()) throw "Documento n√£o existe!";

      const dados = docSnap.data();
      let reacoes = dados.reacoes || {};
      
      // Remove qualquer rea√ß√£o anterior do Or√°culo
      for (const emojiExistente in reacoes) {
        if (Array.isArray(reacoes[emojiExistente])) {
          const oracleIndex = reacoes[emojiExistente].indexOf("Or√°culo");
          if (oracleIndex > -1) {
            reacoes[emojiExistente].splice(oracleIndex, 1);
          }
        }
      }

      // Adiciona a nova rea√ß√£o
      if (!reacoes[emoji]) reacoes[emoji] = [];
      if (!reacoes[emoji].includes("Or√°culo")) {
        reacoes[emoji].push("Or√°culo");
      }
      
      transaction.update(mensagemRef, { reacoes: reacoes });
    });
  } catch (error) {
    console.error(`Or√°culo: Falha ao adicionar rea√ß√£o:`, error);
  }
}
  
window.toggleReacao = function(mensagemId, emoji, event) {
  if (event) event.stopPropagation();
  if (!currentUser) return;

  atualizarReacaoOtimista('#mural-mensagens', mensagemId, emoji);
  tocarSom('som-reacao');

  const mensagemRef = doc(db, "mural", mensagemId);
  const membroRef = doc(db, "membros", currentUser);
  
  let autorId;
  let resumoMensagem;

  runTransaction(db, async (transaction) => {
    const docSnap = await transaction.get(mensagemRef);
    if (!docSnap.exists()) throw "Documento n√£o existe!";

    const dados = docSnap.data();
    autorId = dados.userId;
    resumoMensagem = `"${dados.texto.substring(0, 30)}..."`;
    
    let reacoes = dados.reacoes || {};
    let reactionFeedEvents = dados.reactionFeedEvents || {};
    let reactionNotificationIds = dados.reactionNotificationIds || {};

    const reactionKey = `${currentUser}_${emoji}`;
    
    let reacaoAntiga = null;
    let mudancaDeMoedas = 0;
    let removeuReacao = false; // Flag para controlar a revers√£o

    for (const emojiExistente in reacoes) {
      if (Array.isArray(reacoes[emojiExistente]) && reacoes[emojiExistente].includes(currentUser)) {
        reacaoAntiga = emojiExistente;
        break;
      }
    }
    
    if (reacaoAntiga) {
      const oldReactionKey = `${currentUser}_${reacaoAntiga}`;
      if (reactionFeedEvents[oldReactionKey]) {
        transaction.delete(doc(db, "resumoSemanalFeed", reactionFeedEvents[oldReactionKey]));
        delete reactionFeedEvents[oldReactionKey];
      }
      if (reactionNotificationIds[oldReactionKey]) {
        transaction.delete(doc(db, "notificacoes", reactionNotificationIds[oldReactionKey]));
        delete reactionNotificationIds[oldReactionKey];
      }
    }

    if (reacaoAntiga === emoji) {
      const userIndex = reacoes[emoji].indexOf(currentUser);
      if (userIndex > -1) {
        reacoes[emoji].splice(userIndex, 1);
        mudancaDeMoedas = -1;
        removeuReacao = true; // Marca para reverter DEPOIS da transa√ß√£o
      }
    } else {
      if (reacaoAntiga) {
        const oldUserIndex = reacoes[reacaoAntiga].indexOf(currentUser);
        if (oldUserIndex > -1) reacoes[reacaoAntiga].splice(oldUserIndex, 1);
      } else {
        mudancaDeMoedas = 1;
      }
      
      if (!reacoes[emoji]) reacoes[emoji] = [];
      reacoes[emoji].push(currentUser);
    }
    
    if (mudancaDeMoedas === 1 && autorId && autorId !== currentUser) {
        const notificacoesRef = collection(db, "notificacoes");
        const newNotificacaoRef = doc(notificacoesRef);
        
        transaction.set(newNotificacaoRef, {
            destinatarioId: autorId,
            remetenteNome: currentUser,
            tipo: 'mural',
            conteudo: emoji,
            acao: `reagiu √† sua mensagem: ${resumoMensagem}`,
            lida: false,
            timestamp: new Date()
        });
        reactionNotificationIds[reactionKey] = newNotificacaoRef.id;
    }

    transaction.update(mensagemRef, { 
        reacoes: reacoes,
        reactionFeedEvents: reactionFeedEvents,
        reactionNotificationIds: reactionNotificationIds
    });
    
    if (mudancaDeMoedas !== 0) {
      transaction.update(membroRef, { moedas: increment(mudancaDeMoedas * (recompensasConfig.reagirConteudo || 1)) });
    }

    // Retorna um objeto com os flags necess√°rios
    return { deveCriarFeed: mudancaDeMoedas === 1, removeuReacao: removeuReacao };

  }).then(async (resultado) => {
    
    // 1. Processa a revers√£o SE NECESS√ÅRIO (Anti-Cheat)
    if (resultado.removeuReacao) {
        await reverterProgressoProtecao('reagir');
    } else if (resultado.deveCriarFeed) {
        // S√≥ atualiza o progresso se ADICIONOU
        await atualizarProgressoProtecao('reagir');
    }

    // 2. L√≥gica de Feed
    if (resultado.deveCriarFeed && autorId && autorId !== currentUser) {
      const textoFeed = `<strong>${currentUser}</strong> reagiu com ${emoji} √† mensagem de <strong>${autorId}</strong> no Mural de Mensagens.`;
      
      const feedEventId = await adicionarEventoAoFeed(
        'geral',
        'üëç Nova Rea√ß√£o no Mural!',
        textoFeed,
        { nomeMembro: currentUser, autorMensagem: autorId }
      );
      
      if (feedEventId) {
        const reactionKey = `${currentUser}_${emoji}`;
        await updateDoc(mensagemRef, {
          [`reactionFeedEvents.${reactionKey}`]: feedEventId
        });
      }
    }
  }).catch(error => {
    console.error("Falha na transa√ß√£o de rea√ß√£o do mural: ", error);
    mostrarPopup("‚ùå Ops!", "Sua rea√ß√£o n√£o p√¥de ser salva. Por favor, recarregue a p√°gina.", 4000);
  });
};

// NOVA FUN√á√ÉO: Centraliza a l√≥gica para obter o ranking da semana
async function obterRankingSemanal(dataReferencia = new Date()) {
  try {
    const semana = getSemanaAtual(dataReferencia);
    const inicioSemana = formatarDataISO(semana.inicio);
    const fimSemana = formatarDataISO(semana.fim);

    // Busca as presen√ßas dentro do intervalo da semana
    const q = query(
      collection(db, "presencas"),
      where('__name__', '>=', inicioSemana),
      where('__name__', '<=', fimSemana)
    );

    const querySnapshot = await getDocs(q);
    const contagemMembros = {};

    // Inicializa a contagem para todos os membros
    todosMembros.forEach(m => {
      contagemMembros[m.nome] = { pontos: 0, tempoTotal: 0 };
    });

    // Processa cada dia de presen√ßa na semana
    querySnapshot.forEach(doc => {
      const presencas = doc.data();
      for (const [membro, presencaData] of Object.entries(presencas)) {
        if (contagemMembros[membro] && presencaData) {
          contagemMembros[membro].pontos += 1; // Adiciona o ponto de foco
          if (presencaData && presencaData.toDate) {
            contagemMembros[membro].tempoTotal += presencaData.toDate().getTime();
          }
        }
      }
    });

    // Ordena o ranking: primeiro por mais pontos, depois por menor tempo (quem marcou antes)
    const ranking = Object.entries(contagemMembros)
      .map(([nome, dados]) => ({ nome, pontos: dados.pontos, tempoTotal: dados.tempoTotal }))
      .sort((a, b) => {
        if (b.pontos !== a.pontos) {
          return b.pontos - a.pontos; // Mais pontos primeiro
        }
        // Crit√©rio de desempate: quem marcou antes fica na frente
        if (a.tempoTotal === 0) return 1;
        if (b.tempoTotal === 0) return -1;
        return a.tempoTotal - b.tempoTotal;
      });

    return ranking; // Retorna a lista ordenada

  } catch (error) {
    console.error("Erro ao obter o ranking semanal:", error);
    return []; // Retorna um array vazio em caso de erro
  }
}

async function carregarTop5Semana() {
  try {
    const ranking = await obterRankingSemanal(getHoje());
    const rankingTemPontos = ranking.length > 0 && ranking[0].pontos > 0;
    
    if (!rankingTemPontos) {
      // Se ningu√©m pontuou, limpa o estado e a lista, e encerra.
      const listaEl = document.getElementById('ranking-top-lista');
      if (listaEl) listaEl.innerHTML = '<div class="ranking-item">Ainda n√£o h√° dados esta semana</div>';
      const rankingStateRef = doc(db, "appState", "rankingState");
      const rankingStateSnap = await getDoc(rankingStateRef);
      if (rankingStateSnap.exists()) {
        await deleteDoc(rankingStateRef);
      }
      return;
    }

    const rankingStateRef = doc(db, "appState", "rankingState");
    const top3Atual = ranking.slice(0, 3).map(membro => membro.nome);
    const top3AtualString = top3Atual.join(',');

    // --- IN√çCIO DA L√ìGICA AT√îMICA COM TRANSA√á√ÉO ---
    await runTransaction(db, async (transaction) => {
      const rankingStateSnap = await transaction.get(rankingStateRef);
      const top3Anterior = rankingStateSnap.exists() ? rankingStateSnap.data().top3 : null;

      // A CONDI√á√ÉO CR√çTICA: S√≥ continua se o Top 3 realmente mudou.
      if (top3AtualString !== top3Anterior) {
        console.log("Mudan√ßa no Top 5 detectada. Atualizando o feed...");
        
        const liderAnterior = top3Anterior ? top3Anterior.split(',')[0] : null;
        const novoLider = top3Atual[0];
        let textoFeed;

        if (novoLider === liderAnterior) {
          textoFeed = `<strong>${novoLider}</strong> permanece na lideran√ßa do Top 5 da semana!`;
        } else {
          textoFeed = `<strong>${novoLider}</strong> assumiu a lideran√ßa do Top 5 da semana!`;
        }

        const segundoLugar = top3Atual.length > 1 ? top3Atual[1] : null;
        const terceiroLugar = top3Atual.length > 2 ? top3Atual[2] : null;

        if (segundoLugar && terceiroLugar) {
          textoFeed += ` Em seguida temos <strong>${segundoLugar}</strong> em 2¬∫ e <strong>${terceiroLugar}</strong> em 3¬∫.`;
        } else if (segundoLugar) {
          textoFeed += ` Seguido por <strong>${segundoLugar}</strong> em 2¬∫ lugar.`;
        }

        // Adiciona o evento ao feed DENTRO da transa√ß√£o
        // (Nota: adicionarEventoAoFeed n√£o pode estar aqui se fizer escritas fora da transa√ß√£o.
        //  Vamos assumir que ela pode ser chamada aqui ou moveremos as escritas para a transa√ß√£o).
        // Por seguran√ßa, criaremos o evento aqui e o salvaremos ap√≥s a transa√ß√£o.
        
        // ATUALIZA o estado do ranking DENTRO da transa√ß√£o.
        transaction.set(rankingStateRef, { top3: top3AtualString });
        
        // Dispara o evento de feed fora, ap√≥s a transa√ß√£o ser bem-sucedida.
        // Isso evita erros de "Writes outside of transaction".
        return { deveAdicionarFeed: true, titulo: 'üî• Disputa no Top 5!', texto: textoFeed, dados: { nomeLider: novoLider } };
      }
      
      // Se n√£o houve mudan√ßa, a transa√ß√£o termina sem fazer nada.
      return { deveAdicionarFeed: false };
    }).then(async (resultado) => {
      if (resultado.deveAdicionarFeed) {
        await adicionarEventoAoFeed('geral', resultado.titulo, resultado.texto, resultado.dados);
      }
    });
    // --- FIM DA L√ìGICA AT√îMICA ---

    // A l√≥gica para atualizar a interface visual continua a mesma
    const listaEl = document.getElementById('ranking-top-lista');
    if (!listaEl) return;
    listaEl.innerHTML = '';
    
    const top5 = ranking.slice(0, 5);
    top5.forEach((membro, index) => {
      if (membro.pontos === 0) return;
      const posicao = index + 1;
      let emoji = (posicao === 1) ? 'ü•á' : (posicao === 2) ? 'ü•à' : (posicao === 3) ? 'ü•â' : '‚≠ê';

      const itemEl = document.createElement('div');
      itemEl.className = 'ranking-item';
      itemEl.style.setProperty('--i', index);
      itemEl.innerHTML = `
        <div class="ranking-posicao">${emoji} ${posicao}¬∫</div>
        <div class="ranking-nome">${membro.nome}</div>
        <div class="ranking-pontos">${membro.pontos} dias</div>
      `;
      listaEl.appendChild(itemEl);
    });

    if (listaEl.children.length === 0) {
      listaEl.innerHTML = '<div class="ranking-item">Ainda n√£o h√° dados esta semana</div>';
    }

  } catch (error) {
    console.error("Erro ao carregar ou transacionar o top 5:", error);
  }
}

  // ===== FUN√á√ïES ADICIONADAS PARA MEMBROS DIN√ÇMICOS =====
  async function carregarMembros() {
    const querySnapshot = await getDocs(collection(db, "membros"));
    
    // Resetar estruturas
    todosMembros = [];
    equipes = {
      abelha: { membros: [], lider: null },
      joaninha: { membros: [], lider: null },
      vagalume: { membros: [], lider: null }
    };
    liderGeral = null;

    querySnapshot.forEach(doc => {
      const data = doc.data();
      const membro = {
        nome: doc.id,
        equipe: data.equipe,
        papel: data.papel,
        folga: data.folga || "",
        aniversario: data.aniversario || "",
        senha: data.senha || "",  // Novo campo
        tempPassword: data.tempPassword || true  // Novo campo
      };

      todosMembros.push(membro);

      if (membro.papel === "lider") {
        liderGeral = membro;
      } else if (membro.papel === "lider-equipe") {
        if (equipes[membro.equipe]) {
          equipes[membro.equipe].lider = membro;
        }
      }

      if (membro.equipe && equipes[membro.equipe]) {
        equipes[membro.equipe].membros.push(membro);
      }
    });
  }

function carregarInformacoesMembros() {
  try {
    const carrosselContainer = document.getElementById('carrossel-container');
    const indicadoresContainer = document.getElementById('carrossel-indicadores');

    if (!carrosselContainer) return;

    carrosselContainer.innerHTML = '';
    if (indicadoresContainer) indicadoresContainer.innerHTML = '';

    // === MUDAN√áA PRINCIPAL: Usa 'todosMembros' e mapeia para o formato esperado ===
    const membrosArray = todosMembros.map(membro => ({
        id: membro.nome, // Mapeia 'nome' para 'id' para compatibilidade
        ...membro      // Inclui todas as outras propriedades do membro
    }));
    
    totalSlides = membrosArray.length;

    if (document.getElementById('botao-pausa')) {
        document.getElementById('botao-pausa').textContent = '‚è∏';
    }

    // O resto da fun√ß√£o continua igual, pois j√° opera sobre 'membrosArray'
    membrosArray.forEach((membro, index) => {
      const data = membro;
      const card = document.createElement('div');
      card.className = 'card-membro';
      card.id = `card-membro-${membro.id}`; 

      const corDoCard = data.corCard || '#FFFFFF'; 
      card.style.backgroundColor = corDoCard;

      if (isColorDark(corDoCard)) {
        card.classList.add('text-light');
      } else {
        card.classList.remove('text-light');
      }

      const podeEditar = (currentUser === membro.id || userRole === 'lider');
      const visibilidadeBotoes = podeEditar ? '' : 'hidden';

      card.innerHTML = `
        <div class="card-controls ${visibilidadeBotoes}">
          <button class="card-color-chooser-btn" onclick="toggleColorPalette(event, '${membro.id}')">Escolha a cor</button>
          <div id="palette-${membro.id}" class="card-color-palette hidden">
          </div>
        </div>
        <h3>${membro.id}</h3>
        <div class="subtitulo">coisas sobre mim</div>
        <div class="info-item">
          <div class="info-content"><strong>Eu me chamo:</strong> <span id="info-${membro.id}-me chamo">${data['me chamo'] || 'N√£o informado'}</span></div>
          <button class="edit-info-btn ${visibilidadeBotoes}" onclick="editarInformacao(event, '${membro.id}', 'me chamo')">‚úèÔ∏è</button>
        </div>
        <div class="info-item">
          <div class="info-content"><strong>Meu apelido √©:</strong> <span id="info-${membro.id}-apelido">${data.apelido || 'N√£o informado'}</span></div>
          <button class="edit-info-btn ${visibilidadeBotoes}" onclick="editarInformacao(event, '${membro.id}', 'apelido')">‚úèÔ∏è</button>
        </div>
        <div class="info-item">
          <div class="info-content"><strong>Meu filme favorito:</strong> <span id="info-${membro.id}-filme">${data.filme || 'N√£o informado'}</span></div>
          <button class="edit-info-btn ${visibilidadeBotoes}" onclick="editarInformacao(event, '${membro.id}', 'filme')">‚úèÔ∏è</button>
        </div>
        <div class="info-item">
          <div class="info-content"><strong>Meu maior sonho atualmente:</strong> <span id="info-${membro.id}-sonho">${data.sonho || 'N√£o informado'}</span></div>
          <button class="edit-info-btn ${visibilidadeBotoes}" onclick="editarInformacao(event, '${membro.id}', 'sonho')">‚úèÔ∏è</button>
        </div>
        <div class="info-item">
          <div class="info-content"><strong>Uma m√∫sica que gosto muito:</strong> <span id="info-${membro.id}-musica">${data.musica || 'N√£o informado'}</span></div>
          <button class="edit-info-btn ${visibilidadeBotoes}" onclick="editarInformacao(event, '${membro.id}', 'musica')">‚úèÔ∏è</button>
        </div>
        <div class="info-item">
          <div class="info-content"><strong>Uma curiosidade aleat√≥ria sobre mim:</strong> <span id="info-${membro.id}-curiosidade">${data.curiosidade || 'N√£o informado'}</span></div>
          <button class="edit-info-btn ${visibilidadeBotoes}" onclick="editarInformacao(event, '${membro.id}', 'curiosidade')">‚úèÔ∏è</button>
        </div>
      `;

      const isDark = isColorDark(corDoCard);
      const colorChooserBtn = card.querySelector('.card-color-chooser-btn');
      if (colorChooserBtn) {
        colorChooserBtn.style.color = isDark ? 'white' : 'black';
        colorChooserBtn.style.borderColor = isDark ? 'white' : 'black';
      }

      carrosselContainer.appendChild(card);

      if(podeEditar) {
        criarPaletaDeCoresDoCard(membro.id);
      }

      if (indicadoresContainer) {
          const indicador = document.createElement('div');
          indicador.className = 'carrossel-indicador';
          indicador.onclick = () => {
            if(window.reiniciarIntervaloCarrossel) reiniciarIntervaloCarrossel();
            irParaSlide(index);
          };
          indicadoresContainer.appendChild(indicador);
      }
    });

    if (totalSlides > 0) {
      document.querySelector('.carrossel-indicador')?.classList.add('ativo');
      irParaSlide(0);
      if (totalSlides > 1 && window.iniciarCarrosselAutomatico) {
        iniciarCarrosselAutomatico();
      }
    }
  } catch (error) {
    console.error("Erro ao carregar informa√ß√µes dos membros:", error);
  }
}

window.editarInformacao = async function(event, membroId, campo) {
  event.stopPropagation(); // Impede que o carrossel mude ao clicar

  const spanElement = document.getElementById(`info-${membroId}-${campo}`);
  if (!spanElement) return;

  const valorOriginal = spanElement.textContent;

  // Habilita o modo de edi√ß√£o
  spanElement.contentEditable = true;
  spanElement.classList.add('editing'); // Adiciona classe para feedback visual
  spanElement.focus();

  // Seleciona todo o texto para facilitar a edi√ß√£o
  document.execCommand('selectAll', false, null);

  // Fun√ß√£o para salvar as altera√ß√µes
  const salvarEdicao = async () => {
    // Desliga o modo de edi√ß√£o
    spanElement.contentEditable = false;
    spanElement.classList.remove('editing');

    // Remove os ouvintes de evento para evitar duplica√ß√£o
    spanElement.removeEventListener('blur', salvarEdicao);
    spanElement.removeEventListener('keydown', lidarComTeclas);

    const novoValor = spanElement.textContent.trim();

    // Se o valor n√£o mudou ou est√° vazio, n√£o faz nada no banco de dados
    if (novoValor === valorOriginal || novoValor === '') {
      spanElement.textContent = valorOriginal; // Restaura o valor original se ficou vazio
      return;
    }

    try {
      const membroRef = doc(db, "membros", membroId);
      await updateDoc(membroRef, {
        [campo]: novoValor
      });
      mostrarPopup("‚úÖ Sucesso", `Informa√ß√£o atualizada!`, 3000);
    } catch (error) {
      console.error("Erro ao atualizar informa√ß√£o:", error);
      mostrarPopup("‚ùå Erro", "Ocorreu um erro ao salvar.", 4000);
      spanElement.textContent = valorOriginal; // Restaura em caso de erro
    }
  };

  // Fun√ß√£o para lidar com as teclas Enter e Escape
  const lidarComTeclas = (e) => {
    if (e.key === 'Enter') {
      e.preventDefault(); // Evita criar uma nova linha
      salvarEdicao();
    } else if (e.key === 'Escape') {
      // Cancela a edi√ß√£o, restaurando o valor original
      spanElement.textContent = valorOriginal;
      salvarEdicao(); // Chama para limpar os eventos e classes
    }
  };

  // Adiciona os ouvintes de evento
  spanElement.addEventListener('blur', salvarEdicao); // Salva quando o foco √© perdido
  spanElement.addEventListener('keydown', lidarComTeclas); // Salva com Enter, cancela com Esc
};

// Fun√ß√£o para mostrar/esconder a paleta de cores do card
window.toggleColorPalette = function(event, membroId) {
  event.stopPropagation();
  const palette = document.getElementById(`palette-${membroId}`);
  palette.classList.toggle('hidden');
}

// Fun√ß√£o que gera as 30 cores na paleta
function criarPaletaDeCoresDoCard(membroId) {
  const paletteContainer = document.getElementById(`palette-${membroId}`);
  if (!paletteContainer) return;

  const cores = [
    // Tons Past√©is e Claros
    '#FFFFFF', '#FADADD', '#FFD6A5', '#FDFFB6', '#CAFFBF', '#9BF6FF', 
    '#A0C4FF', '#BDB2FF', '#FFC6FF', '#EAE4E9', '#D4E09B', '#C3E0E5',
    '#F7D6E0', '#F3E9DD', '#D3E4CD',
    // Tons Vibrantes e Saturados
    '#FF1744', '#F50057', '#D500F9', '#651FFF', '#3D5AFE', '#2979FF',
    '#00B0FF', '#00E5FF', '#1DE9B6', '#00E676', '#76FF03', '#C6FF00',
    '#FFEA00', '#FFC400', '#FF9100', '#FF3D00',
    // Tons S√≥brios e Escuros
    '#F38375', '#FBC42C', '#57C479', '#57C5C8', '#578DC8', '#8A57C8',
    '#C857B2', '#4B4A49', '#ACACAC', '#795548', '#607D8B', '#000000',
    // Paleta Adicional
    '#E57373', '#BA68C8', '#7986CB', '#4FC3F7', '#4DB6AC', '#AED581',
    '#FFF176', '#FFB74D', '#A1887F', '#90A4AE', '#008F93', '#F08080',
    '#20B2AA', '#87CEEB', '#9370DB', '#DA70D6'
  ];

  paletteContainer.innerHTML = ''; // Limpa antes de adicionar

  cores.forEach(cor => {
    const corEl = document.createElement('div');
    corEl.className = 'card-color-option';
    corEl.style.backgroundColor = cor;
    corEl.onclick = (event) => selecionarCorDoCard(event, membroId, cor);
    paletteContainer.appendChild(corEl);
  });
}

// Fun√ß√£o para salvar a cor escolhida no Firestore
async function selecionarCorDoCard(event, membroId, cor) {
  event.stopPropagation();

  try {
    const membroRef = doc(db, "membros", membroId);
    await updateDoc(membroRef, {
      corCard: cor
    });

    const cardElement = document.getElementById(`card-membro-${membroId}`);
    if (cardElement) {
      cardElement.style.backgroundColor = cor;

      // ===== IN√çCIO DA ADAPTA√á√ÉO DE COR DO TEXTO =====
      if (isColorDark(cor)) {
        cardElement.classList.add('text-light');
      } else {
        cardElement.classList.remove('text-light');
      }
      // ===== FIM DA ADAPTA√á√ÉO DE COR DO TEXTO =====

      const isDark = isColorDark(cor);
      const colorChooserBtn = cardElement.querySelector('.card-color-chooser-btn');
      if (colorChooserBtn) {
        colorChooserBtn.style.color = isDark ? 'white' : 'black';
        colorChooserBtn.style.borderColor = isDark ? 'white' : 'black';
      }
    }

    const palette = document.getElementById(`palette-${membroId}`);
    if(palette) palette.classList.add('hidden');

    mostrarPopup("üé® Sucesso", "A cor do seu card foi alterada!", 3000);

  } catch (error) {
    console.error("Erro ao salvar cor do card:", error);
    mostrarPopup("‚ùå Erro", "N√£o foi poss√≠vel salvar a cor.", 4000);
  }
}

// NOVA FUN√á√ÉO: Manipula a marca√ß√£o/desmarca√ß√£o de uma checkbox e atualiza o Firestore
async function marcarConcluido(memberId, taskId, data, isChecked) {
    const checkboxElement = document.getElementById(`task-${memberId}-${taskId}-${data}`);
    const memberTeam = checkboxElement ? checkboxElement.dataset.memberTeam : null;

    // Verificar permiss√µes ANTES de qualquer modifica√ß√£o no Firestore
    if (!podeMarcarCheckbox(memberId, memberTeam)) {
        mostrarPopup("Erro", "Voc√™ n√£o tem permiss√£o para marcar/desmarcar esta tarefa.", 3000);
        if (checkboxElement) {
            checkboxElement.checked = !isChecked; // Reverte o estado visual da checkbox
        }
        return; // Impede a execu√ß√£o do restante da fun√ß√£o
    }

    const membroRef = doc(db, "membros", memberId);
    const dataConclusaoCampo = `focoDiario.${data}.${taskId}`; // Caminho para a tarefa espec√≠fica no dia
    const focoDiaCampo = `focoDia.${data}`; // Caminho para o total de foco no dia

    // Usamos uma transa√ß√£o para garantir atomicidade nas opera√ß√µes de leitura/escrita
    try {
        await runTransaction(db, async (transaction) => {
            const docSnap = await transaction.get(membroRef);
            if (!docSnap.exists()) {
                throw new Error("Membro n√£o encontrado.");
            }
            const membroData = docSnap.data();

            // Obter o estado atual dos pontos semanais da equipe (assumindo que j√° foram carregados globalmente)
            let pontosSemanaAtuaisDaEquipe = pontosSemanais[memberTeam] || 0;
            // Obter o foco total do dia para o membro
            let totalFocoDiaAtualDoMembro = (membroData.focoDia && membroData.focoDia[data]) || 0;

            // Verificar se a tarefa j√° estava marcada ou desmarcada no Firestore
            const tarefaEstavaMarcada = membroData.focoDiario && membroData.focoDiario[data] && membroData.focoDiario[data][taskId];

            if (isChecked) {
                // Se o usu√°rio marcou a checkbox e ela N√ÉO estava marcada no Firestore
                if (!tarefaEstavaMarcada) {
                    transaction.update(membroRef, {
                        [dataConclusaoCampo]: true, // Marca a tarefa como true
                        [focoDiaCampo]: increment(1) // Incrementa o contador de foco do dia
                    });
                    pontosSemanaAtuaisDaEquipe++; // Incrementa os pontos locais da equipe
                }
            } else {
                // Se o usu√°rio desmarcou a checkbox e ela ESTAVA marcada no Firestore
                if (tarefaEstavaMarcada) {
                    transaction.update(membroRef, {
                        [dataConclusaoCampo]: false, // Marca a tarefa como false
                        [focoDiaCampo]: increment(-1) // Decrementa o contador de foco do dia
                    });
                    pontosSemanaAtuaisDaEquipe--; // Decrementa os pontos locais da equipe
                }
            }

            // Atualizar os pontos semanais da equipe no documento "semanas/pontosSemanais"
            if (memberTeam && pontosSemanais[memberTeam] !== undefined) {
                const pontosSemanaisRef = doc(db, "semanas", "pontosSemanais");
                transaction.update(pontosSemanaisRef, {
                    [memberTeam]: pontosSemanaAtuaisDaEquipe
                });
                pontosSemanais[memberTeam] = pontosSemanaAtuaisDaEquipe; // Atualiza a vari√°vel global
            }
        });

        console.log("Atualiza√ß√£o conclu√≠da com sucesso!");
        mostrarPopup("Sucesso", "Tarefa atualizada!", 2000);

        // Chamar verificarConquista para atualizar streaks, fora da transa√ß√£o principal
        await verificarConquista(memberId, isChecked ? 'adicionar' : 'remover');

        // Re-executar o resumo geral para atualizar os contadores na UI
        await window.atualizarResumo();

    } catch (error) {
        console.error("Erro ao atualizar o documento: ", error);
        mostrarPopup("Erro", `Erro ao atualizar a tarefa: ${error.message || error}`, 3000);
        if (checkboxElement) {
            checkboxElement.checked = !isChecked; // Reverte o estado visual da checkbox em caso de erro
        }
    }
}

// NOVA FUN√á√ÉO PARA TOGGLE DE PAUSA
window.togglePausa = function() {
  carrosselPausado = !carrosselPausado;
  const botaoPausa = document.getElementById('botao-pausa');
  
  if (carrosselPausado) {
    clearInterval(carrosselInterval);
    botaoPausa.textContent = '‚ñ∂';
    // Pausar a barra
    const barra = document.getElementById('progresso-indicador-barra');
    if (barra) {
      barra.style.transition = 'none';
      barra.dataset.width = barra.style.width;
    }
  } else {
    botaoPausa.textContent = '‚è∏';
    // Retomar a barra
    const barra = document.getElementById('progresso-indicador-barra');
    if (barra) {
      barra.style.transition = 'width 10s linear';
      barra.style.width = barra.dataset.width || '100%';
    }
    iniciarCarrosselAutomatico();
  }
}

// NOVA FUN√á√ÉO PARA BARRA DE PROGRESSO
function iniciarBarraProgresso() {
  const barra = document.getElementById('progresso-indicador-barra');
  if (barra) {
    // Resetar a barra
    barra.style.transition = 'none';
    barra.style.width = '0%';
    
    // For√ßar reflow para que o reset seja aplicado
    void barra.offsetWidth;
    
    // Agora ativar a anima√ß√£o
    barra.style.transition = 'width 10s linear';
    setTimeout(() => {
      if (!carrosselPausado) {
        barra.style.width = '100%';
      }
    }, 10);
    
    // Limpar timeout anterior se existir
    if (progressoBarra) {
      clearTimeout(progressoBarra);
    }
    
    // Configurar para resetar a barra ap√≥s 10 segundos
    progressoBarra = setTimeout(() => {
      barra.style.width = '0%';
    }, 10000);
  }
}

// Fun√ß√µes de controle do carrossel
window.mudarSlide = function(direction) {
  reiniciarIntervaloCarrossel();
  const totalCards = document.querySelectorAll('.card-membro').length;
  
  if (totalCards === 0) return;
  
  currentCarrosselIndex = (currentCarrosselIndex + direction + totalCards) % totalCards;
  irParaSlide(currentCarrosselIndex);
}

function irParaSlide(index) {
  const carrosselContainer = document.getElementById("carrossel-container");
  carrosselContainer.style.transform = `translateX(-${index * 100}%)`;
  
  const indicadores = document.querySelectorAll('#carrossel-indicadores .carrossel-indicador');
  indicadores.forEach((ind, i) => {
    ind.classList.toggle('ativo', i === index);
  });
  
  currentCarrosselIndex = index;
if (!carrosselPausado) iniciarBarraProgresso();
}


function iniciarCarrosselAutomatico() {
  if (carrosselInterval) clearInterval(carrosselInterval);
  
  carrosselInterval = setInterval(() => {
    if (totalSlides > 0 && !carrosselPausado) {
      currentCarrosselIndex = (currentCarrosselIndex + 1) % totalSlides;
      irParaSlide(currentCarrosselIndex);
    }
  }, 10000); // Alterado para 10 segundos
  
  iniciarBarraProgresso();
}

function reiniciarIntervaloCarrossel() {
  clearInterval(carrosselInterval);
  iniciarCarrosselAutomatico();
  iniciarBarraProgresso();
}

// =============================================
// ===== IN√çCIO: FUN√á√ïES DO HALL DA FAMA =====
// =============================================

async function carregarHallDaFama() {
  console.log("Carregando Hall da Fama...");
  try {
    // 1. Limpa o cache
    hallDaFamaCache = [];

    // 2. Busca campe√µes dos anos anteriores
    const q = query(collection(db, "hallDaFama"), orderBy("ano", "desc"));
    const querySnapshot = await getDocs(q);
    querySnapshot.forEach(doc => {
      hallDaFamaCache.push(doc.data());
    });

    console.log(`Encontrados ${hallDaFamaCache.length} campe√µes no Hall da Fama.`);

    // 3. Constr√≥i o carrossel com os dados
    construirCarrosselHallDaFama();
  } catch (error) {
    console.error("Erro ao carregar Hall da Fama:", error);
    // Em caso de erro, constr√≥i o carrossel apenas com o placeholder
    construirCarrosselHallDaFama();
  }
}

function construirCarrosselHallDaFama() {
  const carrosselContainer = document.getElementById('carrossel-container-hall-fama');
  const indicadoresContainer = document.getElementById('carrossel-indicadores-hall-fama');
  const controlesContainer = document.getElementById('controles-hall-fama');
  const progressoContainer = document.getElementById('progresso-hall-fama');

  if (!carrosselContainer) return;

  carrosselContainer.innerHTML = '';
  if (indicadoresContainer) indicadoresContainer.innerHTML = '';

  // --- CORRE√á√ÉO DE ANO (BUG DO DUPLO 2025) ---
  // Verifica se j√° existe um campe√£o no hist√≥rico com o ano atual do sistema.
  // Se existir (ex: Vaga-lume ganhou 2025 e hoje ainda √© 2025), o placeholder vira 2026.
  let anoDoPlaceholder = ANO_ATUAL;
  const jaTemCampeaoEsteAno = hallDaFamaCache.some(h => h.ano == ANO_ATUAL);
  
  if (jaTemCampeaoEsteAno) {
      anoDoPlaceholder = ANO_ATUAL + 1;
  }
  // -------------------------------------------

  // 1. Criar o card "placeholder" para a PR√ìXIMA temporada
  const placeholderCard = document.createElement('div');
  placeholderCard.className = 'card-hall-fama placeholder';
  placeholderCard.innerHTML = `
    <div class="card-hall-ano">Temporada ${anoDoPlaceholder}</div>
    
    <div class="card-hall-equipe" style="flex-direction: column; gap: 5px;">
      <span class="card-hall-emoji">üèÜ</span>
      <span class="card-hall-nome">Aguardando Campe√£</span>
    </div>
    <div class="card-hall-vitorias">A competi√ß√£o est√° em andamento!</div>
  `;
  carrosselContainer.appendChild(placeholderCard);

  // 2. Criar os cards para as campe√£s anteriores (do cache)
  hallDaFamaCache.forEach(campea => {
    const card = document.createElement('div');
    let vencedoras = campea.vencedora;

    // Compatibilidade: Se vier string antiga do banco, converte para array
    if (typeof vencedoras === 'string') {
        vencedoras = [vencedoras.toLowerCase()];
    } else {
        // Garante min√∫sculas
        vencedoras = vencedoras.map(v => v.toLowerCase());
    }

    // Configura√ß√£o de cores (Fundo e Borda) e Emojis
    const configEquipes = {
        'abelha': { cor: '#fffbeb', border: '#f1c40f', emoji: 'üêù', nome: 'Abelha' },
        'joaninha': { cor: '#ffebee', border: '#e74c3c', emoji: 'üêû', nome: 'Joaninha' },
        'vagalume': { cor: '#e8f5e9', border: '#2ecc71', emoji: 'üí°', nome: 'Vaga-lume' }
    };

    let backgroundStyle = '';
    let emojisHTML = '';
    let nomesHTML = '';

    // Remove classes antigas e define a base
    card.className = 'card-hall-fama';

    // === L√ìGICA PARA EMPATE (2 ou mais equipes) ===
    if (vencedoras.length > 1) {
        card.classList.add('empate'); // Classe CSS para ajustes finos
        
        // 1. Configura o GRADIENTE DE FUNDO
        const percentual = (100 / vencedoras.length).toFixed(2);
        let gradienteParts = [];
        let coresBorda = [];
        
        vencedoras.forEach((eq, index) => {
            const config = configEquipes[eq] || { cor: '#ffffff', border: '#000', emoji: 'üèÜ', nome: eq };
            
            // Gradiente
            const start = index * percentual;
            const end = (index + 1) * percentual;
            gradienteParts.push(`${config.cor} ${start}% ${end}%`);
            
            // Cores para a borda
            coresBorda.push(config.border);

            // HTML Interno
            emojisHTML += `<span class="card-hall-emoji multi">${config.emoji}</span>`;
            const nomeCapitalizado = config.nome;
            nomesHTML += (index === 0 ? '' : (index === vencedoras.length - 1 ? ' e ' : ', ')) + nomeCapitalizado;
        });

        // Aplica o fundo gradiente
        card.style.background = `linear-gradient(90deg, ${gradienteParts.join(', ')})`;
        
        // 2. Configura as BORDAS COLORIDAS
        card.style.borderWidth = '4px'; // Borda um pouco mais grossa para destacar
        card.style.borderStyle = 'solid';
        
        if (vencedoras.length === 2) {
            // Empate Duplo: Topo/Esq = Equipe 1, Baixo/Dir = Equipe 2
            card.style.borderTopColor = coresBorda[0];
            card.style.borderLeftColor = coresBorda[0];
            card.style.borderRightColor = coresBorda[1];
            card.style.borderBottomColor = coresBorda[1];
        } else {
            // Empate Triplo: Distribui as cores pelos lados
            card.style.borderTopColor = coresBorda[0];   // Equipe 1
            card.style.borderRightColor = coresBorda[1]; // Equipe 2
            card.style.borderBottomColor = coresBorda[2]; // Equipe 3
            card.style.borderLeftColor = coresBorda[0];  // Repete a 1 para fechar o quadro
        }
        
    } else {
        // === L√ìGICA PARA VENCEDOR √öNICO (Padr√£o) ===
        const equipeId = vencedoras[0];
        card.classList.add(equipeId); // Usa as classes CSS padr√£o (.abelha, .joaninha...)
        
        const config = configEquipes[equipeId] || { emoji: 'üèÜ', nome: equipeId };
        emojisHTML = `<span class="card-hall-emoji">${config.emoji}</span>`;
        nomesHTML = `Equipe ${config.nome}`;
        
        // Limpa estilos inline que podem ter ficado de renderiza√ß√µes anteriores
        card.style.background = '';
        card.style.borderColor = '';
        card.style.borderWidth = '';
    }

    card.innerHTML = `
      <div class="card-hall-ano">Temporada ${campea.ano}</div>
      <div class="card-hall-equipe-container">
        <div class="card-hall-emojis-wrapper">
            ${emojisHTML}
        </div>
        <span class="card-hall-nome ${vencedoras.length > 1 ? 'multi-nome' : ''}">${nomesHTML}</span>
      </div>
      <div class="card-hall-vitorias">${vencedoras.length > 1 ? 'Co-Campe√£s' : 'Campe√£'} com ${campea.vitorias} vit√≥rias!</div>
    `;
    
    carrosselContainer.appendChild(card);
  });

  // 3. Configurar carrossel e indicadores
  totalSlidesHallDaFama = carrosselContainer.children.length;

  // Se houver mais de 1 slide (o placeholder + um campe√£o), ativa os controles
  if (totalSlidesHallDaFama > 1) {
    if (indicadoresContainer) indicadoresContainer.style.display = 'flex';
    if (controlesContainer) controlesContainer.style.display = 'flex';
    if (progressoContainer) progressoContainer.style.display = 'block';

    for (let i = 0; i < totalSlidesHallDaFama; i++) {
      const indicador = document.createElement('div');
      indicador.className = 'carrossel-indicador';
      indicador.onclick = () => {
        reiniciarIntervaloCarrosselHallDaFama();
        irParaSlideHallDaFama(i);
      };
      if (indicadoresContainer) indicadoresContainer.appendChild(indicador);
    }
    
    document.querySelector('#carrossel-indicadores-hall-fama .carrossel-indicador')?.classList.add('ativo');
    iniciarCarrosselAutomaticoHallDaFama();
  } else {
    // Se s√≥ houver o placeholder, esconde os controles
    if (indicadoresContainer) indicadoresContainer.style.display = 'none';
    if (controlesContainer) controlesContainer.style.display = 'none';
    if (progressoContainer) progressoContainer.style.display = 'none';
  }

  irParaSlideHallDaFama(0);
}

// --- Fun√ß√µes de Controle do Carrossel Hall da Fama ---
function iniciarCarrosselAutomaticoHallDaFama() {
  if (carrosselHallDaFamaInterval) clearInterval(carrosselHallDaFamaInterval);
  if (totalSlidesHallDaFama <= 1) return;

  carrosselHallDaFamaInterval = setInterval(() => {
    if (!carrosselHallDaFamaPausado) {
      currentCarrosselHallDaFamaIndex = (currentCarrosselHallDaFamaIndex + 1) % totalSlidesHallDaFama;
      irParaSlideHallDaFama(currentCarrosselHallDaFamaIndex);
    }
  }, 10000);
  iniciarBarraProgressoHallDaFama();
}

function irParaSlideHallDaFama(index) {
  const carrosselContainer = document.getElementById("carrossel-container-hall-fama");
  if (!carrosselContainer) return;
  carrosselContainer.style.transform = `translateX(-${index * 100}%)`;

  const indicadores = document.querySelectorAll('#carrossel-indicadores-hall-fama .carrossel-indicador');
  indicadores.forEach((ind, i) => {
    ind.classList.toggle('ativo', i === index);
  });

  currentCarrosselHallDaFamaIndex = index;
  if (!carrosselHallDaFamaPausado) iniciarBarraProgressoHallDaFama();
}

function iniciarBarraProgressoHallDaFama() {
  const barra = document.getElementById('progresso-indicador-barra-hall-fama');
  if (!barra || totalSlidesHallDaFama <= 1) return;

  barra.style.transition = 'none';
  barra.style.width = '0%';
  void barra.offsetWidth;

  barra.style.transition = 'width 10s linear';
  setTimeout(() => {
    if (!carrosselHallDaFamaPausado) {
      barra.style.width = '100%';
    }
  }, 10);

  if (progressoBarraHallDaFama) clearTimeout(progressoBarraHallDaFama);
  progressoBarraHallDaFama = setTimeout(() => {
    if (!carrosselHallDaFamaPausado) barra.style.width = '0%';
  }, 10000);
}

window.mudarSlideHallDaFama = function(direction) {
  if (totalSlidesHallDaFama <= 1) return;
  reiniciarIntervaloCarrosselHallDaFama();
  currentCarrosselHallDaFamaIndex = (currentCarrosselHallDaFamaIndex + direction + totalSlidesHallDaFama) % totalSlidesHallDaFama;
  irParaSlideHallDaFama(currentCarrosselHallDaFamaIndex);
}

window.togglePausaHallDaFama = function() {
  if (totalSlidesHallDaFama <= 1) return;
  carrosselHallDaFamaPausado = !carrosselHallDaFamaPausado;
  const botaoPausa = document.getElementById('botao-pausa-hall-fama');
  const barra = document.getElementById('progresso-indicador-barra-hall-fama');

  if (carrosselHallDaFamaPausado) {
    clearInterval(carrosselHallDaFamaInterval);
    botaoPausa.textContent = '‚ñ∂';
    if(barra) {
      barra.style.transition = 'none';
      barra.dataset.width = window.getComputedStyle(barra).width;
      if (progressoBarraHallDaFama) clearTimeout(progressoBarraHallDaFama);
    }
  } else {
    botaoPausa.textContent = '‚è∏';
    if(barra) {
      barra.style.transition = 'width 10s linear';
      setTimeout(() => { barra.style.width = '100%'; }, 10);
    }
    iniciarCarrosselAutomaticoHallDaFama();
  }
}

function reiniciarIntervaloCarrosselHallDaFama() {
  if (totalSlidesHallDaFama <= 1) return;
  clearInterval(carrosselHallDaFamaInterval);
  iniciarCarrosselAutomaticoHallDaFama();
}
// =============================================
// ===== FIM: FUN√á√ïES DO HALL DA FAMA =====
// =============================================

  // Fun√ß√£o para reconstruir a interface com os membros carregados
  function construirInterface() {
    const gruposContainer = document.querySelector('.grupos-container');
    if (!gruposContainer) return;
    
    gruposContainer.innerHTML = '';

    // Grupos para cada equipe
    for (const [equipeNome, equipe] of Object.entries(equipes)) {
      const grupo = document.createElement('div');
      grupo.className = 'grupo';
      grupo.id = `equipe-${equipeNome}`;

      let emoji = '';
      if (equipeNome === 'abelha') emoji = 'üêù';
      else if (equipeNome === 'joaninha') emoji = 'üêû';
      else if (equipeNome === 'vagalume') emoji = 'üí°';

      grupo.innerHTML = `
        <h2>${emoji} Equipe ${equipeNome.charAt(0).toUpperCase() + equipeNome.slice(1)}</h2>
        <div class="resumo" id="resumo-${equipeNome}">
          <div>0 focaram hoje!</div>
          <div>0 pontos na semana</div>
          <div>M√©dia: <span id="media-${equipeNome}">0.00</span></div>
        </div>
		<div class="mensagem-equipe-completa hidden" id="msg-equipe-${equipeNome}"></div>
      `;

      // √Årea do l√≠der da equipe
      const liderEquipeDiv = document.createElement('div');
      liderEquipeDiv.className = 'lider-equipe';
      liderEquipeDiv.innerHTML = `
        <div class="titulo-lider">L√≠der da Equipe</div>
      `;

      if (equipe.lider) {
        const liderMembroDiv = document.createElement('div');
        liderMembroDiv.className = 'membro';

        // --- L√ìGICA NOVA DE AUS√äNCIA PARA O L√çDER ---
        const deFeriasLider = equipe.lider.deFerias || false;
        let classeAusenciaLider = '';
        
        if (deFeriasLider) {
            if (equipe.lider.motivoAusencia === 'saude') {
                classeAusenciaLider = 'em-recuperacao';
            } else {
                classeAusenciaLider = 'em-ferias';
            }
        }
        
        const disabledAttrLider = deFeriasLider ? 'disabled' : '';
        // ---------------------------------------------

        liderMembroDiv.innerHTML = `
          <input type="checkbox" id="${equipe.lider.nome}" ${disabledAttrLider}>
          <label for="${equipe.lider.nome}" class="${classeAusenciaLider}">
            <span class="membro-nome ${equipe.lider.nome.length >= 6 ? 'long-name' : ''}"
                  title="${equipe.lider.nome}"
                  onclick="event.preventDefault(); mostrarPopup('üë§ Nome do Membro', '${equipe.lider.nome}', 2000)">
              ${equipe.lider.nome}
            </span>
            <span id="dias-${equipe.lider.nome}" class="dias-badge">0</span>
            <span class="medalha-container">
              <span id="medalha-${equipe.lider.nome}" class="medalha escondido"></span>
            </span>
          </label>
        `;
        liderEquipeDiv.appendChild(liderMembroDiv);
      } else {
        const semLider = document.createElement('div');
        semLider.className = 'sem-lider';
        semLider.textContent = 'Sem l√≠der';
        liderEquipeDiv.appendChild(semLider);
      }

      grupo.appendChild(liderEquipeDiv);

      // Lista de membros (excluindo l√≠der)
      const membrosGrid = document.createElement('div');
      membrosGrid.className = 'membros-grid';

      equipe.membros.forEach(membro => {
    if (equipe.lider && membro.nome === equipe.lider.nome) return;
    
    const membroDiv = document.createElement('div');
    membroDiv.className = 'membro';
    
    // Aplica o estado de aus√™ncia (F√©rias ou Sa√∫de)
    const deFerias = membro.deFerias || false;
    let classeAusencia = '';
    
    if (deFerias) {
        if (membro.motivoAusencia === 'saude') {
            classeAusencia = 'em-recuperacao';
        } else {
            classeAusencia = 'em-ferias';
        }
    }
    
    const disabledAttr = deFerias ? 'disabled' : '';

    membroDiv.innerHTML = `
      <input type="checkbox" id="${membro.nome}" ${disabledAttr}>
      <label for="${membro.nome}" class="${classeAusencia}">
        <span class="membro-nome ${membro.nome.length >= 6 ? 'long-name' : ''}"
              title="${membro.nome}"
              onclick="event.preventDefault(); mostrarPopup('üë§ Nome do Membro', '${membro.nome}', 2000)">
          ${membro.nome}
        </span>
        <span id="dias-${membro.nome}" class="dias-badge">0</span>
        <span class="medalha-container">
          <span id="medalha-${membro.nome}" class="medalha escondido"></span>
        </span>
      </label>
    `;
    membrosGrid.appendChild(membroDiv);
});

      grupo.appendChild(membrosGrid);
      gruposContainer.appendChild(grupo);
    }
	
	// Grupo do L√≠der Geral (AGORA CHAMADO DE GUARDI√ÉO/COORDENA√á√ÉO)
    const grupoLiderGeral = document.createElement('div');
    grupoLiderGeral.className = 'grupo';
    grupoLiderGeral.id = 'lider-geral';
    
    // Altera√ß√£o 1: Mudei o texto de "L√≠der Geral" para "Guardi√£o". Edite se preferir outro.
    // Altera√ß√£o 2: Adicionei o emoji üëë direto aqui para n√£o depender do CSS.
    grupoLiderGeral.innerHTML = `
      <h2>üëë Guardi√£o</h2> 
    `;

    // Altera√ß√£o 3: Usamos a estrutura 'lider-equipe' para o card ficar largo e centralizado
    const containerLider = document.createElement('div');
    containerLider.className = 'lider-equipe'; 
    // Removemos bordas/fundo extras para ficar limpo dentro do grupo
    containerLider.style.boxShadow = 'none'; 
    containerLider.style.background = 'transparent';
    containerLider.style.border = 'none';
    containerLider.style.padding = '0';

    if (liderGeral) {
        // L√≥gica de aus√™ncia (copiada dos l√≠deres de equipe)
        const deFeriasLider = liderGeral.deFerias || false;
        let classeAusenciaLider = '';
        if (deFeriasLider) {
            classeAusenciaLider = liderGeral.motivoAusencia === 'saude' ? 'em-recuperacao' : 'em-ferias';
        }
        const disabledAttrLider = deFeriasLider ? 'disabled' : '';

        containerLider.innerHTML = `
          <div class="membro" style="width: 100%;"> <input type="checkbox" id="${liderGeral.nome}" ${disabledAttrLider}>
            <label for="${liderGeral.nome}" class="${classeAusenciaLider}">
              <span class="membro-nome ${liderGeral.nome.length >= 6 ? 'long-name' : ''}" 
                    title="${liderGeral.nome}" 
                    onclick="event.preventDefault(); mostrarPopup('üë§ Nome do Membro', '${liderGeral.nome}', 2000)">
                ${liderGeral.nome}
              </span>
              <span id="dias-${liderGeral.nome}" class="dias-badge">0</span>
              <span class="medalha-container">
                <span id="medalha-${liderGeral.nome}" class="medalha escondido"></span>
              </span>
            </label>
          </div>
        `;
    } else {
         containerLider.innerHTML = `<div class="sem-lider">Cargo Vago</div>`;
    }

    grupoLiderGeral.appendChild(containerLider);
    gruposContainer.appendChild(grupoLiderGeral);
    
    // Adicionar evento de mudan√ßa apenas uma vez
    todosMembros.forEach(membro => { const nome = membro.nome;
      const checkbox = document.getElementById(nome);
      if (checkbox) {
        checkbox.onchange = () => marcarCheckbox(nome);
      }
    });
  }

  // ===== FUN√á√ïES PARA O PAINEL SECRETO =====
  window.togglePainelSecreto = function(show) {
    const painel = document.getElementById('painel-secreto');
    if (show) {
      painel.style.display = 'block';
    } else {
      painel.style.display = 'none';
    }
  }

  // Ativar painel secreto ap√≥s 5 cliques na medalha de diamante
  function verificarCliquesDiamante() {
    cliqueCount++;
    clearTimeout(timeoutClique);
    
    if (cliqueCount === 5) {
      const senha = prompt("üîê Digite a senha para acessar o painel secreto:");
      if (senha === "goiaba") {
        togglePainelSecreto(true);
      } else {
        alert("‚ùå Senha incorreta!");
      }
      cliqueCount = 0;
    } else {
      timeoutClique = setTimeout(() => {
        cliqueCount = 0;
      }, 3000);
    }
  }
  
  let intervaloConfete = null;
  let animacaoConfeteAniversarioId = null; // Para controlar o loop de anima√ß√£o
  let geradorDeParticulasId = null;     // Para controlar a cria√ß√£o de novas part√≠culas
  let particulasAniversario = [];       // Array para guardar as part√≠culas do anivers√°rio

function carregarAniversariantes() {
  const hoje = getHoje();
  const mesAtual = hoje.getMonth() + 1;
  const diaAtual = hoje.getDate();
  
  const aniversariantes = [];
  let proximoAniversario = null;
  let menorDiferenca = Infinity;

  // === MUDAN√áA PRINCIPAL: Usa a vari√°vel 'todosMembros' em vez de fazer uma nova leitura ===
  todosMembros.forEach(membro => {
    if (membro.aniversario) {
      const [dia, mes] = membro.aniversario.split('/').map(Number);
      
      // Verifica se √© anivers√°rio este m√™s
      if (mes === mesAtual) {
        aniversariantes.push({
          nome: membro.nome,
          data: membro.aniversario,
          hoje: (dia === diaAtual)
        });
      }
      
      // Calcula pr√≥ximo anivers√°rio
      let dataAniversario = new Date(hoje.getFullYear(), mes - 1, dia);
      if (dataAniversario < hoje) {
        dataAniversario.setFullYear(hoje.getFullYear() + 1);
      }
      
      const diff = Math.ceil((dataAniversario - hoje) / (1000 * 60 * 60 * 24));
      if (diff < menorDiferenca) {
        menorDiferenca = diff;
        proximoAniversario = {
          nome: membro.nome,
          dias: diff,
          data: membro.aniversario
        };
      }
    }
  });

  // O resto da fun√ß√£o continua igual
  atualizarInterfaceAniversariantes(aniversariantes, proximoAniversario);
  
  if (aniversariantes.some(a => a.hoje)) {
    iniciarConfeteAniversarioContinuo();
  } else {
    pararConfeteAniversarioContinuo();
  }
}
  
// SUBSTITUA A FUN√á√ÉO ANTIGA PELA VERS√ÉO ABAIXO
async function verificarAniversariantesDoDia() {
  try {
    console.log("Verificando aniversariantes do dia...");
    const hoje = getHoje();
    const diaAtual = hoje.getDate();
    const mesAtual = hoje.getMonth() + 1;

    // A vari√°vel 'todosMembros' j√° est√° carregada
    const aniversariantesDeHoje = todosMembros.filter(membro => {
      if (!membro.aniversario) return false;
      const [dia, mes] = membro.aniversario.split('/').map(Number);
      return dia === diaAtual && mes === mesAtual;
    });

    if (aniversariantesDeHoje.length > 0) {
      console.log(`Encontrados ${aniversariantesDeHoje.length} aniversariante(s) hoje!`);
      
      for (const aniversariante of aniversariantesDeHoje) {
        // Marca a presen√ßa como um "presente" para o aniversariante
        await marcarPresencaAniversario(aniversariante);

        // --- IN√çCIO DA L√ìGICA DO POPUP DE ANIVERS√ÅRIO ---
        // Verifica se o aniversariante √© o usu√°rio logado
        if (aniversariante.nome === currentUser) {
            // Trava removida: Aparecer√° sempre no dia do anivers√°rio ao logar/atualizar
            const mensagem = `
              Hoje o dia √© todo seu! üéâ<br><br>
              Que seu novo ciclo seja repleto de realiza√ß√µes, alegrias e muito foco para alcan√ßar seus sonhos. Agradecemos por fazer parte do nosso grupo e por compartilhar sua jornada conosco.<br><br>
              Seu foco de hoje j√° foi marcado. Aproveite muito o seu dia!
            `;
            // A fun√ß√£o 'dispararConfete' ser√° chamada quando o usu√°rio fechar o card
            // ADICIONADO: ID √∫nico "aniversario_usuario"
            mostrarCardPopup(`Feliz Anivers√°rio, ${currentUser}!`, mensagem, dispararConfete, "Grupo √âpicos", "aniversario_usuario");
        }
        // --- FIM DA L√ìGICA DO POPUP DE ANIVERS√ÅRIO ---
      }
    } else {
      console.log("Nenhum aniversariante hoje.");
    }

  } catch (error) {
    console.error("Erro ao verificar aniversariantes do dia:", error);
  }
}

  function atualizarInterfaceAniversariantes(aniversariantes, proximo) {
    const hojeContainer = document.getElementById('aniversariantes-hoje');
    const proximosContainer = document.getElementById('proximos-aniversarios');
    
    hojeContainer.innerHTML = '';
    proximosContainer.innerHTML = '';
    
    const containerHoje = document.createElement('div');
    containerHoje.className = 'aniversariantes-container-hoje';
    
    if (aniversariantes.length > 0) {
      aniversariantes.forEach(aniversariante => {
        const card = document.createElement('div');
        card.className = 'aniversariante-card';
        if (aniversariante.hoje) {
          card.classList.add('hoje');
        }
        card.innerHTML = `
          <div class="aniversariante-nome">${aniversariante.nome}</div>
          <div class="aniversariante-data">${aniversariante.data}</div>
        `;
        containerHoje.appendChild(card);
      });
    } else {
      const card = document.createElement('div');
      card.className = 'aniversariante-card mensagem-vazia';
      card.textContent = 'Nenhum aniversariante neste m√™s';
      containerHoje.appendChild(card);
    }
    
    hojeContainer.appendChild(containerHoje);
    
    if (proximo) {
      // ADICIONADO SUBT√çTULO AQUI
      proximosContainer.innerHTML = `
        <div style="font-weight:bold; margin-bottom:8px; font-size:1.1rem;">Pr√≥ximo Aniversariante:</div>
        <div>Faltam <strong>${proximo.dias}</strong> dias para o anivers√°rio de</div>
        <div><strong>${proximo.nome}</strong> (${proximo.data})</div>
      `;
    } else {
      proximosContainer.innerHTML = '<div>Nenhum pr√≥ximo anivers√°rio cadastrado</div>';
    }
  }

   function iniciarConfetePeriodico() {
    pararConfetePeriodico();
    // Agora chama a mesma fun√ß√£o de confete das conquistas
    // O intervalo foi aumentado para 5 segundos para n√£o sobrecarregar a tela
    intervaloConfete = setInterval(dispararConfete, 5000); 
    
    // Dispara uma vez imediatamente
    dispararConfete();
  }

  function pararConfetePeriodico() {
    if (intervaloConfete) {
      clearInterval(intervaloConfete);
      intervaloConfete = null;
    }
  }
  
function exibirQuadroFolgas() {
  try {
    const hoje = getHoje().toLocaleDateString("pt-BR", { weekday: "long" });
    const hojeNormalizado = hoje.toLowerCase()
      .replace(/-feira$/, "")
      .normalize('NFD').replace(/[\u0300-\u036f]/g, "");

    const dias = ["segunda", "terca", "quarta", "quinta", "sexta", "sabado", "domingo"];
    const listasDias = {};

    // Resetar listas e guardar refer√™ncias
    dias.forEach(dia => {
      const lista = document.getElementById(dia);
      if (lista) {
        lista.innerHTML = "";
        lista.classList.remove('centralizado');
        listasDias[dia] = lista;
      }
    });

    // Destacar dia atual
    document.querySelectorAll('.dia-col').forEach(col => col.classList.remove('dia-hoje'));
    const diaHojeElement = document.getElementById(hojeNormalizado);
    if (diaHojeElement) {
      diaHojeElement.closest('.dia-col')?.classList.add('dia-hoje');
    }

    // --- 1¬∫: Adiciona os MEMBROS DE FOLGA COM EMOJIS ---
    todosMembros.forEach(membro => {
      const nome = membro.nome;
      const folga = membro.folga || "";
      const diaFolga = folga.toLowerCase()
        .replace(/-feira$/, "")
        .normalize('NFD').replace(/[\u0300-\u036f]/g, "");

      if (diaFolga && dias.includes(diaFolga) && listasDias[diaFolga]) {
        const lista = listasDias[diaFolga];
        const membroEl = document.createElement('div');
        membroEl.className = 'membro-folga';

        if (diaFolga === hojeNormalizado && nome === currentUser) {
            membroEl.classList.add('membro-folga-hoje');
        }
        
        // L√≥gica de Emojis
        let emoji = 'üë§';
        if (membro.papel === 'lider') emoji = '‚≠ê';
        else if (membro.equipe === 'abelha') emoji = 'üêù';
        else if (membro.equipe === 'joaninha') emoji = 'üêû';
        else if (membro.equipe === 'vagalume') emoji = 'üí°';

        membroEl.innerHTML = `<span style="margin-right:4px;">${emoji}</span>${nome}`;
        lista.appendChild(membroEl);
      }
    });

    // --- 2¬∫: ADICIONA "FOLGA COLETIVA" NO DOMINGO ---
    if (listasDias["domingo"]) {
        const folgaColetivaEl = document.createElement('div');
        folgaColetivaEl.className = 'membro-folga folga-coletiva';
        folgaColetivaEl.textContent = 'üèñÔ∏è Folga Coletiva';
        listasDias["domingo"].appendChild(folgaColetivaEl);
    }
    
    // (A parte antiga do cronograma foi removida daqui)

  } catch (error) {
    console.error("Erro ao exibir quadro de folgas:", error);
  }
}
  
  async function openChangeFolgaModal() {
  if (!currentUser) return;

  try {
    const userDocRef = doc(db, "membros", currentUser);
    const userDoc = await getDoc(userDocRef);

    if (userDoc.exists()) {
      const userData = userDoc.data();
      const semanaAtual = getSemanaAtual().numero;
      const semanaDaUltimaTroca = userData.semanaTrocaFolga || 0;

      // ===== IN√çCIO DA ALTERA√á√ÉO =====
      // REGRA: Verifica o limite semanal, A MENOS que o usu√°rio seja o l√≠der geral
      if (userRole !== 'lider') {
        if (semanaDaUltimaTroca === semanaAtual) {
          mostrarPopup("üö´ Limite Atingido", "Voc√™ j√° alterou sua folga esta semana. Tente novamente na pr√≥xima.", 5000);
          return;
        }
      }
      // ===== FIM DA ALTERA√á√ÉO =====

      // Preenche o select com a folga atual do usu√°rio
      const selectFolga = document.getElementById('select-new-folga');
      selectFolga.value = userData.folga || "segunda-feira";

      // Abre o modal
      openModal('change-folga-modal');
    }
  } catch (error) {
    console.error("Erro ao verificar permiss√£o de troca de folga:", error);
    mostrarPopup("‚ùå Erro", "N√£o foi poss√≠vel verificar seus dados de folga.", 3000);
  }
}

// NOVA FUN√á√ÉO PARA ABRIR O MODAL DE REAGENTES
window.abrirModalReagentes = async function(mensagemId, emoji) {
  try {
    const mensagemRef = doc(db, "mural", mensagemId);
    const docSnap = await getDoc(mensagemRef);

    if (!docSnap.exists()) return;

    const reacoes = docSnap.data().reacoes || {};
    const reagentes = Array.isArray(reacoes[emoji]) ? reacoes[emoji] : [];

    const modalTitle = document.getElementById('reactors-modal-title');
    const modalList = document.getElementById('reactors-modal-list');
    const removeBtn = document.getElementById('remove-my-reaction-btn');

    modalTitle.innerHTML = `Reagiram com ${emoji}`;
    modalList.innerHTML = ''; // Limpa a lista anterior

    if (reagentes.length > 0) {
      reagentes.forEach(nome => {
        const item = document.createElement('div');
        item.className = 'reactor-item';
        item.textContent = nome;
        modalList.appendChild(item);
      });
    } else {
      modalList.innerHTML = '<div class="reactor-item" style="text-align:center; font-style:italic;">Ningu√©m reagiu com este emoji ainda.</div>';
    }

    // L√≥gica para o bot√£o de remover rea√ß√£o
    if (currentUser && reagentes.includes(currentUser)) {
      removeBtn.style.display = 'block';
      removeBtn.onclick = async () => {
        await window.toggleReacao(mensagemId, emoji); // Chama a fun√ß√£o que j√° remove
        closeModal('reactors-modal'); // Fecha o modal ap√≥s a a√ß√£o
      };
    } else {
      removeBtn.style.display = 'none';
    }
    
    openModal('reactors-modal');

  } catch (error) {
    console.error("Erro ao abrir modal de reagentes:", error);
    mostrarPopup("‚ùå Erro", "N√£o foi poss√≠vel carregar quem reagiu.", 3000);
  }
};

// --- NOVA FUN√á√ÉO AUXILIAR ---
function getDataDaFolgaNaSemana(nomeDiaFolga) {
  const semana = getSemanaAtual();
  const inicioSemana = new Date(semana.inicio); // Segunda-feira
  
  // Normaliza a string para remover acentos e sufixos
  const diaNormalizado = nomeDiaFolga.toLowerCase()
    .replace(/-feira$/, "")
    .normalize('NFD').replace(/[\u0300-\u036f]/g, "");

  const mapaDias = {
    "segunda": 0,
    "terca": 1,
    "quarta": 2,
    "quinta": 3,
    "sexta": 4,
    "sabado": 5,
    "domingo": 6
  };

  if (mapaDias[diaNormalizado] !== undefined) {
    const dataAlvo = new Date(inicioSemana);
    dataAlvo.setDate(inicioSemana.getDate() + mapaDias[diaNormalizado]);
    return dataAlvo;
  }
  return null;
}

// --- NOVA FUN√á√ÉO DE RECUPERA√á√ÉO ---
async function processarRecuperacaoFolgaRetroativa(membroId, novoDiaFolga) {
  const hoje = getHoje();
  const dataAlvo = getDataDaFolgaNaSemana(novoDiaFolga);

  if (!dataAlvo) return;

  // Zera as horas para comparar apenas as datas
  const hojeZero = new Date(hoje.setHours(0,0,0,0));
  const alvoZero = new Date(dataAlvo.setHours(0,0,0,0));

  // S√≥ processa se a nova folga for em um dia que J√Å PASSOU nesta semana
  if (alvoZero < hojeZero) {
    const dataAlvoISO = formatarDataISO(dataAlvo);
    console.log(`Verificando recupera√ß√£o retroativa para ${dataAlvoISO}...`);

    const presencaRef = doc(db, "presencas", dataAlvoISO);
    const membroRef = doc(db, "membros", membroId);
    const pontosRef = doc(db, "semanas", "pontosSemanais");

    try {
      await runTransaction(db, async (transaction) => {
        // 1. Verifica se j√° existe presen√ßa neste dia passado
        const presencaSnap = await transaction.get(presencaRef);
        const jaFocouNesseDia = presencaSnap.exists() && presencaSnap.data()[membroId];

        if (!jaFocouNesseDia) {
          // RECUPERA√á√ÉO NECESS√ÅRIA!
          const membroSnap = await transaction.get(membroRef);
          if (!membroSnap.exists()) return;

          const dadosMembro = membroSnap.data();
          const equipe = dadosMembro.equipe;
          
          // Marca a presen√ßa retroativa
          transaction.set(presencaRef, { [membroId]: new Date() }, { merge: true });

          // Devolve o streak e as moedas
          transaction.update(membroRef, {
            streak: increment(1),
            moedas: increment(recompensasConfig.focoDiario || 100)
          });

          // Devolve o ponto da equipe (se n√£o for domingo)
          if (equipe && dataAlvo.getDay() !== 0) {
            transaction.update(pontosRef, { [equipe]: increment(1) });
          }
        }
      });

      // Feedback visual se houve recupera√ß√£o
      const presencaCheck = await getDoc(presencaRef);
      if (presencaCheck.exists() && presencaCheck.data()[membroId]) {
         window.mostrarPopup("üîÑ Dia Recuperado!", `Como sua nova folga (${novoDiaFolga}) foi num dia passado que voc√™ n√£o focou, sua presen√ßa foi recuperada automaticamente!`, 6000);
         
         // Atualiza visualmente se o usu√°rio estiver olhando o hist√≥rico
         if (streaksCache[membroId]) streaksCache[membroId]++;
         if (equipes[userTeam]) pontosSemanais[userTeam]++;
         atualizarPlacarSemanal();
         atualizarMedalhas();
      }

    } catch (error) {
      console.error("Erro na recupera√ß√£o retroativa:", error);
    }
  }
}

async function handleUpdateFolga() {
  const novoDia = document.getElementById('select-new-folga').value;
  if (!currentUser) return;

  const semanaAtual = getSemanaAtual().numero;
  const userDocRef = doc(db, "membros", currentUser);

  try {
    // Atualiza a folga e a semana da troca no Firestore
    await updateDoc(userDocRef, {
      folga: novoDia,
      semanaTrocaFolga: semanaAtual
    });

    // Atualiza a informa√ß√£o local no array 'todosMembros'
    const membroIndex = todosMembros.findIndex(m => m.nome === currentUser);
    if (membroIndex !== -1) {
      todosMembros[membroIndex].folga = novoDia; 
      console.log(`Folga local de ${currentUser} atualizada para ${novoDia}.`);
    } else {
      console.warn("N√£o foi poss√≠vel encontrar o membro atual no array local para atualizar a folga.");
    }

    // --- CORRE√á√ÉO AQUI: Adicionado 'window.' ---
    window.mostrarPopup("‚úÖ Sucesso", `Sua folga foi alterada para ${novoDia}!`, 4000);
    window.closeModal('change-folga-modal');

    // ATUALIZA O QUADRO DE FOLGAS IMEDIATAMENTE
    await exibirQuadroFolgas(); 

    // 1. Tenta recuperar dias passados (L√≥gica do Matt)
    await processarRecuperacaoFolgaRetroativa(currentUser, novoDia);

    // 2. L√≥gica para marcar checkbox se a nova folga for HOJE
    const hojeString = getDiaSemanaString();
    // Normaliza para compara√ß√£o segura
    const novoDiaNorm = novoDia.toLowerCase().replace(/-feira$/, "").normalize('NFD').replace(/[\u0300-\u036f]/g, "");
    const hojeStringNorm = hojeString.toLowerCase().replace(/-feira$/, "").normalize('NFD').replace(/[\u0300-\u036f]/g, "");

    if (novoDiaNorm === hojeStringNorm) {
      console.log(`A nova folga (${novoDia}) √© hoje! Verificando se a checkbox precisa ser marcada...`);
      const checkbox = document.getElementById(currentUser);
      if (checkbox && !checkbox.checked) {
        const membro = todosMembros.find(m => m.nome === currentUser);
        if (membro) {
          await marcarFolgaAutomatica(membro);
          // --- CORRE√á√ÉO AQUI: Adicionado 'window.' ---
          window.mostrarPopup("üå¥ Folga Imediata!", "Como sua nova folga √© hoje, j√° marcamos seu foco para voc√™. Bom descanso!", 6000);
        }
      }
    }

  } catch (error) {
    console.error("Erro ao atualizar folga:", error);
    // --- CORRE√á√ÉO AQUI: Adicionado 'window.' ---
    window.mostrarPopup("‚ùå Erro", "Falha ao salvar sua nova folga.", 3000);
  }
}
  
  function atualizarRelogio() {
    const agora = new Date();
    const horas = String(agora.getHours()).padStart(2, '0');
    const minutos = String(agora.getMinutes()).padStart(2, '0');
    const segundos = String(agora.getSeconds()).padStart(2, '0');
    document.getElementById('relogio').textContent = `${horas}:${minutos}:${segundos}`;
  }
  
  // NOVA FUN√á√ÉO: Para tocar sons de forma segura
  function tocarSom(id) {
    try {
      const som = document.getElementById(id);
      if (som) {
        som.currentTime = 0; // Reinicia o som caso ele j√° esteja tocando
        som.play();
      }
    } catch (error) {
      console.warn(`N√£o foi poss√≠vel tocar o som "${id}":`, error);
    }
  }

  // === SISTEMA DE AUTENTICA√á√ÉO CORRIGIDO ===
  async function handleLogin() {
    let username = loginUsernameInput.value.trim();
    if (username) {
        // Formata o nome: Primeira letra mai√∫scula, resto min√∫sculo.
        username = username.charAt(0).toUpperCase() + username.slice(1).toLowerCase();
    }
    const password = loginPasswordInput.value;

    if (!username || !password) {
      mostrarPopup("‚ùå Erro", "Por favor, preencha todos os campos", 3000);
      return;
    }

    // Feedback visual imediato
    loginBtn.textContent = "Entrando...";
    loginBtn.disabled = true;

    try {
      const userDoc = await getDoc(doc(db, "membros", username));

      if (userDoc.exists()) {
        const userData = userDoc.data();

        // Cen√°rio 1: Login com SENHA DEFINITIVA
        if (userData.senha === password && userData.usedProv === 'on') {
        
        // =======================================================
        // ===== BLOCO DE PROTE√á√ÉO: VERIFICA√á√ÉO SEGURA =====
        // =======================================================
        try {
            // Carrega o status dos poderes
            const statusRef = collection(db, "statusPoderes");
            // Verifica se o query est√° funcionando corretamente
            if (typeof query === 'function') {
                const qStatus = query(statusRef, where("expiraEm", ">", new Date()));
                const statusSnap = await getDocs(qStatus);
                
                statusPoderesAtivos = [];
                statusSnap.forEach(doc => {
                    statusPoderesAtivos.push({ id: doc.id, ...doc.data() });
                });

                const estaBloqueado = statusPoderesAtivos.find(p => 
                    p.poderId === 'runa_soft_block' && 
                    p.equipeAlvo === userData.equipe &&
                    userData.papel !== 'lider' && 
                    userData.papel !== 'lider-equipe'
                );

                if (estaBloqueado) {
                    const dataExpiracao = estaBloqueado.expiraEm.toDate().toLocaleString('pt-BR', { day: '2-digit', month: '2-digit', hour: '2-digit', minute: '2-digit' });
                    mostrarPopup("üö´ Acesso Bloqueado", `Sua equipe est√° sob o efeito da "Runa do Soft Block" at√© ${dataExpiracao}.`, 8000);
                    
                    // Reseta o bot√£o e sai
                    loginBtn.textContent = "Entrar";
                    loginBtn.disabled = false;
                    return; 
                }
            }
        } catch (errPoderes) {
            console.warn("Erro ao verificar bloqueios (Soft Block). Permitindo login por seguran√ßa.", errPoderes);
            // Em caso de erro na verifica√ß√£o do poder, permitimos o login para n√£o travar o usu√°rio
        }
        // =======================================================
        // ===== FIM DO BLOCO =====
        // =======================================================
        
          localStorage.setItem('loggedInUser', username);
          await performSuccessfulLogin(username);

        // Cen√°rio 2: Login com SENHA PROVIS√ìRIA
        } else if (userData.senhaProv === password && userData.usedProv === 'off') {
          currentUser = username;
          mostrarPopup("üîë Primeiro Acesso", "Crie sua senha definitiva para continuar.", 4000);
          showChangePasswordForm();

        // Cen√°rio 3: Senha incorreta
        } else {
          mostrarPopup("‚ùå Erro de Acesso", "Nome ou senha incorreta.", 3000);
        }

      } else {
        mostrarPopup("‚ùå Erro", "Usu√°rio n√£o encontrado", 3000);
      }
    } catch (error) {
      console.error("Erro no login:", error);
      mostrarPopup("‚ùå Erro", "Falha de conex√£o: " + error.message, 5000);
    } finally {
        // Sempre restaura o bot√£o, deu certo ou errado
        if (loginBtn) {
            loginBtn.textContent = "Entrar";
            loginBtn.disabled = false;
        }
    }
  }
  
// ========================================================================
// IN√çCIO DO BLOCO DE C√ìDIGO CORRIGIDO - COLE ISTO NO LUGAR DAS FUN√á√ïES ANTIGAS
// ========================================================================

// SUBSTITUA A SUA FUN√á√ÉO ANTIGA POR ESTA
async function carregarDadosEssenciais() {
  console.log("Otimiza√ß√£o: Carregando todos os dados essenciais (incluindo medalhas) de uma s√≥ vez..."); // Mensagem atualizada

  const querySnapshot = await getDocs(collection(db, "membros"));

  // Resetar estruturas (incluindo caches de medalhas)
  todosMembros = [];
  equipes = {
    abelha: { membros: [], lider: null },
    joaninha: { membros: [], lider: null },
    vagalume: { membros: [], lider: null }
  };
  liderGeral = null;
  streaksCache = {};
  medalhasInventarioCache = {}; // <<< NOVO: Resetar cache
  medalhasOrdemCache = {};     // <<< NOVO: Resetar cache
  // O cache 'medalhasDesejadasCache' ser√° populado em 'carregarDadosMedalhasHonra'

  querySnapshot.forEach(doc => {
    const data = doc.data();
    const membroId = doc.id; // <<< NOVO: Guarda o ID para usar nos caches

    // Normaliza√ß√£o dos dados de aus√™ncia
    let estaAusente = data.deFerias || false;
    let motivo = data.motivoAusencia || (estaAusente ? 'ferias' : null);

    const membro = {
      nome: membroId,
      deFerias: estaAusente, // Mantemos true para travar o foco
      motivoAusencia: motivo, // 'ferias', 'saude' ou null
      ...data 
    };

    todosMembros.push(membro);
    streaksCache[membro.nome] = membro.streak || 0;

    // L√≥gica existente para pap√©is e equipes...
    if (membro.papel === "lider") {
      liderGeral = membro;
    } else if (membro.papel === "lider-equipe") {
      if (equipes[membro.equipe]) {
        equipes[membro.equipe].lider = membro;
      }
    }
    if (membro.equipe && equipes[membro.equipe]) {
      equipes[membro.equipe].membros.push(membro);
    }

    // <<< IN√çCIO DO BLOCO ADICIONADO: Coleta dados das medalhas >>>
    medalhasInventarioCache[membroId] = data.medalhasInventario || [];
    medalhasOrdemCache[membroId] = data.medalhasOrdem || [];
    // <<< FIM DO BLOCO ADICIONADO >>>
  });
  console.log(`Dados essenciais (incluindo medalhas) de ${todosMembros.length} membros carregados com apenas 1 leitura da cole√ß√£o.`); // Mensagem atualizada
}

// SUBSTITUA A FUN√á√ÉO ANTIGA POR ESTA VERS√ÉO COMPLETA E BLINDADA
async function verificarConquista(nome, acao, equipeDoMembro, isDomingo) {
    const hojeISO = getHojeISO();
    
    const membroRef = doc(db, "membros", nome);
    const presencaRef = doc(db, "presencas", hojeISO);
    const pontosSemanaisRef = doc(db, "semanas", "pontosSemanais");

    try {
        // Usamos uma transa√ß√£o para garantir que todas as opera√ß√µes sejam at√¥micas.
        const { streakAtual, novosPontosEquipe } = await runTransaction(db, async (transaction) => {
            const valorIncremento = acao === 'adicionar' ? 1 : -1;

            // 1. LEITURAS OBRIGAT√ìRIAS (Tudo deve ser lido antes de escrever)
            const membroSnap = await transaction.get(membroRef);
            const presencaSnap = await transaction.get(presencaRef); // <--- A chave da blindagem
            
            let pontosSnap;
            if (!isDomingo && equipeDoMembro) {
                pontosSnap = await transaction.get(pontosSemanaisRef);
            }

            if (!membroSnap.exists()) {
                throw "Documento do membro n√£o encontrado.";
            }

            // 2. C√ÅLCULOS
            const streakAntes = membroSnap.data().streak || 0;
            const novoStreak = streakAntes + valorIncremento;

            // 3. ESCRITAS BLINDADAS
            
            // A) Atualiza√ß√£o do Membro
            const recompensaFoco = recompensasConfig.focoDiario || 100;
            transaction.update(membroRef, { 
              streak: novoStreak,
              moedas: increment(valorIncremento * recompensaFoco) 
            });

            // B) Atualiza√ß√£o da Presen√ßa (L√≥gica Anti-Sobrescrita)
            if (acao === 'adicionar') {
                if (presencaSnap.exists()) {
                    // Se J√Å EXISTE, usamos update. Isso impede que apague os dados dos outros.
                    transaction.update(presencaRef, { [nome]: new Date() });
                } else {
                    // Se N√ÉO EXISTE, usamos set com merge.
                    transaction.set(presencaRef, { [nome]: new Date() }, { merge: true });
                }
            } else {
                // Para remover, s√≥ tentamos se o documento existir
                if (presencaSnap.exists()) {
                    transaction.update(presencaRef, { [nome]: deleteField() });
                }
            }
            
            // C) Atualiza√ß√£o dos Pontos da Equipe
            let pontosFinaisEquipe = 0;
            if (!isDomingo && equipeDoMembro && pontosSemanais.hasOwnProperty(equipeDoMembro)) {
                // Incremento at√¥mico no banco
                transaction.update(pontosSemanaisRef, { [equipeDoMembro]: increment(valorIncremento) });
                
                // C√°lculo para retorno visual
                const pontosAtuais = pontosSnap && pontosSnap.exists() ? (pontosSnap.data()[equipeDoMembro] || 0) : 0;
                pontosFinaisEquipe = pontosAtuais + valorIncremento;
            }
            
            // 3. RETORNO
            return { streakAtual: novoStreak, novosPontosEquipe: pontosFinaisEquipe };
        });

        // --- AQUI COME√áA A SUA L√ìGICA VISUAL ORIGINAL (MANTIDA INTACTA) ---
        // Tudo que acontece ap√≥s o sucesso da transa√ß√£o no banco

        return { streakAtual: streakAtual, novosPontosEquipe: novosPontosEquipe };

    } catch (error) {
        console.error("FALHA NA TRANSA√á√ÉO AT√îMICA:", error);
        mostrarPopup("‚ùå Erro de Sincroniza√ß√£o", "Sua a√ß√£o n√£o p√¥de ser salva devido a um conflito. Tente novamente.", 5000);
        throw error; // Propaga o erro para a fun√ß√£o 'marcarCheckbox' reverter o visual
    }
}

// 4. (FUN√á√ÉO SUBSTITU√çDA) - Vers√£o otimizada que usa o cache.
async function carregarStreaks() {
  todosMembros.forEach(membro => {
    if (streaksCache[membro.nome] !== undefined) {
      atualizarStreakVisualMembro(membro.nome, streaksCache[membro.nome]);
    }
  });
  atualizarMedalhas();
}

// =======================================================
// NOVA FUN√á√ÉO: Verifica√ß√£o de atualiza√ß√£o bloqueante (PASSO 1)
// =======================================================
async function verificarSePrecisaAtualizarImediatamente() {
  try {
    const statusRef = doc(db, "appState", "status");
    const docSnap = await getDoc(statusRef);
    
    if (docSnap.exists()) {
      const data = docSnap.data();
      if (data.requiredUpdateVersion) {
        // Atualiza a vari√°vel global para que o bot√£o de atualizar funcione
        officialAppVersion = data.requiredUpdateVersion.toDate();
        
        const localVersionStr = localStorage.getItem('currentAppVersion');
        const localVersion = localVersionStr ? new Date(localVersionStr) : new Date(0);

        if (officialAppVersion > localVersion) {
          console.log("Atualiza√ß√£o obrigat√≥ria detectada no in√≠cio. Bloqueando carregamento.");
          
          // Garante que a tela de login suma
          if(authContainer) authContainer.classList.add('hidden');
          
          // Mostra o overlay de atualiza√ß√£o
          showUpdateOverlay();
          
          // Retorna true para indicar que o app deve PARAR de carregar
          return true; 
        }
      }
    }
  } catch (error) {
    console.error("Erro ao verificar vers√£o inicial:", error);
  }
  return false; // N√£o precisa atualizar, pode continuar
}

async function performSuccessfulLogin(username, isFirstLogin = false, isAdminBypass = false) {

  // --- 1. APLICA AS CORES DO TEMA IMEDIATAMENTE ---
  const hora = new Date().getHours();
  const body = document.body;
  body.classList.remove("tema-manha", "tema-tarde", "tema-noite");
  
  if (hora >= 5 && hora < 12) {
      body.classList.add("tema-manha");
  } else if (hora >= 12 && hora < 18) {
      body.classList.add("tema-tarde");
  } else {
      body.classList.add("tema-noite");
  }
  // ------------------------------------------------

  // 2. NOVA CHECAGEM DE ATUALIZA√á√ÉO (BLOQUEANTE)
  const precisaAtualizar = await verificarSePrecisaAtualizarImediatamente();
  if (precisaAtualizar) {
    return; 
  }
  
  showLoadingOverlay("Sincronizando rel√≥gio..."); 
  await sincronizarHorarioBrasilia();
  hideLoadingOverlay();
  
  isTestModeActive = false;
  dataAtual = getHojeISO();
  
  await carregarDadosEssenciais();
  
  // LIMPEZA DE BLOQUEIOS ANTIGOS (N√£o custa leitura extra pois usa update)
  limparBloqueiosAntigosUsuario();
  
  // CORRE√á√ÉO: Carrega as configura√ß√µes de recompensa ANTES de qualquer verifica√ß√£o de pagamento
  await carregarConfiguracoesRecompensas(); 

  const userDoc = await getDoc(doc(db, "membros", username));
  if (!userDoc.exists()) {
    localStorage.removeItem('loggedInUser');
    location.reload();
    return;
  }
  const userData = userDoc.data();

  // =======================================================
  // ===== VERIFICA√á√ÉO DE SOFT BLOCK (COM BYPASS DE ADMIN E POPUP) =====
  // =======================================================
  // S√≥ verifica se N√ÉO for um acesso for√ßado de Admin
  if (!isAdminBypass) { 
      try {
          const statusRef = collection(db, "statusPoderes");
          const qStatus = query(statusRef, where("expiraEm", ">", new Date()));
          const statusSnap = await getDocs(qStatus);
          
          const activePowers = [];
          statusSnap.forEach(doc => activePowers.push(doc.data()));

          const softBlockAtivo = activePowers.find(p => 
              p.poderId === 'runa_soft_block' && 
              p.equipeAlvo === userData.equipe &&
              userData.papel !== 'lider' && 
              userData.papel !== 'lider-equipe'
          );

          if (softBlockAtivo) {
              const dataExpiracao = softBlockAtivo.expiraEm.toDate().toLocaleString('pt-BR', { day: '2-digit', month: '2-digit', hour: '2-digit', minute: '2-digit' });
              
              console.log(`BLOQUEIO ATIVO: Usu√°rio ${username} impedido.`);
              
              // 1. Remove o login autom√°tico
              localStorage.removeItem('loggedInUser');
              
              // 2. Reseta a interface para o estado de "Logout" para mostrar o popup sobre a tela de login
              if (authContainer) authContainer.classList.remove('hidden');
              if (mainContent) mainContent.classList.add('hidden');
              if (loginBtn) { loginBtn.textContent = "Entrar"; loginBtn.disabled = false; }
              hideLoadingOverlay(); // Garante que o loading suma
              
              // 3. Exibe o Popup do Site (Bonito e agora com COR!)
              setTimeout(() => {
                  mostrarPopup("üö´ Acesso Bloqueado", `Sua equipe est√° sob o efeito da <strong>Runa do Soft Block</strong>.<br><br>O acesso est√° impedido at√©:<br><strong>${dataExpiracao}</strong>`, 8000);
              }, 100);
              
              return; // Encerra a fun√ß√£o aqui, impedindo o login
          }
      } catch (errBlock) {
          console.error("Erro ao verificar Soft Block:", errBlock);
      }
  } else {
      console.log("üîê Admin Bypass: Ignorando verifica√ß√£o de Soft Block.");
  }
  // =======================================================
  // ===== FIM DA VERIFICA√á√ÉO =====
  // =======================================================

  await verificarEAtualizarAvatar(userData);

  currentUser = username;
  userRole = userData.papel;
  userTeam = userData.equipe;

  const isManutencaoAtiva = await verificarEstadoManutencaoInicial();
  if (isManutencaoAtiva && userRole !== 'lider') {
    console.log(`Modo de manuten√ß√£o ATIVO. Bloqueando acesso para o usu√°rio: ${username}`);
    document.getElementById('maintenance-overlay').classList.remove('hidden');
    document.body.style.overflow = 'hidden';
    return;
  }

  authContainer.classList.add('hidden');
  mainContent.classList.remove('hidden');

  construirInterface();
  await carregarDadosAvatar();
  iniciarCalendario();
  atualizarPainelPessoal();
  configurarOuvintePresencaTempoReal();
  
  await carregarRecompensaDiaria();
  inicializarEstadoProtecao();
  
  await carregarPontosSemanais(); 
  await verificarEConcederPremiacaoDiaria();
  // Atrasamos o Or√°culo em 12 segundos para garantir que a interface carregue suavemente primeiro
  setTimeout(() => {
      console.log("Iniciando verifica√ß√µes do Or√°culo em segundo plano...");
      gerenciarEventosAgendadosDoOraculo(); 
  }, 12000); 
  await executarMarcacaoAutomaticaDeFolgasDoDia();
  await marcarFolgaColetivaDeDomingo();
  
  await processarFeriadoDoDia();

  await Promise.all([
      carregarRankingGeral(),
      carregarArvoreEpica(),
      carregarStreaks(),
	  carregarEExibirAvaliacoesDesenho(),
	  loadAdvantageState()
  ]);
  
  configurarOuvintesDePreviewDesenho();

  const equipesDesenho = ['abelha', 'joaninha', 'vagalume'];
  equipesDesenho.forEach(equipe => {
      const previewContainer = document.getElementById(`preview-container-${equipe}`);
      if (previewContainer) {
        previewContainer.onclick = () => abrirModalDesenho(equipe);
      }
  });

  const indicadoresContainer = document.getElementById('carrossel-indicadores-desenho');
  if (indicadoresContainer) {
    indicadoresContainer.innerHTML = '';
    for (let i = 0; i < 3; i++) {
        const indicador = document.createElement('div');
        indicador.className = 'carrossel-indicador';
        indicador.onclick = () => { irParaSlideDesenho(i); };
        indicadoresContainer.appendChild(indicador);
    }
  }
  iniciarCarrosselDesenho();
  document.querySelector('#carrossel-indicadores-desenho .carrossel-indicador')?.classList.add('ativo');
  irParaSlideDesenho(0);
  
  if (isFirstLogin) {
    setTimeout(() => {
      // L√≥gica de g√™nero para o popup de boas-vindas
      let textoTitulo = `üéâ Seja muito bem-vindo(a), ${username}!`;
      if (userData.genero === 'masculino') {
          textoTitulo = `üéâ Seja muito bem-vindo, ${username}!`;
      } else if (userData.genero === 'feminino') {
          textoTitulo = `üéâ Seja muito bem-vinda, ${username}!`;
      }

      const mensagem = `
        <p>√â uma alegria ter voc√™ no Grupo √âpicos!</p>
        <p>Voc√™ acaba de entrar para o nosso grupo de foco. Aqui, acreditamos que o verdadeiro progresso √© constru√≠do um dia de cada vez, com determina√ß√£o e apoio m√∫tuo.</p>
        <p>Sinta-se em casa para navegar, interagir e encontrar seu pr√≥prio ritmo. Lembre-se: <strong>cada pequeno passo √© uma grande vit√≥ria em sua jornada.</strong></p>
        <p>Estamos muito felizes em ter voc√™ conosco. Vamos juntos construir uma jornada √âpica!</p>
      `;
      mostrarCardPopup(textoTitulo, mensagem, dispararConfete);
    }, 2000);
  } else {
      // Adapta√ß√£o para o popup de "Ol√° de novo" (opcional, mas recomendado)
      let msgRetorno = 'Bem-vindo(a) de volta!';
      if (userData.genero === 'masculino') msgRetorno = 'Bem-vindo de volta!';
      if (userData.genero === 'feminino') msgRetorno = 'Bem-vinda de volta!';
      
      setTimeout(() => {
        mostrarPopup(`‚úÖ ${msgRetorno}`, `Ol√°, ${username}! √â bom ver voc√™ aqui.`, 4000);
      }, 1500); 
  }

  await verificarELimparNaSegunda();
  atualizarPlacarSemanal();
  atualizarRankingGeral();
  atualizarDataCabecalho();
  atualizarInfoSemana();
  configurarMuralTempoReal();
  createColorPalette();
  configurarResumoSemanalTempoReal();
  await finalizarSemana();

  await Promise.all([
      carregarTop5Semana(),
      exibirQuadroFolgas(),
      carregarInformacoesMembros(),
      carregarAniversariantes(),
      carregarCondominioEpicos(),
	  carregarHallDaFama(),
	  carregarTemaDesenho()
  ]);

  atualizarVisualBloqueio();
  await carregarEExibirMembrosOciosos();
  await carregarDadosMedalhasHonra();
  
  await executarResetDeTemporada();
  
  await carregarDadosLoteria();
  
  // Tenta executar o sorteio se for Quarta e ainda n√£o tiver rolado (Recupera√ß√£o de Falha)
  await executarSorteioLoteria();   

  setTimeout(() => {
    iniciarCarrosselAutomatico();
    irParaSlide(0);
  }, 1000); 

  setupRefreshListener(); 
  setupVersionCheckListener();
  configurarNotificacoesTempoReal();
  await verificarEExibirPopupNovaMedalha(); // Notifica√ß√µes priorit√°rias (Medalhas ganhas)
  await carregarBancosEquipes();
  
  inicializarLojaPoderes();
  await carregarStatusPoderes(); // Carrega dados da loja sem exibir popup ainda
  
  await atualizarResumo();
  
  // === ORDEM DE POPUPS SOLICITADA (1 a 9) ===
  
  // 1. Boas-vindas (J√° √© tratado pelo if(isFirstLogin) no in√≠cio da fun√ß√£o, mantido l√°)
  
  // 2. Mensagem do Dia do Or√°culo (Com confete)
  await verificarEMostrarMensagemDoDia();
  
  // 2.1. Envio de Moedas Di√°rias (PRIORIDADE ALTA)
  // Verifica se precisa enviar moedas e aguarda a fila liberar
  await verificarPopupEnvioDiario();
  
  //2.1.1 Popup de ano novo   
   await verificarPopupFimDeTemporada();
  
  // 3. Anivers√°rio
  await verificarAniversariantesDoDia();

  // 4. Resultado detalhado da competi√ß√£o (Fecha e abre o 5. An√°lise do Or√°culo automaticamente)
  await exibirPopupResultadoCompeticao();
  
  // 5. A An√°lise do Or√°culo √© chamada automaticamente ao fechar o Resultado da Competi√ß√£o (L√≥gica j√° existente no bot√£o fechar)

  // 6. Folgas e V√©speras (Sem confete)
  await verificarEProcessarFolgaDoDiaAtual();
  await verificarPopupDeFolga();
  
    // NOVO: Verifica resultado do desenho (Popup + Caixas na tela)
  await verificarUltimoResultadoDesenho();

  // 7. Resultado do sorteio da loteria
  await verificarPopupResultadoLoteria();
  await verificarPopupVesperaSorteio();

  // 8. Efeitos das magias da lojinha de magias
  exibirPopupPoderesAtivos();

  // Outros popups utilit√°rios
  await verificarPopupRecompensas();
  
  // --- POPUPS DE DESENHO ---
  const diaSemanaLogin = getHoje().getDay();
  
  // Segunda-feira: Aviso de Fim
  if (diaSemanaLogin === 1) {
      mostrarCardPopup(
          "üé® √öltimo Dia para Desenhar!",
          "A Batalha de Desenhos encerra hoje √†s 23:59. Certifique-se de que sua equipe finalizou a obra de arte!",
          null, "Grupo √âpicos", "aviso_fim_desenho"
      );
  }
  
  // Quinta-feira: Novo Tema (busca do status global)
  if (diaSemanaLogin === 4) {
      const statusGlobal = await getDoc(doc(db, "appState", "status"));
      if (statusGlobal.exists() && statusGlobal.data().avisoNovoTema) {
          const dadosTema = statusGlobal.data().avisoNovoTema;
          // Verifica se √© de hoje
          if (dadosTema.data === getHojeISO()) {
              mostrarCardPopup(
                  "üé® Novo Tema Liberado!", 
                  `O tema da semana √©: <strong>${dadosTema.tema}</strong>.<br>Corram para as telas de desenho!`,
                  null, "Or√°culo", "aviso_novo_tema_" + dadosTema.data
              );
          }
      }
  }
  
  // Ter√ßa-feira: Resultado (Busca se houve resultado recente)
  if (diaSemanaLogin === 2) {
      // (Opcional: Verificar no banco se o usu√°rio j√° viu o resultado espec√≠fico)
      // A fun√ß√£o executarJulgamentoDesenhos j√° mostra o popup para quem est√° online no momento.
      // Para quem logar depois, voc√™ pode adicionar uma verifica√ß√£o similar √† da Loteria.
  }

  // Inicializa√ß√µes finais de interface
  inicializarMapa();
  await destacarVencedoraDomingo();
  
  if (historicoConversaIA.length === 0 && baseDeConhecimentoTexto !== '') {
    const saudacaoInicial = `Ol√°, ${currentUser}! Sou o Or√°culo dos √âpicos. Posso te ajudar em algo?`;
    adicionarMensagemIA(saudacaoInicial);
  }
  
  // Verifica√ß√£o final de notifica√ß√µes restantes
  setTimeout(async () => {
    // REMOVIDO: await verificarNotificacoesRestantes();
    console.log("Verifica√ß√£o autom√°tica de notifica√ß√µes no login desativada.");
  }, 3500);
}

async function verificarPopupDeFolga() {
    if (!currentUser) return;

    // Trava de sess√£o removida

    const membroAtual = todosMembros.find(m => m.nome === currentUser);
    if (!membroAtual) return;
    
    const amanha = new Date();
    amanha.setDate(amanha.getDate() + 1);
    
    // --- IN√çCIO DA L√ìGICA DA V√âSPERA DE ANIVERS√ÅRIO ---
    if (membroAtual.aniversario) {
        const [diaAniversario, mesAniversario] = membroAtual.aniversario.split('/').map(Number);
        if (amanha.getDate() === diaAniversario && (amanha.getMonth() + 1) === mesAniversario) {
            const mensagem = `Falta pouco para o seu dia especial! Estamos muito ansiosos para comemorar o seu anivers√°rio amanh√£ com voc√™!!`;
            // ADICIONADO: ID √∫nico "vespera_aniversario"
            mostrarCardPopup('üéâ Seu Anivers√°rio est√° Chegando!', mensagem, null, "Grupo √âpicos", "vespera_aniversario");
            sessionStorage.setItem('popupVesperaMostradoHoje', 'true');
            return; // Encerra a fun√ß√£o para n√£o mostrar o popup de folga tamb√©m
        }
    }
    // --- FIM DA L√ìGICA DA V√âSPERA DE ANIVERS√ÅRIO ---

    // --- L√ìGICA DA V√âSPERA DE FOLGA (sem altera√ß√µes) ---
    if (membroAtual.folga) {
        const diaAmanhaNormalizado = getDiaSemanaString(amanha).toLowerCase().replace(/-feira$/, "").normalize('NFD').replace(/[\u0300-\u036f]/g, "");
        const folgaMembroNormalizada = membroAtual.folga.toLowerCase().replace(/-feira$/, "").normalize('NFD').replace(/[\u0300-\u036f]/g, "");

        if (folgaMembroNormalizada === diaAmanhaNormalizado) {
            const mensagem = `Lembrete amig√°vel: amanh√£ √© o seu dia de folga programado. Aproveite para recarregar as energias!`;
            // ID √öNICO ADICIONADO: 'aviso_vespera_folga'
            mostrarCardPopup('üå¥ Seu Descanso se Aproxima!', mensagem, null, "Grupo √âpicos", "aviso_vespera_folga");
            return; 
        }
    }
    
    if (getHoje().getDay() === 6) { // Se hoje for s√°bado
         const mensagem = `Aproveite o s√°bado! Lembre-se que amanh√£ √© nossa folga coletiva. Um √≥timo descanso para todos n√≥s!`;
         // ID √öNICO ADICIONADO: 'aviso_sabado'
         mostrarCardPopup('üéâ Fim de Semana Chegou!', mensagem, null, "Grupo √âpicos", "aviso_sabado");
    }
}

function handleLogout() {
  // Desliga os ouvintes de desenho
  desligarTodosOsOuvintesDeDesenho();
  
  // NOVO: Desliga o ouvinte de notifica√ß√µes ANTES de limpar o resto
  if (unsubscribeNotificacoes) {
    unsubscribeNotificacoes();
    unsubscribeNotificacoes = null;
    console.log("Ouvinte de notifica√ß√µes desligado com sucesso no logout.");
  }

  // O resto da sua fun√ß√£o de logout continua o mesmo
  closeModal('user-panel-modal');
  localStorage.removeItem('loggedInUser');
  sessionStorage.removeItem('avatarPermissionsChecked');
  
  currentUser = null;
  userRole = null;
  userTeam = null;

  authContainer.classList.remove('hidden');
  mainContent.classList.add('hidden');

  loginUsernameInput.value = '';
  loginPasswordInput.value = '';

  showLoginForm();

  mostrarPopup("‚ÑπÔ∏è Sess√£o encerrada", "Voc√™ saiu do sistema", 3000);
}

  function showChangePasswordForm() {
    loginForm.classList.add('hidden');
    changePasswordForm.classList.remove('hidden');
  }

  function showLoginForm() {
  changePasswordForm.classList.add('hidden');
  forgotPasswordForm.classList.add('hidden');
  secretQuestionForm.classList.add('hidden'); // Adicione esta linha tamb√©m
  loginForm.classList.remove('hidden');
}

  async function handlePasswordChange() {
  const newPassword = document.getElementById('new-password').value;
  const confirmPassword = document.getElementById('confirm-new-password').value;

  if (!newPassword || !confirmPassword) {
    mostrarPopup("‚ùå Erro", "Preencha todos os campos", 3000);
    return;
  }
  if (newPassword !== confirmPassword) {
    mostrarPopup("‚ùå Erro", "As novas senhas n√£o coincidem", 3000);
    return;
  }
  if (newPassword.length < 6) {
    mostrarPopup("‚ùå Erro", "A senha deve ter no m√≠nimo 6 caracteres.", 3000);
    return;
  }

  try {
    const userDocRef = doc(db, "membros", currentUser);
    await updateDoc(userDocRef, { senha: newPassword });

    if (isPasswordResetFlow) {
      // Se for recupera√ß√£o de senha, loga direto
      isPasswordResetFlow = false; // Reseta a vari√°vel
      mostrarPopup("‚úÖ Sucesso!", "Sua senha foi redefinida. Carregando o app...", 4000);
      await performSuccessfulLogin(currentUser, false); // false = n√£o √© o primeiro login
    } else {
      // Se for o primeiro login, continua o fluxo normal
      mostrarPopup("‚úÖ Senha Criada", "Agora, vamos configurar sua recupera√ß√£o de login.", 5000);
      showSecretQuestionForm();
    }

  } catch (error) {
    console.error("Erro ao alterar senha:", error);
    mostrarPopup("‚ùå Erro", "Falha ao alterar senha. Tente novamente.", 3000);
  }
}

function initAuth() {
    authContainer = document.getElementById("auth-container");
    mainContent = document.getElementById("main-content");
    logoutBtn = document.getElementById("logout-btn");
    loginForm = document.getElementById("login-form");
    changePasswordForm = document.getElementById("change-password-form");
	let userMenuDropdown = document.getElementById('user-menu-dropdown');

    // --- Listeners de Men√ß√£o (sem altera√ß√£o) ---
    const composerTextarea = document.getElementById('composer-textarea');
    composerTextarea.addEventListener('paste', function(e) {
        e.preventDefault();
        let text = (e.clipboardData || window.clipboardData).getData('text/plain');
        const html = text.replace(/\r\n|\r|\n/g, '<br>');
        document.execCommand('insertHTML', false, html);
    });
    composerTextarea.addEventListener('input', handleComposerInput);
    composerTextarea.addEventListener('keydown', handleMentionKeyDown);
    const commentTextarea = document.getElementById('comment-textarea-modal');
    commentTextarea.addEventListener('input', handleComposerInput);
    commentTextarea.addEventListener('keydown', handleMentionKeyDown);
    // --- Fim dos Listeners de Men√ß√£o ---

    loginBtn = document.getElementById("login-btn");
    loginUsernameInput = document.getElementById("login-username");
    loginPasswordInput = document.getElementById("login-password");
	forgotPasswordForm = document.getElementById("forgot-password-form");
	secretQuestionForm = document.getElementById("secret-question-form");
	
	if (loginBtn) loginBtn.addEventListener("click", handleLogin);
	
	const togglePasswordBtn = document.getElementById('toggle-password-btn');

    if (loginPasswordInput && togglePasswordBtn) {
      loginPasswordInput.addEventListener('input', () => {
        togglePasswordBtn.style.display = loginPasswordInput.value.length > 0 ? 'block' : 'none';
      });
      togglePasswordBtn.addEventListener('click', () => {
        const isPassword = loginPasswordInput.type === 'password';
        loginPasswordInput.type = isPassword ? 'text' : 'password';
        togglePasswordBtn.textContent = isPassword ? 'Ocultar' : 'Ver';
      });
    }

    if (loginBtn) {
      loginBtn.addEventListener("click", handleLogin);
    }
    
    if (logoutBtn) {
      logoutBtn.addEventListener("click", handleLogout);
    }
    
    if (loginPasswordInput) {
      loginPasswordInput.addEventListener("keypress", (e) => {
        if (e.key === "Enter") handleLogin();
      });
    }
	
	const categoriaSelect = document.getElementById('add-item-categoria');
    if (categoriaSelect) {
      categoriaSelect.addEventListener('change', () => {
        const subcategoriaContainer = document.getElementById('add-item-subcategoria-container');
        subcategoriaContainer.classList.toggle('hidden', categoriaSelect.value !== 'acessorio');
      });
    }

    document.getElementById('confirm-remove-button')?.addEventListener('click', executeRemoveMember);
    document.getElementById('force-refresh-btn')?.addEventListener('click', requestGlobalRefresh);
    document.getElementById('trigger-update-btn')?.addEventListener('click', triggerForcedUpdate);
    document.getElementById('perform-update-btn')?.addEventListener('click', performUpdate);
    
    // =======================================================
    // ===== IN√çCIO DA CORRE√á√ÉO (CLIQUE NO √çCONE) =====
    // =======================================================
    document.getElementById('notificacoes-btn')?.addEventListener('click', () => {
        // A√ß√£o de marcar como lido foi REMOVIDA daqui
        // marcarNotificacoesComoLidas();
        
        // Apenas abre o modal
        openModal('notificacoes-modal');
    });
    // =======================================================
    // ===== FIM DA CORRE√á√ÉO (CLIQUE NO √çCONE) =====
    // =======================================================


    // =======================================================
    // ===== IN√çCIO DA CORRE√á√ÉO (L√ìGICA DO BOT√ÉO FECHAR v2) =====
    // =======================================================
    const closeNotifBtn = document.getElementById('notificacoes-fechar-btn');
    if (closeNotifBtn) {
        let pressTimer = null;
        let longPressTriggered = false;

        const startPress = (e) => {
            // e.preventDefault(); // <-- ESTA LINHA FOI REMOVIDA
            longPressTriggered = false;
            pressTimer = setTimeout(() => {
                // A√á√ÉO SECRETA (LONG-PRESS)
                longPressTriggered = true;
                console.log("Modo Admin: Fechando modal sem limpar notifica√ß√µes.");
                
                // 1. Apenas fecha o modal
                closeModal('notificacoes-modal');
                
                // 2. (N√£o marca como lida e n√£o apaga)
                
                // 3. Feedback visual para o admin
                mostrarPopup("‚ôªÔ∏è Modo de Preserva√ß√£o", "Notifica√ß√µes preservadas como n√£o lidas.", 2000);

            }, 1500); // Segure por 1.5 segundos
        };

        const endPressOrCancel = () => {
            clearTimeout(pressTimer);
        };

        const clickHandler = (e) => {
            if (longPressTriggered) {
                // Se o long-press j√° foi disparado, impede o clique normal
                e.preventDefault();
                e.stopImmediatePropagation();
                longPressTriggered = false;
            } else {
                // A√á√ÉO NORMAL (CLIQUE CURTO)
                // Chama a nova fun√ß√£o que marca, apaga E fecha.
                acaoNormalFecharNotificacoes(); 
            }
        };

        // Eventos de Toque (Mobile) - RE-ADICIONADOS CORRETAMENTE
        closeNotifBtn.addEventListener('touchstart', startPress, { passive: true }); // Adicionado { passive: true } para evitar erros
        closeNotifBtn.addEventListener('touchend', endPressOrCancel);
        closeNotifBtn.addEventListener('touchmove', endPressOrCancel); // Cancela o timer se o dedo deslizar
        
        // Eventos de Mouse (Desktop) - Mantidos
        closeNotifBtn.addEventListener('mousedown', startPress);
        closeNotifBtn.addEventListener('mouseup', endPressOrCancel);
        closeNotifBtn.addEventListener('mouseleave', endPressOrCancel);

        // O evento de 'click' decide qual a√ß√£o tomar (Funciona no Desktop e Mobile)
        closeNotifBtn.addEventListener('click', clickHandler);
    }
    // =======================================================
    // ===== FIM DA CORRE√á√ÉO (L√ìGICA DO BOT√ÉO FECHAR v2) =====
    // =======================================================


    document.getElementById('btn-abrir-add-avatar-item')?.addEventListener('click', abrirModalAdicionarItemAvatar);
    document.getElementById('save-new-avatar-item-btn')?.addEventListener('click', salvarItemAvatar);
    document.getElementById('add-item-raro')?.addEventListener('change', (e) => {
        const descContainer = document.getElementById('add-item-raro-descricao-container');
        const membrosContainer = document.getElementById('add-item-membros-permitidos-container');
        const isChecked = e.target.checked;
        descContainer.classList.toggle('hidden', !isChecked);
        membrosContainer.classList.toggle('hidden', !isChecked);
        if (isChecked) popularListaMembrosPermissao();
    });

    // Eventos do Pix
    document.getElementById('pix-iniciar-btn')?.addEventListener('click', iniciarNovoPix);
    document.querySelectorAll('.pix-cancel-btn').forEach(btn => btn.addEventListener('click', () => navegarPix(0)));
    document.getElementById('pix-verificar-btn')?.addEventListener('click', verificarComprovantePix);
    document.getElementById('pix-salvar-comprovante-btn')?.addEventListener('click', salvarComprovantePix);
    document.getElementById('pix-nova-transferencia-btn')?.addEventListener('click', iniciarNovoPix);
    document.getElementById('pix-executar-btn')?.addEventListener('click', executarPix);
    document.getElementById('pix-step1-next')?.addEventListener('click', () => {
        const checkboxes = document.querySelectorAll('#pix-lista-membros input:checked');
        if (checkboxes.length === 0) return mostrarPopup("ü§î Aten√ß√£o", "Selecione pelo menos um membro.", 3000);
        pixDestinatarios = Array.from(checkboxes).map(cb => cb.value);

        // --- IN√çCIO DA L√ìGICA DO BANCO (PASSO 11 A) ---
        const fontePagamentoContainer = document.getElementById('pix-fonte-pagamento');
        const podeLiderar = userRole === 'lider' || userRole === 'lider-equipe';
        const membroAtual = todosMembros.find(m => m.nome === currentUser);
        const saldoPessoal = membroAtual ? membroAtual.moedas || 0 : 0;

        // Atualiza o saldo pessoal "Seu Saldo: X"
        document.querySelector('#pix-saldo-atual span').textContent = saldoPessoal.toLocaleString('pt-BR');

        if (podeLiderar && userTeam) {
            const saldoBanco = saldosBancosEquipes[userTeam] || 0;

            // Atualiza os labels das op√ß√µes de r√°dio
            document.getElementById('saldo-pessoal-pix').textContent = saldoPessoal.toLocaleString('pt-BR');
            document.getElementById('saldo-banco-pix').textContent = saldoBanco.toLocaleString('pt-BR');

            // Habilita/desabilita as op√ß√µes
            document.getElementById('fonte-pessoal-pix').disabled = false;
            document.getElementById('fonte-banco-pix').disabled = false;
            
            // Seleciona 'pessoal' por padr√£o
            document.getElementById('fonte-pessoal-pix').checked = true;

            fontePagamentoContainer.classList.remove('hidden');
        } else {
            fontePagamentoContainer.classList.add('hidden');
        }
        // --- FIM DA L√ìGICA DO BANCO ---

        // L√≥gica original (mantida)
        popularTecladoPix();
        document.getElementById('pix-valor-display').textContent = '0';
        navegarPix(2);
    });
    document.getElementById('pix-step2-next')?.addEventListener('click', () => {
        // --- IN√çCIO DA L√ìGICA DO BANCO (PASSO 11 B) ---
        const valor = parseInt(document.getElementById('pix-valor-display').textContent, 10);
        const fontePagamentoEl = document.querySelector('input[name="fonte-pagamento-pix"]:checked');
        const fontePagamento = (fontePagamentoEl && !fontePagamentoEl.disabled) ? fontePagamentoEl.value : 'pessoal';

        let saldoDisponivel = 0;
        if (fontePagamento === 'banco') {
            saldoDisponivel = saldosBancosEquipes[userTeam] || 0;
        } else {
            const membroAtual = todosMembros.find(m => m.nome === currentUser);
            saldoDisponivel = membroAtual ? membroAtual.moedas || 0 : 0;
        }
        
        if (valor < 1) {
            mostrarPopup("‚ùå Valor Inv√°lido", "O valor m√≠nimo para envio √© de 1 moeda.", 4000);
            return; // Impede de avan√ßar
        }
        if (valor * pixDestinatarios.length > saldoDisponivel) {
            mostrarPopup("üí∞ Saldo Insuficiente", "Voc√™ n√£o tem moedas suficientes nessa fonte de pagamento.", 4000);
            return; // Impede de avan√ßar
        }
        
        pixValor = valor;
        navegarPix(3); // Avan√ßa para o passo 3 (coment√°rio)
        // --- FIM DA L√ìGICA DO BANCO ---
    });
    document.getElementById('pix-step3-next')?.addEventListener('click', () => {
        pixComentario = document.getElementById('pix-comentario-input').value.trim();
        document.getElementById('pix-resumo-confirmacao').innerHTML = `<p><strong>Destinat√°rio(s):</strong> ${pixDestinatarios.join(', ')}</p><p><strong>Valor por pessoa:</strong> üí∞ ${pixValor}</p><p><strong>Valor Total:</strong> üí∞ ${pixValor * pixDestinatarios.length}</p><p><strong>Coment√°rio:</strong> ${pixComentario || 'Nenhum'}</p>`;
        navegarPix(4);
    });
    document.getElementById('pix-step4-next')?.addEventListener('click', () => {
        document.getElementById('pix-senha-input').value = '';
        navegarPix(5);
    });

    // Outros eventos
    document.getElementById('btn-abrir-envio-moedas')?.addEventListener('click', abrirModalEnvioMoedas);
    document.getElementById('enviar-moedas-btn')?.addEventListener('click', () => executarEnvioMoedas('envio-moedas-modal'));
    document.getElementById('enviar-moedas-popup-btn')?.addEventListener('click', () => executarEnvioMoedas('popup-envio-diario-moedas'));
    document.getElementById('toggle-maintenance-btn')?.addEventListener('click', toggleMaintenanceMode);
    document.getElementById('enviar-recompensa-equipe-btn')?.addEventListener('click', executarEnvioRecompensaEquipe);
    document.getElementById('enviar-recompensa-lideres-btn')?.addEventListener('click', executarEnvioRecompensaLideres);
    document.getElementById('limpar-feed-btn')?.addEventListener('click', limparFeedManualmente);
    document.getElementById('limpar-mural-btn')?.addEventListener('click', limparMuralManualmente);
    document.getElementById('btn-abrir-inventario')?.addEventListener('click', abrirInventario);
    document.getElementById('change-folga-btn')?.addEventListener('click', openChangeFolgaModal);
    document.getElementById('save-new-folga-btn')?.addEventListener('click', handleUpdateFolga);
    document.getElementById('btn-ver-lista-aniversarios')?.addEventListener('click', abrirModalListaAniversarios);
    document.getElementById('conta-gotas-btn')?.addEventListener('click', () => definirModoGlobal('conta-gotas'));
    document.getElementById('save-new-password-btn')?.addEventListener('click', handleUpdatePassword);
    document.getElementById('save-new-secret-btn')?.addEventListener('click', handleUpdateSecretAnswer);
    window.addEventListener('click', () => { if (userMenuDropdown && !userMenuDropdown.classList.contains('hidden')) userMenuDropdown.classList.add('hidden'); });

// Listeners da Loteria
document.getElementById('btn-fazer-aposta')?.addEventListener('click', abrirModalAposta);
document.getElementById('btn-confirmar-aposta')?.addEventListener('click', confirmarAposta);
document.getElementById('btn-minhas-apostas')?.addEventListener('click', verMinhasApostas); // NOVO LISTENER
document.getElementById('btn-ver-historico-apostas')?.addEventListener('click', verHistoricoApostas);
document.getElementById('btn-consultar-id-aposta')?.addEventListener('click', consultarApostaPorID);

document.getElementById('btn-decretar-feriado')?.addEventListener('click', handleDecretarFeriado);

    // Barra de Desenho
    document.getElementById('pincel-btn')?.addEventListener('click', () => definirModoGlobal('pincel'));
    document.getElementById('borracha-btn')?.addEventListener('click', () => definirModoGlobal('borracha'));
    document.getElementById('pan-btn')?.addEventListener('click', () => definirModoGlobal('arrastar'));
    document.getElementById('cor-pincel')?.addEventListener('input', e => { corPincel = e.target.value; definirModoGlobal('pincel'); });
    document.getElementById('tamanho-pincel')?.addEventListener('input', (e) => {
        tamanhoPincel = e.target.value;
        const tamanhoValorEl = document.getElementById('valor-pincel');
        if(tamanhoValorEl) tamanhoValorEl.textContent = e.target.value;
        atualizarCursorDinamico();
    });
    document.getElementById('limpar-tela-btn')?.addEventListener('click', () => { if (activeDrawingTeam) confirmarLimpezaDeTela(activeDrawingTeam); });
    const toolbar = document.getElementById('desenho-toolbar');
    const toggleBtn = document.getElementById('toggle-toolbar-btn');
    if (toolbar && toggleBtn && !toolbar.dataset.listener) {
        toggleBtn.addEventListener('click', () => toolbar.classList.toggle('recolhida'));
        toolbar.dataset.listener = 'true';
    }

    // Ajustes e Mural
    document.getElementById('btn-adicionar-pontos')?.addEventListener('click', () => handleAjusteManualPontos('adicionar'));
    document.getElementById('btn-remover-pontos')?.addEventListener('click', () => handleAjusteManualPontos('remover'));
    document.getElementById('open-composer-btn')?.addEventListener('click', () => openMessageComposer());
    document.getElementById('confirm-delete-btn')?.addEventListener('click', confirmDelete);
    document.getElementById('viewer-close-btn')?.addEventListener('click', () => closeModal('message-viewer-modal'));
    document.getElementById('composer-color-btn')?.addEventListener('click', (e) => {
      e.stopPropagation();
      const palette = document.getElementById('composer-color-palette');
      const isHidden = palette.classList.toggle('hidden');
      if (!isHidden) {
        const closePaletteOnClickOutside = (event) => {
          if (!palette.contains(event.target) && event.target !== e.target) {
            palette.classList.add('hidden');
            document.removeEventListener('click', closePaletteOnClickOutside);
          }
        };
        setTimeout(() => document.addEventListener('click', closePaletteOnClickOutside), 0);
      }
    });
    document.getElementById('composer-close-btn')?.addEventListener('click', closeMessageComposer);
    document.getElementById('composer-send-btn')?.addEventListener('click', enviarMensagem);

    // Coment√°rios
    document.getElementById('confirm-delete-comment-btn')?.addEventListener('click', executarExclusaoComentario);
    document.getElementById('save-edit-comment-btn')?.addEventListener('click', salvarEdicaoComentario);

    // Painel de Controle
    document.getElementById('botao-painel-usuario')?.addEventListener('click', () => openModal('user-panel-modal'));
    document.getElementById('generate-batch-code-btn')?.addEventListener('click', handleGenerateBatchCode);
    document.getElementById('add-member-btn')?.addEventListener('click', handleAddMember);
    document.getElementById('remove-member-btn')?.addEventListener('click', handleRemoveMember);
    document.getElementById('btn-abrir-gerador-codigo')?.addEventListener('click', abrirGeradorDeCodigos);
    document.getElementById('generate-code-btn')?.addEventListener('click', handleGenerateCode);
    document.getElementById('redeem-code-btn')?.addEventListener('click', handleRedeemCode);
    document.getElementById('save-game-order-btn')?.addEventListener('click', salvarNovaOrdemJogos);
    document.getElementById('btn-abrir-painel-controle')?.addEventListener('click', () => { openControlPanel(); closeModal('user-panel-modal'); });
    document.getElementById('btn-logout-panel')?.addEventListener('click', handleLogout);

    // Senha
    document.getElementById('change-password-btn')?.addEventListener('click', handlePasswordChange);
    document.getElementById('cancel-change-password')?.addEventListener('click', showLoginForm);
    document.getElementById('forgot-password-link')?.addEventListener('click', showForgotPasswordForm);
	document.getElementById('verify-answer-btn')?.addEventListener('click', handleVerifySecretAnswer);
    document.getElementById('cancel-forgot-password')?.addEventListener('click', showLoginForm);
	document.getElementById('save-secret-answer-btn')?.addEventListener('click', handleSaveSecretAnswer);
	
    // Loja e Condom√≠nio
    document.getElementById('btn-abrir-loja')?.addEventListener('click', abrirLoja);
	document.querySelector('.botao-info[onclick*="info-moedas-modal"]').addEventListener('click', popularModalRecompensas);
    document.getElementById('btn-ver-condominio')?.addEventListener('click', abrirVisaoCondominio);
	document.getElementById('btn-ranking-imobiliario')?.addEventListener('click', carregarRankingImobiliario);
	document.getElementById('info-moedas-modal').addEventListener('click', handleRewardEditClick);
	
	// Banco das equipes
document.getElementById('btn-enviar-banco')?.addEventListener('click', abrirModalEnviarMoedasBanco);
document.getElementById('enviar-moedas-banco-confirmar-btn')?.addEventListener('click', executarEnvioMoedasBanco);
document.getElementById('btn-extrato-banco')?.addEventListener('click', abrirModalExtratoBanco);
document.getElementById('btn-stats-banco')?.addEventListener('click', abrirModalEstatisticasBanco);

// Eventos das abas de estat√≠sticas
document.querySelectorAll('.avatar-tab-btn[data-tab-stats]').forEach(btn => {
  btn.addEventListener('click', () => {
    const tabId = btn.dataset.tabStats;
    
    // Desativa todas as abas e pain√©is
    document.querySelectorAll('.avatar-tab-btn[data-tab-stats]').forEach(t => t.classList.remove('ativo'));
    document.querySelectorAll('#estatisticas-banco-modal .avatar-tab-content').forEach(c => c.classList.remove('ativo'));

    // Ativa a aba e o painel clicados
    btn.classList.add('ativo');
    document.getElementById(`stats-tab-${tabId}`).classList.add('ativo');
  });
});

// --- IN√çCIO DA CORRE√á√ÉO: Listeners das abas principais do Avatar ---
    // Adiciona os event listeners para as abas "Meu Invent√°rio" e "Loja"
    
    const inventarioTabBtn = document.querySelector('.avatar-tab-btn[data-tab="inventario"]');
    const lojaTabBtn = document.querySelector('.avatar-tab-btn[data-tab="loja"]');
    
    const inventarioContent = document.getElementById('avatar-tab-inventario');
    const lojaContent = document.getElementById('avatar-tab-loja');

    if (inventarioTabBtn && lojaTabBtn && inventarioContent && lojaContent) {
      
      inventarioTabBtn.addEventListener('click', () => {
        
        // Gerencia as classes 'ativo'
        inventarioTabBtn.classList.add('ativo');
        lojaTabBtn.classList.remove('ativo');
        inventarioContent.classList.add('ativo');
        lojaContent.classList.remove('ativo');
        
        // Chama a fun√ß√£o para popular o conte√∫do do invent√°rio
        popularInventario();
      });

      lojaTabBtn.addEventListener('click', () => {

        // Gerencia as classes 'ativo'
        lojaTabBtn.classList.add('ativo');
        inventarioTabBtn.classList.remove('ativo');
        lojaContent.classList.add('ativo');
        inventarioContent.classList.remove('ativo');
        
        // Chama a fun√ß√£o para popular o conte√∫do da loja
        popularLojaAvatar();
      });
    } else {
      // Log de erro se os elementos n√£o forem encontrados
      console.error("N√£o foi poss√≠vel encontrar os elementos das abas do Avatar");
    }
    // --- FIM DA CORRE√á√ÉO ---
	
  }
  
  async function loginUser() {
    const username = loginUsernameInput.value.trim();
    const password = loginPasswordInput.value.trim();

    if (!username || !password) {
        mostrarPopup("Erro", "Por favor, preencha todos os campos.", 3000);
        return;
    }

    try {
        const userDocRef = doc(db, "users", username);
        const docSnap = await getDoc(userDocRef);

        if (docSnap.exists()) {
            const userData = docSnap.data();
            if (userData.password === password) {
                currentUser = username;
                // userTeam = userData.equipe; // Mantenha esta linha se 'equipe' tamb√©m existe na cole√ß√£o 'users' e √© usada para algo.

                // NOVO: Buscar o papel e a equipe do membro na cole√ß√£o 'membros'
                const membroDocRef = doc(db, "membros", currentUser); // Assume que o ID do documento do membro √© o username
                const membroDocSnap = await getDoc(membroDocRef);

                if (membroDocSnap.exists()) {
                    const membroData = membroDocSnap.data();
                    currentUserRole = membroData.papel || 'membro'; // Define o papel do usu√°rio logado
                    currentUserTeam = membroData.equipe || null; // Define a equipe do usu√°rio logado
                } else {
                    console.warn("Documento do membro n√£o encontrado na cole√ß√£o 'membros' para o usu√°rio logado:", currentUser);
                    // Em caso de erro, define um papel e equipe padr√£o para evitar quebrar a aplica√ß√£o
                    currentUserRole = 'membro';
                    currentUserTeam = null;
                }

                // Chamar carregarInformacoesMembros() para carregar a interface e os dados
                await carregarInformacoesMembros();
                
                // Estas chamadas podem ser redundantes se carregarInformacoesMembros j√° as faz,
                // mas n√£o causam problema se forem chamadas novamente.
                await carregarInformacoesMembros(); // Chamada existente para carregar dados
                // await carregarInformacoesMembros(); // Re-chamar se necess√°rio, ou garantir que seja idempotente

                // L√≥gica de g√™nero
                let textoSucesso = `Bem-vindo(a), ${username}!`;
                if (membroData.genero === 'masculino') textoSucesso = `Bem-vindo, ${username}!`;
                if (membroData.genero === 'feminino') textoSucesso = `Bem-vinda, ${username}!`;

                mostrarPopup("Sucesso", textoSucesso, 3000);
                authContainer.classList.add('hidden');
                mainContent.classList.remove('hidden');
                logoutBtn.classList.remove('hidden');

                // NOVO: Chamar esta fun√ß√£o para ajustar as permiss√µes visuais das checkboxes ap√≥s o login
                atualizarPermissoesCheckboxes();
            } else {
                mostrarPopup("Erro", "Senha incorreta.", 3000);
            }
        } else {
            mostrarPopup("Erro", "Usu√°rio n√£o encontrado.", 3000);
        }
    } catch (e) {
        console.error("Erro ao fazer login: ", e);
        mostrarPopup("Erro", "Erro ao fazer login. Tente novamente.", 3000);
    }
}

// Fun√ß√£o para copiar texto para a √°rea de transfer√™ncia
window.copyToClipboard = function(text, type) {
  navigator.clipboard.writeText(text).then(() => {
    mostrarPopup('‚úÖ Copiado', `${type} copiado para a √°rea de transfer√™ncia!`, 2000);
  }).catch(err => {
    console.error('Erro ao copiar: ', err);
    mostrarPopup('‚ùå Erro', 'N√£o foi poss√≠vel copiar.', 3000);
  });
}

window.podeDesenhar = function (equipeId) {
  if (!currentUser) return false;
  
  // Verifica se a Batalha est√° ativa (Quinta a Segunda)
  const hoje = getHoje();
  const dia = hoje.getDay();
  // Permite: Quinta(4), Sexta(5), S√°bado(6), Domingo(0), Segunda(1)
  const batalhaAtiva = (dia === 4 || dia === 5 || dia === 6 || dia === 0 || dia === 1);
  
  if (!batalhaAtiva && userRole !== 'lider') return false; // Bloqueia fora do prazo

  if (userRole === 'lider') return true;
  if (userTeam === equipeId) return true;
  return false;
};

function atualizarPermissoesCheckboxes() {
    // Seleciona todas as checkboxes que t√™m a classe 'tarefa-checkbox'
    const checkboxes = document.querySelectorAll('.tarefa-checkbox'); 
    checkboxes.forEach(checkbox => {
        const memberId = checkbox.dataset.memberId;
        const memberTeam = checkbox.dataset.memberTeam;
        if (memberId && memberTeam) { // Garante que os datasets existem
            checkbox.disabled = !podeMarcarCheckbox(memberId, memberTeam);
        }
    });
}

function atualizarVisualBloqueio() {
  if (!currentUser) return;

  todosMembros.forEach(membro => {
    const checkbox = document.getElementById(membro.nome);
    if (!checkbox) return;

    let podeMarcar = false;
    if (userRole === 'lider' || (userRole === 'lider-equipe' && membro.equipe === userTeam) || (currentUser === membro.nome)) {
      podeMarcar = true;
    }

    const membroDiv = checkbox.parentElement; // Pega o <div class="membro">
if (membroDiv) {
  if (podeMarcar) {
    membroDiv.classList.remove('bloqueado');
    membroDiv.title = 'Clique para marcar/desmarcar o foco';
  } else {
    membroDiv.classList.add('bloqueado');
    membroDiv.title = 'Voc√™ n√£o tem permiss√£o para alterar este foco';
  }
}
  });
}

function showForgotPasswordForm() {
  loginForm.classList.add('hidden');
  changePasswordForm.classList.add('hidden');
  forgotPasswordForm.classList.remove('hidden'); // Mostra o novo formul√°rio
}

async function handleVerifySecretAnswer() {
  let username = document.getElementById('forgot-username').value.trim();
  if (username) {
    username = username.charAt(0).toUpperCase() + username.slice(1).toLowerCase();
  }
  const secretAnswer = document.getElementById('secret-answer').value.trim();

  if (!username || !secretAnswer) {
    mostrarPopup("‚ùå Erro", "Preencha seu nome e a resposta secreta.", 3000);
    return;
  }

  try {
    const userDocRef = doc(db, "membros", username);
    const docSnap = await getDoc(userDocRef);

    if (docSnap.exists()) {
      const userData = docSnap.data();

      if (userData.pet && userData.pet.toLowerCase() === secretAnswer.toLowerCase()) {
        isPasswordResetFlow = true; // <-- LINHA ADICIONADA AQUI
        currentUser = username; 
        mostrarPopup("‚úÖ Correto", "Resposta correta! Crie sua nova senha.", 3000);
        forgotPasswordForm.classList.add('hidden');
        changePasswordForm.classList.remove('hidden');
      } else {
        mostrarPopup("‚ùå Incorreto", "A resposta para a pergunta secreta est√° errada.", 4000);
      }
    } else {
      mostrarPopup("‚ùå Erro", "Usu√°rio n√£o encontrado.", 3000);
    }
  } catch (error) {
    console.error("Erro ao verificar resposta secreta:", error);
    mostrarPopup("‚ùå Erro", "Ocorreu um erro ao verificar os dados.", 3000);
  }
}

function showSecretQuestionForm() {
  loginForm.classList.add('hidden');
  changePasswordForm.classList.add('hidden');
  forgotPasswordForm.classList.add('hidden');
  secretQuestionForm.classList.remove('hidden'); // Mostra o formul√°rio da pergunta
}

async function handleSaveSecretAnswer() {
  const secretAnswer = document.getElementById('setup-secret-answer').value.trim();

  if (!secretAnswer) {
    mostrarPopup("‚ùå Erro", "Por favor, preencha a resposta.", 3000);
    return;
  }

  try {
    const userDocRef = doc(db, "membros", currentUser);

    await updateDoc(userDocRef, {
      pet: secretAnswer,
      usedProv: "on"
    });

    // L√≥gica de G√™nero (Busca no array local 'todosMembros')
    let textoBemVindo = `Bem-vindo(a), ${currentUser}!`;
    const membroAtual = todosMembros.find(m => m.nome === currentUser);
    
    if (membroAtual) {
        if (membroAtual.genero === 'masculino') textoBemVindo = `Bem-vindo, ${currentUser}!`;
        else if (membroAtual.genero === 'feminino') textoBemVindo = `Bem-vinda, ${currentUser}!`;
    }

    mostrarPopup("‚úÖ Tudo Pronto!", `${textoBemVindo} Carregando o app...`, 4000);

    await performSuccessfulLogin(currentUser, true);

  } catch (error) {
    console.error("Erro ao salvar resposta secreta:", error);
    mostrarPopup("‚ùå Falha Grave", "Ocorreu um erro ao finalizar seu cadastro. Por favor, recarregue a p√°gina.", 5000);
  }
}

// Adicione estas novas fun√ß√µes ao seu script

// Fun√ß√µes para abrir e fechar modais
window.openModal = function(modalId) {
  const modal = document.getElementById(modalId);
  if (modal) {
    modal.style.display = 'flex';
    modal.classList.remove('hidden');
    // ===== LINHA CORRIGIDA/ADICIONADA =====
    // Adiciona a classe 'show' para ativar a transi√ß√£o de opacidade
    modal.classList.add('show'); 
    // ====================================
  }
}

window.closeModal = async function(modalId) {
  const modal = document.getElementById(modalId);
  if (modal) {
    modal.style.display = 'none';
    modal.classList.add('hidden');
    
    // CORRE√á√ÉO CR√çTICA: Remove a classe 'show'.
    // Isso avisa ao processador da fila que o modal realmente fechou.
    modal.classList.remove('show'); 
  }
  
  // --- CORRE√á√ÉO ADICIONADA AQUI ---
  // Garante que a lista de sugest√µes de men√ß√£o sempre feche junto com qualquer modal.
  if (typeof hideMentionSuggestions === 'function') {
      hideMentionSuggestions();
  }
  // --- FIM DA CORRE√á√ÉO ---

  // --- IN√çCIO DA NOVA L√ìGICA (PASSO 3) ---
  // Lista de popups que devem acionar a verifica√ß√£o
  const specialPopups = [
    'pix-recebido-popup',
    'medalha-ganha-popup',
    'recompensa-recebida-popup',
    'popup-envio-diario-moedas',
    'custom-card-popup',
    'recompensa-lideres-modal', 
    'recompensa-equipe-modal',
    'fim-temporada-popup'
  ];

  if (specialPopups.includes(modalId)) {
    // Aguarda um instante para o modal ser marcado como 'hidden'
    await new Promise(resolve => setTimeout(resolve, 100)); 
    
    // DESTRAVA A FILA: Garante que o sistema saiba que a tela est√° livre agora
    isCardPopupShowing = false;

    // CORRE√á√ÉO: Primeiro tenta processar a fila de Cards (ex: Mensagem do Dia)
    if (typeof cardPopupQueue !== 'undefined' && cardPopupQueue.length > 0) {
        if (typeof processarFilaCardPopup === 'function') processarFilaCardPopup();
    } 
  }
  
  // --- L√ìGICA DO FLUXO P√ìS-FOCO (TRAVA DE NOTIFICA√á√ïES) ---
  if (modalId === 'notificacoes-modal' && typeof fluxoNotificacaoFoco !== 'undefined' && fluxoNotificacaoFoco) {
      fluxoNotificacaoFoco = false; 

      // 1. Atualiza o texto do fundo para o sucesso
      if (typeof updateLoadingOverlayText === 'function') updateLoadingOverlayText("Maravilha, o foco foi registrado!");
      
      // Toca o som de sucesso uma √∫nica vez
      if (typeof tocarSom === 'function') tocarSom('som-check');
      
      // 2. Aguarda um pouco para o usu√°rio ler a mensagem antes de fechar o fundo
      setTimeout(() => {
          if (typeof hideLoadingOverlay === 'function') hideLoadingOverlay();
      }, 1500);

      // Mant√©m a l√≥gica da loteria
      if (typeof verificarNudgeLoteria === 'function') setTimeout(verificarNudgeLoteria, 2000); 
  }
  else if (modalId === 'notificacoes-modal') {
      // Caso normal (abriu pelo bot√£o do menu), s√≥ verifica loteria
      if (typeof verificarNudgeLoteria === 'function') setTimeout(verificarNudgeLoteria, 500);
  }
  // --- FIM DA L√ìGICA ---
}

function showConfirmationPopup(title, text, onConfirm) {
  document.getElementById('confirm-action-title').textContent = title;
  document.getElementById('confirm-action-text').innerHTML = text;
  document.getElementById('confirm-action-btn').onclick = () => {
    closeModal('confirm-action-modal');
    onConfirm();
  };
  openModal('confirm-action-modal');
}

// Nova fun√ß√£o para ATUALIZAR a senha de um usu√°rio J√Å LOGADO
async function handleUpdatePassword() {
  const newPassword = document.getElementById('logged-in-new-password').value;
  const confirmPassword = document.getElementById('logged-in-confirm-password').value;

  if (!newPassword || newPassword.length < 6) {
    mostrarPopup("‚ùå Erro", "A senha deve ter no m√≠nimo 6 caracteres.", 3000);
    return;
  }
  if (newPassword !== confirmPassword) {
    mostrarPopup("‚ùå Erro", "As senhas n√£o coincidem.", 3000);
    return;
  }

  // O BLOCO DE C√ìDIGO FOI REMOVIDO DAQUI

  try {
    await updateDoc(doc(db, "membros", currentUser), { senha: newPassword });
    mostrarPopup("‚úÖ Sucesso", "Sua senha foi alterada!", 3000);
    closeModal('change-password-modal');
  } catch (error) {
    mostrarPopup("‚ùå Erro", "Falha ao atualizar a senha.", 3000);
    console.error("Erro ao trocar senha:", error);
  }
}

// Nova fun√ß√£o para ATUALIZAR a pergunta secreta
async function handleUpdateSecretAnswer() {
  const newAnswer = document.getElementById('new-secret-answer').value.trim();

  if (!newAnswer) {
    mostrarPopup("‚ùå Erro", "Por favor, digite uma resposta.", 3000);
    return;
  }

  try {
    await updateDoc(doc(db, "membros", currentUser), { pet: newAnswer });
    mostrarPopup("‚úÖ Sucesso", "Sua resposta secreta foi atualizada!", 3000);
    closeModal('change-secret-modal');
  } catch (error) {
    mostrarPopup("‚ùå Erro", "Falha ao atualizar a resposta.", 3000);
    console.error("Erro ao trocar resposta secreta:", error);
  }
}

// ATUALIZADA: Aceita um idPersonalizado para evitar duplica√ß√µes no Feed
async function adicionarEventoAoFeed(tipo, titulo, texto, dadosExtras = {}, idPersonalizado = null) {
  try {
    let eventoRef;
    
    if (idPersonalizado) {
      // Se tiver ID personalizado, usa ele (Evita duplicatas!)
      eventoRef = doc(db, "resumoSemanalFeed", idPersonalizado);
    } else {
      // Se n√£o, gera um aleat√≥rio como antes
      eventoRef = doc(collection(db, "resumoSemanalFeed"));
    }

    const dadosEvento = {
      id: eventoRef.id,
      tipo: tipo,
      titulo: titulo,
      texto: texto,
      timestamp: getHoje(),
      // Se o documento j√° existe, preservamos as rea√ß√µes antigas usando merge depois
      // Mas definimos o padr√£o caso seja novo
      ...dadosExtras
    };
    
    // Usamos setDoc com merge: true para n√£o apagar rea√ß√µes se o card j√° existir
    await setDoc(eventoRef, {
        ...dadosEvento,
        reacoes: dadosExtras.reacoes || { "üëç": [], "üòÇ": [], "üò≠": [], "üíñ": [], "üò°": [] } 
    }, { merge: true });
    
    return eventoRef.id;

  } catch (error) {
    console.error("Erro ao adicionar evento ao feed:", error);
    return null;
  }
}

// =======================================================
// ===== NOVA FUN√á√ÉO: GERADOR DE EVENTOS DE FEED COM IA ====
// =======================================================

// PASSO 1: SUBSTITUA A FUN√á√ÉO ANTIGA POR ESTA
async function gerarEventoDeFoco(nome, equipe, streakAtual, pontosEquipe) {
  // Esta fun√ß√£o agora usa a mensagem padr√£o, enriquecida com o streak.
  const nomeEquipeCapitalizado = equipe.charAt(0).toUpperCase() + equipe.slice(1);
  const textoPadrao = `A equipe <strong>${nomeEquipeCapitalizado}</strong> avan√ßa com +1 ponto de <strong>${nome}</strong> (${streakAtual} üî• dias de foco), totalizando <strong>${pontosEquipe}</strong> pontos!`;
  
  await adicionarEventoAoFeed('geral', `üìà Ponto para a equipe ${nomeEquipeCapitalizado}!`, textoPadrao, { nomeMembro: nome, equipe: equipe });
}

// =======================================================
// ===== NOVA FUN√á√ÉO: GERADOR DE EVENTOS INDIVIDUAIS COM IA ====
// =======================================================

// PASSO 2: SUBSTITUA A FUN√á√ÉO ANTIGA POR ESTA
async function gerarEventoDeFocoIndividual(nome, streakAtual) {
  // Mensagem padr√£o para membros sem equipe, agora mostrando o streak.
  const textoPadrao = `Mesmo sem uma equipe na competi√ß√£o, <strong>${nome}</strong> mant√©m a disciplina, atingindo <strong>${streakAtual} üî• dias</strong> de foco. Parab√©ns pela dedica√ß√£o!`;
  
  await adicionarEventoAoFeed('geral', 'üåü Foco Pessoal Registrado!', textoPadrao, { nomeMembro: nome });
}

// NOVA FUN√á√ÉO: Cria o HTML para um card do feed
function criarElementoCardResumo(evento) {
  const card = document.createElement('div');
  card.className = `feed-card ${evento.tipo}`;
  card.dataset.id = evento.id;

  const timestamp = evento.timestamp?.toDate ? evento.timestamp.toDate() : new Date();
  const dataCurta = timestamp.toLocaleDateString('pt-BR', { day: '2-digit', month: '2-digit', year: 'numeric' });
  const horaFormatada = timestamp.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });
  const dataCompletaFormatada = `${dataCurta}, ${horaFormatada}`;

  // L√≥gica de Rea√ß√µes (copiada e adaptada do mural)
  const reacoes = evento.reacoes || {};
  let reacoesHTML = '';
  const emojisOrdenados = Object.keys(reacoes).sort((a, b) => (reacoes[b]?.length || 0) - (reacoes[a]?.length || 0));

  emojisOrdenados.forEach(emoji => {
    const reagentes = Array.isArray(reacoes[emoji]) ? reacoes[emoji] : [];
    if (reagentes.length > 0) {
      const userHasReacted = reagentes.includes(currentUser);
      const reactedClass = userHasReacted ? 'reacted' : '';
      reacoesHTML += `
        <div class="reacao-display ${reactedClass}" 
             title="Reagido por: ${reagentes.join(', ')}"
             onclick="toggleReacaoFeed(event, '${evento.id}', '${emoji}')">
          ${emoji} <span class="contador-display">${reagentes.length}</span>
        </div>`;
    }
  });

  const reacoesContainer = reacoesHTML ? `<div class="feed-card-reacoes">${reacoesHTML}</div>` : `<div class="feed-card-reacoes"></div>`;

  card.innerHTML = `
    <div class="feed-card-header">
      <span>${evento.titulo}</span>
      <span>${dataCompletaFormatada}</span>
      
      ${userRole === 'lider' ? `
        <button class="feed-card-delete-btn" title="Apagar evento" onclick="deletarEventoFeed(event, '${evento.id}')">
          &times;
        </button>
      ` : ''}
      </div>
    <div class="feed-card-body">
      ${evento.texto}
    </div>
    ${reacoesContainer}
  `;


  // Adiciona o seletor de emojis ao clicar no card
  card.addEventListener('click', (e) => {
    if (e.target.closest('.reacao-display')) return; // N√£o ativa se clicar em uma rea√ß√£o existente

    // Remove outros seletores abertos
    document.querySelectorAll('.reacao-seletor-bar').forEach(bar => bar.remove());

    const seletorBar = document.createElement('div');
    seletorBar.className = 'reacao-seletor-bar';
    const emojisParaReagir = ['üëç', 'üíñ', 'üòÇ', 'üéâ', 'üî•', 'üòÆ', 'üò≠', 'üò°'];
    emojisParaReagir.forEach(emoji => {
        const btn = document.createElement('button');
        btn.textContent = emoji;
        btn.onclick = (ev) => {
            ev.stopPropagation();
            toggleReacaoFeed(ev, evento.id, emoji);
            seletorBar.remove();
        };
        seletorBar.appendChild(btn);
    });

    // Anexa a barra de rea√ß√µes ao card clicado
    card.querySelector('.feed-card-reacoes').appendChild(seletorBar);

    // Fecha a barra se clicar fora
    setTimeout(() => {
        document.addEventListener('click', function closeBar(event) {
            if (!card.contains(event.target)) {
                seletorBar.remove();
                document.removeEventListener('click', closeBar);
            }
        }, { once: true });
    }, 100);
  });

  return card;
}

// Vari√°vel global para controlar a pagina√ß√£o do feed
let limiteAtualFeed = 10;
let unsubscribeFeed = null;

function configurarResumoSemanalTempoReal() {
  const feedContainer = document.getElementById('feed-semanal-cards');
  if (!feedContainer) return;

  // Se j√° existe um ouvinte, desliga ele antes de criar um novo com novo limite
  if (unsubscribeFeed) {
    unsubscribeFeed();
  }

  // Consulta com limite din√¢mico
  const q = query(collection(db, "resumoSemanalFeed"), orderBy("timestamp", "desc"), limit(limiteAtualFeed));

  unsubscribeFeed = onSnapshot(q, (querySnapshot) => {
    feedContainer.innerHTML = ''; 
    feedEventosCache = []; 

    if (querySnapshot.empty) {
      feedContainer.innerHTML = '<div class="sem-mensagens">Nenhum evento importante aconteceu esta semana ainda.</div>';
      return;
    }
    
    querySnapshot.forEach(doc => {
      const evento = doc.data();
      
      feedEventosCache.push({
        titulo: evento.titulo,
        texto: evento.texto.replace(/<[^>]*>/g, ""), 
        data: evento.timestamp?.toDate ? evento.timestamp.toDate().toLocaleDateString('pt-BR') : 'Data desconhecida'
      });

      const cardElement = criarElementoCardResumo(evento);
      feedContainer.appendChild(cardElement);
    });

    // --- L√ìGICA DO BOT√ÉO VER MAIS ---
    // Se a quantidade de itens recebidos for igual ao limite, provavelmente tem mais
    if (querySnapshot.size === limiteAtualFeed) {
        const btnVerMais = document.createElement('button');
        btnVerMais.textContent = "Ver mais antigos...";
        btnVerMais.className = "painel-btn";
        btnVerMais.style.width = "100%";
        btnVerMais.style.marginTop = "10px";
        btnVerMais.onclick = () => {
            limiteAtualFeed += 10; // Aumenta o limite
            configurarResumoSemanalTempoReal(); // Recarrega o listener
        };
        feedContainer.appendChild(btnVerMais);
    }
  });
}

window.toggleReacaoComentario = async function(event, messageId, commentId, emoji) {
  event.stopPropagation();
  if (!currentUser) return;

  tocarSom('som-reacao');

  const commentRef = doc(db, "mural", messageId, "comments", commentId);
  const membroRef = doc(db, "membros", currentUser);

  try {
    const resultado = await runTransaction(db, async (transaction) => {
      const docSnap = await transaction.get(commentRef);
      if (!docSnap.exists()) throw "Coment√°rio n√£o existe!";

      const dados = docSnap.data();
      const autorId = dados.userId;
      let reacoes = dados.reacoes || {};
      let reactionNotificationIds = dados.reactionNotificationIds || {};
      const reactionKey = `${currentUser}_${emoji}`;
      let reacaoAntiga = null;
      let mudancaDeMoedas = 0;
      let removeuReacao = false; // Flag

      for (const emojiExistente in reacoes) {
        if (Array.isArray(reacoes[emojiExistente]) && reacoes[emojiExistente].includes(currentUser)) {
          reacaoAntiga = emojiExistente;
          break;
        }
      }
      
      if (reacaoAntiga) {
        const oldReactionKey = `${currentUser}_${reacaoAntiga}`;
        if (reactionNotificationIds[oldReactionKey]) {
          transaction.delete(doc(db, "notificacoes", reactionNotificationIds[oldReactionKey]));
          delete reactionNotificationIds[oldReactionKey];
        }
      }

      if (reacaoAntiga === emoji) {
        const userIndex = reacoes[emoji].indexOf(currentUser);
        if (userIndex > -1) {
          reacoes[emoji].splice(userIndex, 1);
          mudancaDeMoedas = -1;
          removeuReacao = true; // Marca revers√£o
        }
      } else {
        if (reacaoAntiga) {
          const oldUserIndex = reacoes[reacaoAntiga].indexOf(currentUser);
          if (oldUserIndex > -1) reacoes[reacaoAntiga].splice(oldUserIndex, 1);
        } else {
          mudancaDeMoedas = 1;
        }
        
        if (!reacoes[emoji]) reacoes[emoji] = [];
        reacoes[emoji].push(currentUser);
      }
      
      if (mudancaDeMoedas === 1 && autorId && autorId !== currentUser) {
          const notificacoesRef = collection(db, "notificacoes");
          const newNotificacaoRef = doc(notificacoesRef);
          
          transaction.set(newNotificacaoRef, {
              destinatarioId: autorId,
              remetenteNome: currentUser,
              tipo: 'comment-reaction',
              conteudo: emoji,
              acao: `reagiu ao seu coment√°rio: "${dados.texto.substring(0, 30)}..."`,
              lida: false,
              timestamp: new Date()
          });
          reactionNotificationIds[reactionKey] = newNotificacaoRef.id;
      }

      transaction.update(commentRef, { 
          reacoes: reacoes,
          reactionNotificationIds: reactionNotificationIds
      });
      
      if (mudancaDeMoedas !== 0) {
        transaction.update(membroRef, { moedas: increment(mudancaDeMoedas * (recompensasConfig.reagirConteudo || 1)) });
      }

      return { removeuReacao: removeuReacao };
    });
    
    // Executa a l√≥gica de prote√ß√£o FORA da transa√ß√£o
        if (resultado.removeuReacao) {
            await reverterProgressoProtecao('reagir');
        } else {
            // CORRE√á√ÉO: Chama a fun√ß√£o para contabilizar a rea√ß√£o no Feed como tarefa cumprida
            atualizarProgressoProtecao('reagir');
        }

    } catch (error) {
    console.error("Falha na transa√ß√£o de rea√ß√£o do coment√°rio: ", error);
    mostrarPopup("‚ùå Ops!", "Sua rea√ß√£o n√£o p√¥de ser salva. Por favor, recarregue a p√°gina.", 4000);
  }
};

window.toggleReacaoFeed = async function(event, eventoId, emoji) {
    event.stopPropagation();
    if (!currentUser) return;

    atualizarReacaoOtimista('#feed-semanal-cards', eventoId, emoji);
    
    const eventoRef = doc(db, "resumoSemanalFeed", eventoId);
    const membroRef = doc(db, "membros", currentUser);

    try {
        tocarSom('som-reacao');
        const resultado = await runTransaction(db, async (transaction) => {
            const docSnap = await transaction.get(eventoRef);
            if (!docSnap.exists()) { throw "Evento n√£o encontrado!"; }

            const dados = docSnap.data();
            const membroAlvo = dados.nomeMembro || dados.nomeLider;
            const reacoes = dados.reacoes || {};
            let reactionNotificationIds = dados.reactionNotificationIds || {};
            const reactionKey = `${currentUser}_${emoji}`;

            let reacaoAntiga = null;
            let mudancaDeMoedas = 0;
            let removeuReacao = false; // Flag

            for (const emojiExistente in reacoes) {
                if (Array.isArray(reacoes[emojiExistente]) && reacoes[emojiExistente].includes(currentUser)) {
                    reacaoAntiga = emojiExistente;
                    break;
                }
            }

            if (reacaoAntiga) {
                const oldReactionKey = `${currentUser}_${reacaoAntiga}`;
                if (reactionNotificationIds[oldReactionKey]) {
                    transaction.delete(doc(db, "notificacoes", reactionNotificationIds[oldReactionKey]));
                    delete reactionNotificationIds[oldReactionKey];
                }
            }

            if (!Array.isArray(reacoes[emoji])) {
                reacoes[emoji] = [];
            }

            const userIndex = reacoes[emoji].indexOf(currentUser);

            if (reacaoAntiga === emoji) {
                if (userIndex > -1) {
                    reacoes[emoji].splice(userIndex, 1);
                    mudancaDeMoedas = -1;
                    removeuReacao = true; // Marca revers√£o
                }
            } else {
                if (reacaoAntiga) {
                    const oldUserIndex = reacoes[reacaoAntiga].indexOf(currentUser);
                    if (oldUserIndex > -1) reacoes[reacaoAntiga].splice(oldUserIndex, 1);
                } else {
                    mudancaDeMoedas = 1;
                }
                reacoes[emoji].push(currentUser);
            }

            if (mudancaDeMoedas === 1 && membroAlvo && membroAlvo !== currentUser) {
                const notificacoesRef = collection(db, "notificacoes");
                const newNotificacaoRef = doc(notificacoesRef);

                transaction.set(newNotificacaoRef, {
                    destinatarioId: membroAlvo,
                    remetenteNome: currentUser,
                    tipo: 'feed',
                    conteudo: emoji,
                    acao: `reagiu a um evento sobre voc√™: "${dados.titulo}"`,
                    lida: false,
                    timestamp: new Date()
                });
                reactionNotificationIds[reactionKey] = newNotificacaoRef.id;
            }
            
            transaction.update(eventoRef, { 
                reacoes: reacoes,
                reactionNotificationIds: reactionNotificationIds
            });

            if (mudancaDeMoedas !== 0) {
              transaction.update(membroRef, { moedas: increment(mudancaDeMoedas * (recompensasConfig.reagirConteudo || 1)) });
            }

            return { removeuReacao: removeuReacao };
        });

        // Executa a l√≥gica de prote√ß√£o FORA da transa√ß√£o
        if (resultado.removeuReacao) {
            await reverterProgressoProtecao('reagir');
        } else {
            await atualizarProgressoProtecao('reagir');
        }

    } catch (error) {
        console.error("Erro ao reagir no feed:", error);
        mostrarPopup("‚ùå Ops!", "Sua rea√ß√£o n√£o p√¥de ser salva. Por favor, recarregue a p√°gina.", 4000);
    }
}

async function gerarReacaoOraculoParaMensagemComIA(textoDaMensagem) {
  if (!genAI) return 'üëç';

  const prompt = `
    Voc√™ √© o Or√°culo, um mentor s√°bio e carinhoso.
    Um membro do grupo postou a seguinte mensagem no mural:
    "${textoDaMensagem}"
    
    Qual emoji melhor representa sua rea√ß√£o a esta mensagem?
    Escolha UM emoji da seguinte lista: ['üëç', 'üíñ', 'üòÇ', 'üéâ', 'üî•', 'üòÆ']

    Sua resposta DEVE ser um JSON v√°lido no formato: {"emoji": "SEU_EMOJI_AQUI"}.
    Apenas o JSON, sem explica√ß√µes.
  `;

  try {
    const text = await callGenerativeAIWithRetry(prompt); // USA A NOVA FUN√á√ÉO AQUI
    const jsonString = text.match(/{[\s\S]*}/)[0];
    const { emoji } = JSON.parse(jsonString);
    return emoji && EMOJIS_MURAL.includes(emoji) ? emoji : 'üëç';
  } catch (error) {
    console.error("Or√°culo (Rea√ß√£o Imediata): Erro final ao escolher emoji.", error);
    return 'üëç';
  }
}

// ATUALIZADA: Agora usa a fun√ß√£o com retentativas
async function gerarRespostaOraculoParaMensagem(messageId, textoOriginal, autorMensagem) {
  if (!genAI) return;

  console.log(`Or√°culo: Fui mencionado na mensagem de ${autorMensagem}. Preparando resposta...`);

  const prompt = `
    Voc√™ √© o Or√°culo, o mentor s√°bio e carinhoso do Grupo √âpicos.
    Um membro, "${autorMensagem}", acabou de te mencionar em uma mensagem no mural. Sua tarefa √© escrever uma resposta direta e acolhedora.

    CONTEXTO:
    - Mensagem do Membro (que te mencionou): "${textoOriginal}"

    INSTRU√á√ïES:
    1.  Sua resposta deve ser curta, am√°vel e no seu estilo de mentor.
    2.  Responda diretamente √† mensagem, mencionando o autor com <strong>@${autorMensagem}</strong>.
    3.  N√ÉO se revele como uma IA. Aja 100% como uma pessoa.
    4.  Assine sua resposta com "‚Äî Or√°culo".
    5.  Sua resposta deve ser apenas o texto do coment√°rio, sem formata√ß√£o JSON ou introdu√ß√µes.
  `;

  try {
    const respostaTexto = await callGenerativeAIWithRetry(prompt); // USA A NOVA FUN√á√ÉO AQUI

    const commentsRef = collection(db, "mural", messageId, "comments");
    await addDoc(commentsRef, {
      userId: "Or√°culo",
      texto: respostaTexto.replace(/\n/g, '<br>'),
      timestamp: new Date(),
      reacoes: EMOJIS_MURAL.reduce((acc, emoji) => ({...acc, [emoji]: []}), {})
    });
    
    await updateDoc(doc(db, "mural", messageId), { commentCount: increment(1) });
    console.log("Or√°culo: Resposta √† mensagem enviada como coment√°rio com sucesso.");

  } catch (error) {
    console.error("Or√°culo: Erro ao gerar ou postar resposta de mensagem:", error);
  }
}

// SUBSTITUA A SUA FUN√á√ÉO ANTIGA POR ESTA

async function executarInteracaoImediataOraculo(messageId, textoOriginal, autorMensagem) {
  // 1. Obt√©m todo o contexto din√¢mico do grupo
  const contextoDinamico = await obterContextoDinamicoParaIA();
  
  // 2. Cria um contexto combinado para a IA
  const contextoCompleto = `
    O membro "${autorMensagem}" acabou de postar a seguinte mensagem no mural: "${textoOriginal}"
    
    --- CONTEXTO ATUAL DO GRUPO PARA SUA AN√ÅLISE ---
    ${contextoDinamico}
  `;

  const instrucoes = `
    1.  Escolha UM emoji de rea√ß√£o da lista: ['üëç', 'üíñ', 'üòÇ', 'üéâ', 'üî•', 'üòÆ'].
    2.  Escreva uma resposta curta, am√°vel e no seu estilo de mentor, mencionando o autor com <strong>@${autorMensagem}</strong>.
    3.  Analise o CONTEXTO ATUAL DO GRUPO para dar uma resposta relevante. Se a pergunta for sobre quem vai ganhar, voc√™ DEVE se posicionar e fazer uma aposta com base nos dados.
    4.  Assine sua resposta com "‚Äî Or√°culo".
    5.  N√ÉO se revele como uma IA.
  `;

  // 3. Faz UMA √öNICA chamada para a IA com o contexto completo
  const resultado = await gerarReacaoERespostaCombinadaComIA(contextoCompleto, instrucoes);

  if (!resultado) {
    console.error("Or√°culo (Mensagem): Falha ao obter dados da IA. A intera√ß√£o ser√° abortada.");
    return;
  }
  
  // 4. Executa as a√ß√µes com os dados recebidos
  try {
    // Reagir √† mensagem
    await adicionarReacaoComoOraculo(messageId, resultado.emoji);

    // Responder √† mensagem (como um coment√°rio)
    const commentsRef = collection(db, "mural", messageId, "comments");
    await addDoc(commentsRef, {
      userId: "Or√°culo",
      texto: resultado.resposta.replace(/\n/g, '<br>'),
      timestamp: new Date(),
      reacoes: EMOJIS_MURAL.reduce((acc, emoji) => ({...acc, [emoji]: []}), {})
    });
    
    await updateDoc(doc(db, "mural", messageId), { commentCount: increment(1) });
    
    console.log("Or√°culo: Rea√ß√£o e resposta √† MENSAGEM enviadas com sucesso.");

  } catch (error) {
    console.error("Or√°culo (Mensagem): Erro ao postar rea√ß√£o ou coment√°rio.", error);
  }
}

// NOVA FUN√á√ÉO: Limpa apostas de edi√ß√µes anteriores √† atual
async function limparApostasLoteriaAntigas() {
    console.log("üßπ Verificando apostas de loteria antigas...");
    try {
        // 1. Descobre a edi√ß√£o atual
        const estadoRef = doc(db, "loteria", "estadoAtual");
        const estadoSnap = await getDoc(estadoRef);
        if (!estadoSnap.exists()) return;
        
        const edicaoAtual = estadoSnap.data().edicao;

        // 2. Busca apostas com edi√ß√£o menor que a atual
        const apostasRef = collection(db, "loteria", "estadoAtual", "apostasDaEdicao");
        const q = query(apostasRef, where("edicao", "<", edicaoAtual));
        const snapshot = await getDocs(q);

        if (snapshot.empty) {
            console.log("Nenhuma aposta antiga de loteria para limpar.");
            return;
        }

        const batch = writeBatch(db);
        snapshot.forEach(doc => {
            batch.delete(doc.ref);
        });

        await batch.commit();
        console.log(`‚úÖ Limpeza conclu√≠da! ${snapshot.size} apostas de loteria antigas foram removidas.`);
    } catch (error) {
        console.error("Erro ao limpar apostas antigas:", error);
    }
}

// NOVA FUN√á√ÉO: Limpa bloqueios de popups de dias anteriores para economizar espa√ßo
async function limparBloqueiosAntigosUsuario() {
    if (!currentUser) return;
    
    const membroCache = todosMembros.find(m => m.nome === currentUser);
    if (!membroCache || !membroCache.bloqueiosPopups) return;

    const hojeISO = getHojeISO();
    const bloqueios = membroCache.bloqueiosPopups;
    const chavesParaRemover = [];

    // Identifica chaves que n√£o cont√™m a data de hoje
    for (const key in bloqueios) {
        if (!key.endsWith(hojeISO)) {
            chavesParaRemover.push(key);
        }
    }

    if (chavesParaRemover.length > 0) {
        console.log(`Limpando ${chavesParaRemover.length} bloqueios de popup antigos...`);
        const membroRef = doc(db, "membros", currentUser);
        
        // Cria objeto para dele√ß√£o
        const updates = {};
        chavesParaRemover.forEach(key => {
            updates[`bloqueiosPopups.${key}`] = deleteField();
        });

        try {
            await updateDoc(membroRef, updates);
            // Atualiza cache local
            chavesParaRemover.forEach(key => delete membroCache.bloqueiosPopups[key]);
        } catch (error) {
            console.error("Erro na limpeza de bloqueios:", error);
        }
    }
}

async function limparHistoricoTopicosOraculo() {
  try {
    console.log("Limpando hist√≥ricos de t√≥picos do Or√°culo de semanas anteriores...");
    const semanaAtual = getSemanaAtual();
    const idHistoricoAtual = `oraculoTopics_${semanaAtual.numero}_${semanaAtual.inicio.getFullYear()}`;

    const q = query(collection(db, "appState"));
    const querySnapshot = await getDocs(q);

    if (querySnapshot.empty) return;

    const batch = writeBatch(db);
    let documentosApagados = 0;

    querySnapshot.forEach(doc => {
      // Apaga apenas os documentos de hist√≥rico de T√ìPICOS que N√ÉO s√£o da semana atual
      if (doc.id.startsWith("oraculoTopics_") && doc.id !== idHistoricoAtual) {
        batch.delete(doc.ref);
        documentosApagados++;
      }
    });

    if (documentosApagados > 0) {
      await batch.commit();
      console.log(`‚úÖ Limpeza conclu√≠da: ${documentosApagados} registro(s) de hist√≥rico de t√≥picos do Or√°culo foram removidos.`);
    }
  } catch (error) {
    console.error("Erro ao limpar hist√≥ricos de t√≥picos do Or√°culo:", error);
  }
}

async function limparHistoricoNotificacoesOraculo() {
  try {
    console.log("Limpando hist√≥ricos de notifica√ß√£o do Or√°culo de semanas anteriores...");
    const semanaAtual = getSemanaAtual();
    const idHistoricoAtual = `oraculoHistory_semana_${semanaAtual.numero}_${semanaAtual.inicio.getFullYear()}`;

    const q = query(collection(db, "appState"));
    const querySnapshot = await getDocs(q);

    if (querySnapshot.empty) return;

    const batch = writeBatch(db);
    let documentosApagados = 0;

    querySnapshot.forEach(doc => {
      // Apaga apenas os documentos de hist√≥rico de notifica√ß√£o que N√ÉO s√£o da semana atual
      if (doc.id.startsWith("oraculoHistory_") && doc.id !== idHistoricoAtual) {
        batch.delete(doc.ref);
        documentosApagados++;
      }
    });

    if (documentosApagados > 0) {
      await batch.commit();
      console.log(`‚úÖ Limpeza conclu√≠da: ${documentosApagados} registro(s) de hist√≥rico do Or√°culo foram removidos.`);
    }
  } catch (error) {
    console.error("Erro ao limpar hist√≥ricos de notifica√ß√£o do Or√°culo:", error);
  }
}

// NOVA FUN√á√ÉO: Apaga todos os documentos do feed semanal
async function limparFeedSemanal() {
  console.log("üßπ Verificando e limpando o feed da semana anterior...");
  const q = query(collection(db, "resumoSemanalFeed"));
  const querySnapshot = await getDocs(q);

  if (querySnapshot.empty) {
    console.log("Feed j√° estava limpo.");
    return;
  }

  const batch = writeBatch(db);
  querySnapshot.forEach(doc => {
    batch.delete(doc.ref);
  });

  await batch.commit();
  console.log(`‚úÖ Feed limpo! ${querySnapshot.size} eventos removidos.`);
  
  // Adiciona a mensagem de "nova semana" AP√ìS limpar o feed.
  await adicionarEventoAoFeed(
      'geral', 
      '‚ú® Uma Nova Semana Come√ßou!', 
      'O resumo da semana foi zerado. Que esta seja uma semana produtiva e cheia de foco para todos n√≥s!'
  );
}

// 2. ADICIONE esta nova fun√ß√£o para limpar todo o mural.
async function limparTodoOMural() {
    console.log("üßπ Verificando e limpando o mural de mensagens...");
    const q = query(collection(db, "mural"));
    const querySnapshot = await getDocs(q);

    if (querySnapshot.empty) {
        console.log("Mural de mensagens j√° estava limpo.");
        return;
    }

    const batch = writeBatch(db);
    querySnapshot.forEach(doc => {
        batch.delete(doc.ref);
    });

    await batch.commit();
    console.log(`‚úÖ Mural limpo! ${querySnapshot.size} mensagens removidas.`);
}

// =============================================
// ===== NOVAS FUN√á√ïES DE LIMPEZA SEMANAL ======
// =============================================

// NOVA FUN√á√ÉO: Apaga as notifica√ß√µes com mais de 7 dias.
async function limparNotificacoesAntigas() {
  console.log("üßπ Verificando e limpando notifica√ß√µes antigas...");
  
  try {
    // 1. Calcula a data de corte (hoje - 7 dias)
    const hoje = new Date();
    const dataCorte = new Date(hoje.setDate(hoje.getDate() - 7));

    // 2. Cria a consulta no Firestore para buscar documentos cujo timestamp
    //    seja anterior √† data de corte.
    const q = query(
      collection(db, "notificacoes"), 
      where("timestamp", "<", dataCorte)
    );

    const querySnapshot = await getDocs(q);

    if (querySnapshot.empty) {
      console.log("Nenhuma notifica√ß√£o antiga para limpar.");
      return;
    }

    // 3. Usa um "batch" para deletar todos os documentos de uma s√≥ vez.
    const batch = writeBatch(db);
    querySnapshot.forEach(doc => {
      batch.delete(doc.ref);
    });

    await batch.commit();
    console.log(`‚úÖ Limpeza conclu√≠da! ${querySnapshot.size} notifica√ß√µes antigas foram removidas.`);

  } catch (error) {
    console.error("Erro ao limpar notifica√ß√µes antigas:", error);
  }
  
  // O bloco de c√≥digo que limpava "dailyMemberState" foi removido daqui.
  
}

// NOVA FUN√á√ÉO: Limpa a sub-cole√ß√£o de coment√°rios de todos os posts do mural.
async function limparTodosOsComentariosDoMural() {
    console.log("üßπ Verificando e limpando os coment√°rios do mural...");
    try {
        const muralRef = collection(db, "mural");
        const muralSnapshot = await getDocs(muralRef);

        if (muralSnapshot.empty) {
            console.log("Nenhuma mensagem no mural para limpar coment√°rios.");
            return;
        }

        const batch = writeBatch(db);
        let totalComentariosApagados = 0;

        // Precisamos percorrer cada mensagem para acessar sua sub-cole√ß√£o de coment√°rios
        for (const messageDoc of muralSnapshot.docs) {
            const commentsRef = collection(db, "mural", messageDoc.id, "comments");
            const commentsSnapshot = await getDocs(commentsRef);

            if (!commentsSnapshot.empty) {
                commentsSnapshot.forEach(commentDoc => {
                    batch.delete(commentDoc.ref);
                    totalComentariosApagados++;
                });
            }
        }

        if (totalComentariosApagados > 0) {
            await batch.commit();
            console.log(`‚úÖ Coment√°rios limpos! ${totalComentariosApagados} coment√°rios foram removidos.`);
        } else {
            console.log("Nenhum coment√°rio encontrado para apagar.");
        }

    } catch (error) {
        console.error("Erro ao limpar os coment√°rios do mural:", error);
    }
}

// NOVA FUN√á√ÉO: Limpa todas as telas de desenho das equipes.
async function limparTodasAsTelasDeDesenho() { 
  console.log("üßπ Limpando todas as telas de desenho...");
  const equipes = ['abelha', 'joaninha', 'vagalume'];
  try {
    for (const equipe of equipes) {
      const q = query(collection(db, `desenhos_${equipe}`));
      const querySnapshot = await getDocs(q);
      if (!querySnapshot.empty) {
        const batch = writeBatch(db);
        querySnapshot.forEach(doc => batch.delete(doc.ref));
        await batch.commit();
        console.log(`- Tela da equipe ${equipe} limpa.`);
      }
    }
    console.log("‚úÖ Limpeza das telas de desenho conclu√≠da.");
  } catch(error) {
    console.error("Erro ao limpar as telas de desenho:", error);
  }
}

// NOVA FUN√á√ÉO: Limpa os registros de popups de recompensa de semanas passadas.
async function limparPopupStateAntigo() {
  try {
    console.log("Limpando estados de popup de semanas anteriores...");
    const semanaAtual = getSemanaAtual();
    const idSemanaAtual = `popupState_${semanaAtual.numero}_${semanaAtual.inicio.getFullYear()}`;

    const q = query(collection(db, "appState"));
    const querySnapshot = await getDocs(q);

    if (querySnapshot.empty) return;

    const batch = writeBatch(db);
    let documentosApagados = 0;

    querySnapshot.forEach(doc => {
      // Apaga apenas os documentos de estado de popup que N√ÉO s√£o da semana atual
      if (doc.id.startsWith("popupState_") && doc.id !== idSemanaAtual) {
        batch.delete(doc.ref);
        documentosApagados++;
      }
    });

    if (documentosApagados > 0) {
      await batch.commit();
      console.log(`‚úÖ Limpeza conclu√≠da: ${documentosApagados} registro(s) de estado de popup antigos foram removidos.`);
    }
  } catch (error) {
    console.error("Erro ao limpar estados de popup antigos:", error);
  }
}

// =======================================================
// ===== FUN√á√ÉO PARA LIMPAR PODERES ANTIGOS (PASSO 1) =====
// =======================================================
// ATUALIZADA: Limpeza total dos poderes na virada da semana
async function limparStatusPoderesAntigos() {
    try {
        console.log("üßπ Limpeza Semanal: Removendo TODOS os efeitos de poderes ativos...");
        
        // Como √© uma nova semana, limpamos tudo para garantir que nada da semana anterior persista.
        const q = query(collection(db, "statusPoderes"));
        const querySnapshot = await getDocs(q);
        
        if (querySnapshot.empty) {
            console.log("Nenhum status de poder ativo para limpar.");
            return;
        }

        const batch = writeBatch(db);
        let documentosApagados = 0;

        querySnapshot.forEach(doc => {
            batch.delete(doc.ref);
            documentosApagados++;
        });

        await batch.commit();
        
        // Limpa o cache local tamb√©m para refletir a mudan√ßa imediatamente sem recarregar
        statusPoderesAtivos = [];
        
        console.log(`‚úÖ Limpeza conclu√≠da: ${documentosApagados} efeitos de magia foram removidos para o in√≠cio da nova semana.`);

    } catch(error) {
        console.error("Erro ao limpar registros de poderes antigos:", error);
    }
}

// NOVA FUN√á√ÉO: Apaga as mensagens di√°rias do Or√°culo anteriores ao dia de hoje (Corre√ß√£o por ID)
async function limparMensagensDiariasAntigas() {
  console.log("üßπ Verificando mensagens di√°rias antigas...");
  try {
    const hojeISO = getHojeISO(); // Ex: "2025-12-31"

    // Busca todos os documentos da cole√ß√£o
    const q = query(collection(db, "mensagensDiarias"));
    const querySnapshot = await getDocs(q);

    if (querySnapshot.empty) {
      console.log("Nenhuma mensagem di√°ria para limpar.");
      return;
    }

    const batch = writeBatch(db);
    let documentosApagados = 0;

    querySnapshot.forEach(doc => {
      // O ID √©: NomeDoUsuario_AAAA-MM-DD
      // Se o ID N√ÉO terminar com a data de hoje, √© antigo.
      if (!doc.id.endsWith(hojeISO)) {
          batch.delete(doc.ref);
          documentosApagados++;
      }
    });

    if (documentosApagados > 0) {
      await batch.commit();
      console.log(`‚úÖ Limpeza conclu√≠da! ${documentosApagados} mensagens di√°rias antigas foram removidas.`);
    } else {
      console.log("Nenhuma mensagem antiga encontrada (todas s√£o de hoje).");
    }

  } catch (error) {
    console.error("Erro ao limpar cole√ß√£o 'mensagensDiarias':", error);
  }
}

// NOVA FUN√á√ÉO: Apaga os locks da √Årvore de dias anteriores para limpar o appState
async function limparLocksAntigosDaArvore() {
  console.log("üßπ Verificando locks antigos da √Årvore √âpica...");
  try {
    const hojeISO = getHojeISO();
    const idLockHoje = `lock_arvore_${hojeISO}`; 

    const q = query(collection(db, "appState"));
    const querySnapshot = await getDocs(q);

    if (querySnapshot.empty) return;

    const batch = writeBatch(db);
    let documentosApagados = 0;

    querySnapshot.forEach(doc => {
      // Apaga se come√ßar com "lock_arvore_" E n√£o for o ID exato de hoje
      if (doc.id.startsWith("lock_arvore_") && doc.id !== idLockHoje) {
        batch.delete(doc.ref); 
        documentosApagados++;
      }
    });

    if (documentosApagados > 0) {
      await batch.commit();
      console.log(`‚úÖ Limpeza conclu√≠da: ${documentosApagados} lock(s) antigos da √°rvore foram removidos.`);
    }
  } catch (error) {
    console.error("Erro ao limpar locks antigos da √°rvore:", error);
  }
}

// NOVA FUN√á√ÉO: Apaga os registros de recompensas de l√≠deres de semanas anteriores
async function limparRecompensasLideresAntigas() {
  console.log("üßπ Verificando recompensas de l√≠deres antigas...");
  try {
    // Precisamos manter o documento da semana passada (para o pagamento no domingo/segunda)
    // E o da semana atual (se j√° tiver sido criado).
    const hoje = getHoje();
    const semanaAtual = getSemanaAtual();
    const semanaPassada = getSemanaAtual(new Date(hoje.getTime() - (24 * 60 * 60 * 1000 * 7)));

    const idSemanaAtual = `semana_${semanaAtual.numero}_${semanaAtual.inicio.getFullYear()}`;
    const idSemanaPassada = `semana_${semanaPassada.numero}_${semanaPassada.inicio.getFullYear()}`;

    const recompensasRef = collection(db, "recompensasLideres");
    const querySnapshot = await getDocs(recompensasRef);

    if (querySnapshot.empty) {
      console.log("Nenhuma recompensa antiga para limpar.");
      return;
    }

    const batch = writeBatch(db);
    let documentosApagados = 0;

    querySnapshot.forEach(doc => {
      // Se o documento N√ÉO for da semana atual E N√ÉO for da semana passada, apaga.
      if (doc.id !== idSemanaAtual && doc.id !== idSemanaPassada) {
        console.log(`Marcando para apagar recompensa antiga: ${doc.id}`);
        batch.delete(doc.ref);
        documentosApagados++;
      }
    });

    if (documentosApagados > 0) {
      await batch.commit();
      console.log(`‚úÖ Limpeza conclu√≠da: ${documentosApagados} registros de recompensas antigos removidos.`);
    } else {
        console.log("Nenhum registro antigo de recompensa encontrado.");
    }

  } catch (error) {
    console.error("Erro ao limpar recompensas de l√≠deres antigas:", error);
  }
}

// NOVA FUN√á√ÉO: Apaga os registros de envio di√°rio anteriores ao dia de hoje.
async function limparEnviosDiariosAntigos() {
  console.log("üßπ Verificando envios di√°rios antigos...");
  try {
    // 1. Define a data de corte como HOJE (00:00:00)
    // Isso garante que qualquer envio feito antes de hoje (ontem, semana passada, etc.) ser√° apagado.
    const dataCorte = new Date();
    dataCorte.setHours(0, 0, 0, 0);

    // 2. Busca todos os documentos da cole√ß√£o
    const enviosRef = collection(db, "enviosDiarios");
    const querySnapshot = await getDocs(enviosRef);

    if (querySnapshot.empty) {
      console.log("Nenhum registro de envio di√°rio encontrado para limpar.");
      return;
    }

    const batch = writeBatch(db);
    let documentosApagados = 0;

    // 3. Itera sobre cada documento e verifica a data no ID
    querySnapshot.forEach(doc => {
      // O ID do documento √© no formato "NomeUsuario_AAAA-MM-DD"
      const partesId = doc.id.split('_');
      if (partesId.length > 1) {
        const dataStr = partesId[partesId.length - 1];
        
        // Converte a string da data para um objeto Date
        // Adicionamos "T12:00:00" para evitar problemas de fuso hor√°rio onde o dia anterior √© pego incorretamente
        const dataDoc = new Date(dataStr + "T12:00:00");
        
        // Se a data do documento for anterior √† data de corte (hoje), apaga
        if (dataDoc < dataCorte) {
          batch.delete(doc.ref);
          documentosApagados++;
        }
      }
    });

    if (documentosApagados > 0) {
      await batch.commit();
      console.log(`‚úÖ Limpeza conclu√≠da! ${documentosApagados} registro(s) de envio di√°rio antigos foram removidos.`);
    } else {
      console.log("Nenhum registro de envio di√°rio antigo para apagar nesta verifica√ß√£o.");
    }

  } catch (error) {
    console.error("Erro ao limpar a cole√ß√£o 'enviosDiarios':", error);
  }
}

// Fun√ß√£o que o l√≠der chama para for√ßar a atualiza√ß√£o de todos
async function requestGlobalRefresh() {
  if (!confirm("Tem certeza que deseja for√ßar a atualiza√ß√£o da p√°gina para todos os membros?")) return;

  try {
    // Usamos um local espec√≠fico no DB para isso: cole√ß√£o 'appState', documento 'status'
    const refreshRef = doc(db, "appState", "status");
    await setDoc(refreshRef, { 
      lastRefreshRequest: new Date() // Salva o timestamp atual
    });
    mostrarPopup("üöÄ Enviado!", "Comando de atualiza√ß√£o enviado para todos os membros.", 3000);
  } catch (error) {
    console.error("Erro ao solicitar atualiza√ß√£o global:", error);
    mostrarPopup("‚ùå Erro", "N√£o foi poss√≠vel enviar o comando.", 4000);
  }
}

// Configura o ouvinte de snapshot para atualiza√ß√µes globais
function setupRefreshListener() {
  const refreshRef = doc(db, "appState", "status");

  onSnapshot(refreshRef, (docSnap) => {
    if (docSnap.exists()) {
      const newTimestamp = docSnap.data().lastRefreshRequest?.toDate();
      
      if (newTimestamp) {
        // A primeira vez que carrega, apenas armazena o timestamp
        if (lastRefreshTimestamp === null) {
          lastRefreshTimestamp = newTimestamp;
          return;
        }

        // Se o timestamp do DB for mais novo que o nosso, significa que outra pessoa (o l√≠der) pediu a atualiza√ß√£o
        if (newTimestamp > lastRefreshTimestamp) {
          console.log("Recebido comando de atualiza√ß√£o global. Atualizando a interface...");
          lastRefreshTimestamp = newTimestamp; // Atualiza nosso timestamp local
          refreshAppUI(); // Executa a atualiza√ß√£o!
        }
      }
    }
  });
}

// Fun√ß√£o que o l√≠der chama para for√ßar a atualiza√ß√£o de vers√£o
async function triggerForcedUpdate() {
  if (!confirm("‚ö†Ô∏è ATEN√á√ÉO!\n\nVoc√™ est√° prestes a for√ßar uma atualiza√ß√£o para TODOS os membros. A tela deles ser√° bloqueada at√© que cliquem no bot√£o para atualizar.\n\nUse isso apenas ap√≥s ter certeza de que uma nova vers√£o do aplicativo est√° no ar.\n\nDeseja continuar?")) {
    return;
  }

  try {
    const statusRef = doc(db, "appState", "status");
    // Usamos um timestamp como um n√∫mero de vers√£o.
    // Qualquer um com uma vers√£o mais antiga ser√° for√ßado a atualizar.
    await setDoc(statusRef, { 
      requiredUpdateVersion: new Date()
    }, { merge: true }); // Merge para n√£o apagar o 'lastRefreshRequest'

    mostrarPopup("üöÄ Enviado!", "Comando de atualiza√ß√£o de vers√£o enviado.", 4000);
  } catch (error) {
    console.error("Erro ao for√ßar atualiza√ß√£o:", error);
    mostrarPopup("‚ùå Erro", "N√£o foi poss√≠vel enviar o comando.", 4000);
  }
}

// Fun√ß√£o que mostra a tela de bloqueio
function showUpdateOverlay() {
  const overlay = document.getElementById('update-overlay');
  if (overlay) {
    overlay.classList.remove('hidden');
  }
}

// Fun√ß√£o que o bot√£o de atualiza√ß√£o vai chamar
function performUpdate() {
  if (!officialAppVersion) {
    location.reload(true);
    return;
  }
  
  // ALTERA√á√ÉO: Remove a chave do sessionStorage para que o popup possa reaparecer.
  sessionStorage.removeItem('popupDiarioMostrado');
  
  // =======================================================
  // ===== IN√çCIO DA ALTERA√á√ÉO (PASSO 5) =====
  // =======================================================
  sessionStorage.removeItem('popupAnaliseOraculoVisto'); // <-- NOVA LINHA ADICIONADA
  // =======================================================
  // ===== FIM DA ALTERA√á√ÉO =====
  // =======================================================
  
  localStorage.setItem('currentAppVersion', officialAppVersion.toISOString());
  location.reload(true);
}

// Fun√ß√£o que escuta as mudan√ßas de vers√£o no Firestore
function setupVersionCheckListener() {
  const statusRef = doc(db, "appState", "status");

  onSnapshot(statusRef, (docSnap) => {
    if (docSnap.exists()) {
      const data = docSnap.data();
      if (data.requiredUpdateVersion) {
        // Armazena a vers√£o oficial que veio do DB na nossa vari√°vel global
        officialAppVersion = data.requiredUpdateVersion.toDate();
        
        // Pega a vers√£o que o usu√°rio tem salva no navegador dele
        const localVersionStr = localStorage.getItem('currentAppVersion');
        const localVersion = localVersionStr ? new Date(localVersionStr) : new Date(0); // Usa uma data muito antiga se n√£o houver nada salvo

        // Se a vers√£o oficial for mais nova que a vers√£o local, mostra a tela
        if (officialAppVersion > localVersion) {
          console.log("Nova vers√£o detectada. Exibindo tela de atualiza√ß√£o.");
          showUpdateOverlay();
        }
      }
    }
  });
}

// NOVA FUN√á√ÉO: Deleta um card do feed semanal
window.deletarEventoFeed = async function(event, eventoId) {
  // Impede que o clique no bot√£o "x" acione outros cliques no card
  event.stopPropagation();

  if (!confirm("Tem certeza que deseja apagar este evento do feed?")) {
    return; // O usu√°rio cancelou a a√ß√£o
  }

  try {
    const eventoRef = doc(db, "resumoSemanalFeed", eventoId);
    await deleteDoc(eventoRef);
    mostrarPopup("‚úÖ Sucesso", "O evento foi removido do feed.", 3000);
    // O feed se atualizar√° automaticamente por causa do 'onSnapshot'
  } catch (error) {
    console.error("Erro ao deletar evento do feed:", error);
    mostrarPopup("‚ùå Erro", "N√£o foi poss√≠vel remover o evento.", 4000);
  }
}

async function carregarCondominioEpicos() {
    if (!currentUser) return;

    const membroRef = doc(db, "membros", currentUser);

    // Listener em tempo real para moedas e casa
    onSnapshot(membroRef, (docSnap) => {
        if (docSnap.exists()) {
            const data = docSnap.data();

            // Atualiza o nome e o saldo de moedas
            document.getElementById('nome-membro-condominio').textContent = currentUser;
            document.getElementById('saldo-moedas').textContent = data.moedas || 0;
			
			// Altera√ß√£o: Adicionado .toLocaleString('pt-BR') para formatar com pontos
			document.querySelector('#indicador-moedas-pessoal span').textContent = (data.moedas || 0).toLocaleString('pt-BR');

            const loteContainer = document.getElementById('lote-pessoal-container');
            const casaExibidaId = data.casaExibida;

            if (casaExibidaId && data.inventarioCasas?.includes(casaExibidaId)) {
                // Se tem uma casa para exibir, busca a imagem dela
                getDoc(doc(db, "loja_casas", casaExibidaId)).then(casaDoc => {
                    if (casaDoc.exists()) {
                        loteContainer.innerHTML = `<img src="${casaDoc.data().imagemURL}" alt="${casaDoc.data().nome}">`;
                    }
                });
            } else {
                // Se n√£o tem casa, mostra a placa de terreno
                loteContainer.innerHTML = `
                    <div class="placa-terreno">
                        <div class="placa-madeira">Voc√™ ainda n√£o comprou uma casa no condom√≠nio √©picos.</div>
                        <div class="haste-madeira"></div>
                    </div>
                `;
            }
        }
    });

    // Atualiza o fundo (sol/lua/nuvens) - copiamos a l√≥gica da √°rvore
    const agora = getHoje();
    const horas = agora.getHours();
    const modoNoite = horas >= 18 || horas < 6;
    const condominioSky = document.querySelector('#condominio-container .tree-sky');
    
    if (condominioSky) {
    if (modoNoite) {
        condominioSky.classList.add("night-mode");
        condominioSky.classList.remove("day-mode");
        // Adicione as linhas abaixo
        criarEstrelas(); // Chama a fun√ß√£o para popular o cont√™iner, se vazio
        const starsCondominio = condominioSky.querySelector('.stars-container');
        if (starsCondominio) starsCondominio.style.opacity = "1";
    } else {
        condominioSky.classList.remove("night-mode");
        condominioSky.classList.add("day-mode");
         // E adicione estas linhas para esconder as estrelas durante o dia
        const starsCondominio = condominioSky.querySelector('.stars-container');
        if (starsCondominio) starsCondominio.style.opacity = "0";
    }
}
    
    document.getElementById('sol-condominio').style.opacity = modoNoite ? "0" : "1";
    document.getElementById('lua-condominio').style.opacity = modoNoite ? "1" : "0";
}

// Adicione estas fun√ß√µes ao seu script

// Abre e popula a loja
async function abrirLoja() {
  const categorias = {
    pequena: document.getElementById('catalogo-pequenas'),
    media: document.getElementById('catalogo-medias'),
    mansao: document.getElementById('catalogo-mansoes'),
  };

  // Limpa os cat√°logos
  for (const key in categorias) {
    categorias[key].innerHTML = '<p>Carregando casas...</p>';
  }

  openModal('loja-modal');

  try {
    const membroDoc = await getDoc(doc(db, "membros", currentUser));
    const moedasAtuais = membroDoc.data().moedas || 0;
    const inventario = membroDoc.data().inventarioCasas || [];

    const casasSnapshot = await getDocs(collection(db, "loja_casas"));
    
    // Limpa novamente para adicionar os cards
    for (const key in categorias) categorias[key].innerHTML = '';

    casasSnapshot.forEach(casaDoc => {
      const casa = { id: casaDoc.id, ...casaDoc.data() };
      const container = categorias[casa.categoria];
      if (!container) return;

      const jaPossui = inventario.includes(casa.id);
      const podeComprar = moedasAtuais >= casa.preco;

      const card = document.createElement('div');
      card.className = 'casa-card';
      card.innerHTML = `
        <div class="casa-card-imagem"><img src="${casa.imagemURL}" alt="${casa.nome}"></div>
        <div class="casa-card-info">
          <div>
            <div class="casa-card-nome">${casa.nome}</div>
            <div class="casa-card-preco">üí∞ ${casa.preco}</div>
          </div>
          <button class="painel-btn btn-adicionar btn-comprar" 
                  onclick="comprarCasa('${casa.id}', ${casa.preco})"
                  ${(jaPossui || !podeComprar) ? 'disabled' : ''}>
            ${jaPossui ? 'J√° Comprada' : 'Comprar'}
          </button>
        </div>
      `;
      container.appendChild(card);
    });

  } catch (error) {
    console.error("Erro ao abrir a loja:", error);
    mostrarPopup("‚ùå Erro", "N√£o foi poss√≠vel carregar a loja.", 4000);
  }
}

// Fun√ß√£o para comprar uma casa (VERS√ÉO ATUALIZADA)
window.comprarCasa = async function(casaId, preco) {
  // Popula o texto din√¢mico do modal
  const textoModal = document.getElementById('confirm-compra-texto');
  textoModal.innerHTML = `Voc√™ tem certeza que deseja comprar esta casa por <strong>üí∞ ${preco} moedas</strong>?`;

  // Define a a√ß√£o do bot√£o "Confirmar"
  const btnConfirmar = document.getElementById('confirm-compra-btn');
  btnConfirmar.onclick = () => executarCompraCasa(casaId, preco);

  // Abre o modal
  openModal('confirm-compra-modal');
}

// Passo 2: A l√≥gica de compra que √© executada ap√≥s a confirma√ß√£o
async function executarCompraCasa(casaId, preco) {
  // Fecha o modal de confirma√ß√£o primeiro
  closeModal('confirm-compra-modal');

  const membroRef = doc(db, "membros", currentUser);
  try {
    await runTransaction(db, async (transaction) => {
      const membroDoc = await transaction.get(membroRef);
      if (!membroDoc.exists()) throw "Membro n√£o encontrado.";

      const dadosMembro = membroDoc.data();
      const moedasAtuais = dadosMembro.moedas || 0;
      if (moedasAtuais < preco) throw "Moedas insuficientes.";
      
      const inventarioAtual = dadosMembro.inventarioCasas || [];
      const ePrimeiraCasa = inventarioAtual.length === 0;

      const atualizacoes = {
        moedas: increment(-preco),
        inventarioCasas: arrayUnion(casaId)
      };

      if (ePrimeiraCasa) {
        atualizacoes.casaExibida = casaId;
      }
      
      transaction.update(membroRef, atualizacoes);
    });

    const casaCompradaRef = doc(db, "loja_casas", casaId);
    const casaDoc = await getDoc(casaCompradaRef);

    if (casaDoc.exists()) {
      const casaData = casaDoc.data();
      const loteContainer = document.getElementById('lote-pessoal-container');
      
      if (loteContainer) {
        loteContainer.innerHTML = `<img src="${casaData.imagemURL}" alt="${casaData.nome}">`;
      }
    }

    mostrarPopup("üéâ Parab√©ns!", "Voc√™ comprou uma nova casa!", 5000);
    dispararConfete();
    abrirLoja();

  } catch (error) {
    console.error("Erro na compra:", error);
    mostrarPopup("‚ùå Falha na Compra", error.toString(), 4000);
  }
}

async function abrirVisaoCondominio() {
  const map = document.getElementById('condominio-map');
  map.innerHTML = '<h2>Carregando condom√≠nio...</h2>';
  document.getElementById('condominio-view-overlay').classList.remove('hidden');

  try {
    // 1. Buscar apenas as casas (pois os membros j√° temos em cache na vari√°vel global)
    const casasSnap = await getDocs(collection(db, "loja_casas"));

    // Usa a vari√°vel global 'todosMembros' que foi carregada no login
    // Mapeia para garantir que o formato seja id: nome (para compatibilidade com o resto da fun√ß√£o)
    const todosMembrosLocal = todosMembros.map(m => ({ id: m.nome, ...m }));

    const todasCasas = {};
    casasSnap.forEach(doc => todasCasas[doc.id] = doc.data());

    // 2. Calcular layout do grid
    const numMembros = todosMembros.length;
    // Um pouco mais largo que alto para um layout agrad√°vel
    const colunas = Math.ceil(Math.sqrt(numMembros) * 1.2); 

    map.innerHTML = ''; // Limpa a mensagem "Carregando..."

    // 3. Gerar os lotes para cada membro
    todosMembros.forEach(membro => {
      const lote = document.createElement('div');
      lote.className = 'lote-condominio';
	  lote.id = `lote-${membro.id}`;

      const casaExibidaId = membro.casaExibida;
      const casaData = (casaExibidaId && todasCasas[casaExibidaId]) ? todasCasas[casaExibidaId] : null;

      // Cria um container para a imagem da casa
      const casaContainer = document.createElement('div');
      casaContainer.className = 'casa-imagem-container';

      if (casaData) {
        // Se o membro tem uma casa, cria a imagem com a classe da categoria
        casaContainer.innerHTML = `
          <img src="${casaData.imagemURL}" 
               class="casa-no-lote ${casaData.categoria}" 
               alt="${casaData.nome}">
        `;
      } else {
        casaContainer.innerHTML = `
  <div class="placa-terreno">
    <div class="placa-madeira">sem casa</div>
    <div class="haste-madeira"></div>
  </div>
`;
      }
      
      // Adiciona o container da casa e a placa de nome ao lote
      lote.appendChild(casaContainer);
      
      const nomeDiv = document.createElement('div');
      nomeDiv.className = 'nome-lote';
      nomeDiv.textContent = membro.id;
	  // ADI√á√ÉO 2: Adicione um ID √∫nico e um evento de clique para a placa
    nomeDiv.id = `nome-lote-${membro.id}`;
    nomeDiv.onclick = (event) => toggleNameplateColorPalette(event, membro.id);

    // ADI√á√ÉO 3: Aplique a cor salva e verifique o contraste
    if (membro.nomeLoteCor) {
        nomeDiv.style.backgroundColor = membro.nomeLoteCor;
        if (isColorDark(membro.nomeLoteCor)) {
            nomeDiv.style.color = '#FFFFFF';
        } else {
            nomeDiv.style.color = '#000000';
        }
    }
      lote.appendChild(nomeDiv);

// ADI√á√ÉO 4: Crie o container da paleta de cores, escondido por padr√£o
    const paletteContainer = document.createElement('div');
    paletteContainer.id = `palette-container-${membro.id}`;
    paletteContainer.className = 'nameplate-palette hidden';
    lote.appendChild(paletteContainer); // Adiciona a paleta ao lote

      map.appendChild(lote);
    });

    // 4. Ativar o arraste (pan) - sem altera√ß√µes aqui
    const wrapper = document.getElementById('condominio-map-wrapper');
    let isDown = false;
    let startX, startY, scrollLeft, scrollTop;

    const startPan = (e) => {
      isDown = true;
      wrapper.classList.add('active');
      const pageX = e.pageX || e.touches[0].pageX;
      const pageY = e.pageY || e.touches[0].pageY;
      startX = pageX - wrapper.offsetLeft;
      startY = pageY - wrapper.offsetTop;
      scrollLeft = wrapper.scrollLeft;
      scrollTop = wrapper.scrollTop;
    };
    
    const endPan = () => {
      isDown = false;
    };

    const movePan = (e) => {
      if (!isDown) return;
      e.preventDefault();
      const pageX = e.pageX || e.touches[0].pageX;
      const pageY = e.pageY || e.touches[0].pageY;
      const x = pageX - wrapper.offsetLeft;
      const y = pageY - wrapper.offsetTop;
      const walkX = (x - startX) * 2;
      const walkY = (y - startY) * 2;
      wrapper.scrollLeft = scrollLeft - walkX;
      wrapper.scrollTop = scrollTop - walkY;
    };

    wrapper.addEventListener('mousedown', startPan);
    wrapper.addEventListener('mouseleave', endPan);
    wrapper.addEventListener('mouseup', endPan);
    wrapper.addEventListener('mousemove', movePan);
    
    wrapper.addEventListener('touchstart', startPan, { passive: true });
    wrapper.addEventListener('touchend', endPan);
    wrapper.addEventListener('touchmove', movePan);

  } catch (error) {
    console.error("Erro ao montar o condom√≠nio:", error);
    map.innerHTML = '<h2>Ocorreu um erro ao carregar o condom√≠nio.</h2>';
  }
}

function formatarDataISO(date) {
    if (!date) return '';
    const ano = date.getFullYear();
    const mes = String(date.getMonth() + 1).padStart(2, '0');
    const dia = String(date.getDate()).padStart(2, '0');
    return `${ano}-${mes}-${dia}`;
  }
  
  // NOVA FUN√á√ÉO: Limpa manualmente o feed da semana (chamada pelo bot√£o do l√≠der)
async function limparFeedManualmente() {
  if (!confirm("‚ö†Ô∏è ATEN√á√ÉO!\n\nVoc√™ est√° prestes a apagar TODOS os eventos do feed da semana.\n\nDeseja continuar?")) return;

  try {
    const feedRef = collection(db, "resumoSemanalFeed");
    const querySnapshot = await getDocs(feedRef);

    if (querySnapshot.empty) {
      mostrarPopup("‚ÑπÔ∏è Informa√ß√£o", "O feed da semana j√° est√° limpo.", 3000);
      return;
    }

    const batch = writeBatch(db);
    querySnapshot.forEach(doc => {
      batch.delete(doc.ref);
    });
    await batch.commit();

    mostrarPopup("‚úÖ Sucesso", `Todos os ${querySnapshot.size} eventos do feed foram apagados.`, 5000);
  } catch (error) {
    console.error("Erro ao limpar feed manualmente:", error);
    mostrarPopup("‚ùå Erro", "Ocorreu uma falha ao tentar limpar o feed.", 4000);
  }
}

// NOVA FUN√á√ÉO: Limpa manualmente o mural de mensagens (chamada pelo bot√£o do l√≠der)
async function limparMuralManualmente() {
  if (!confirm("‚ö†Ô∏è ATEN√á√ÉO!\n\nVoc√™ est√° prestes a apagar TODAS as mensagens do mural.\n\nEsta a√ß√£o √© permanente. Deseja continuar?")) return;

  try {
    const muralRef = collection(db, "mural");
    const querySnapshot = await getDocs(muralRef);

    if (querySnapshot.empty) {
      mostrarPopup("‚ÑπÔ∏è Informa√ß√£o", "O mural de mensagens j√° est√° vazio.", 3000);
      return;
    }

    const batch = writeBatch(db);
    querySnapshot.forEach(doc => {
      batch.delete(doc.ref);
    });
    await batch.commit();

    mostrarPopup("‚úÖ Sucesso", `Todas as ${querySnapshot.size} mensagens do mural foram apagadas.`, 5000);
  } catch (error) {
    console.error("Erro ao limpar mural manualmente:", error);
    mostrarPopup("‚ùå Erro", "Ocorreu uma falha ao tentar limpar o mural.", 4000);
  }
}

// Fun√ß√£o para ABRIR e popular o invent√°rio
async function abrirInventario() {
  const inventarioGrid = document.getElementById('inventario-grid');
  inventarioGrid.innerHTML = '<p>Carregando seu invent√°rio...</p>';
  openModal('inventario-modal');

  try {
    // Busca apenas as casas da loja
    const casasSnapshot = await getDocs(collection(db, "loja_casas"));

    // Pega os dados do membro da vari√°vel global
    const dadosMembro = todosMembros.find(m => m.nome === currentUser);

    if (!dadosMembro) throw "Dados do membro n√£o encontrados no cache.";
    const inventarioIds = dadosMembro.inventarioCasas || [];
    const casaPrincipalId = dadosMembro.casaExibida;

    // Cria um mapa de todas as casas da loja para f√°cil acesso
    const todasCasas = {};
    casasSnapshot.forEach(doc => {
      todasCasas[doc.id] = { id: doc.id, ...doc.data() };
    });

    inventarioGrid.innerHTML = ''; // Limpa o "Carregando..."

    if (inventarioIds.length === 0) {
      inventarioGrid.innerHTML = '<p style="text-align: center; font-style: italic;">Voc√™ ainda n√£o comprou nenhuma casa. Visite a loja!</p>';
      return;
    }

    // Cria um card para cada casa que o membro possui
    inventarioIds.forEach(casaId => {
      const casa = todasCasas[casaId];
      if (!casa) return; // Pula se a casa n√£o existir mais na loja

      const ePrincipal = casa.id === casaPrincipalId;

      const card = document.createElement('div');
      card.className = 'casa-card';
      if (ePrincipal) {
        card.classList.add('selecionada'); // Adiciona classe de destaque
      }

      card.innerHTML = `
        <div class="casa-card-imagem"><img src="${casa.imagemURL}" alt="${casa.nome}"></div>
        <div class="casa-card-info">
          <div>
            <div class="casa-card-nome">${casa.nome}</div>
          </div>
          <button class="painel-btn btn-adicionar btn-definir-principal" 
                  onclick="definirCasaPrincipal('${casa.id}')"
                  ${ePrincipal ? 'disabled' : ''}>
            ${ePrincipal ? 'Principal' : 'Exibir esta'}
          </button>
        </div>
      `;
      inventarioGrid.appendChild(card);
    });

  } catch (error) {
    console.error("Erro ao abrir o invent√°rio:", error);
    mostrarPopup("‚ùå Erro", "N√£o foi poss√≠vel carregar seu invent√°rio.", 4000);
    closeModal('inventario-modal');
  }
}

// Fun√ß√£o para ATUALIZAR a casa principal no Firestore
window.definirCasaPrincipal = async function(casaId) {
  const membroRef = doc(db, "membros", currentUser);
  try {
    // Atualiza apenas o campo 'casaExibida'
    await updateDoc(membroRef, {
      casaExibida: casaId
    });

    mostrarPopup("‚úÖ Sucesso!", "Sua casa principal foi atualizada.", 3000);
	
	await carregarCondominioEpicos();
	
    closeModal('inventario-modal'); 
    // A atualiza√ß√£o na tela principal ser√° autom√°tica gra√ßas ao listener 'onSnapshot'
    // que j√° existe na fun√ß√£o carregarCondominioEpicos.

  } catch (error) {
    console.error("Erro ao definir casa principal:", error);
    mostrarPopup("‚ùå Erro", "N√£o foi poss√≠vel salvar sua escolha.", 4000);
  }
}

// NOVA FUN√á√ÉO: Mostra ou esconde a paleta de cores da placa
function toggleNameplateColorPalette(event, membroId) {
  event.stopPropagation(); // Impede que o clique se propague para o mapa

  // Verifica a permiss√£o do usu√°rio
  if (currentUser !== membroId && userRole !== 'lider') {
    mostrarPopup("üö´ Acesso Negado", "Voc√™ s√≥ pode alterar a cor da sua pr√≥pria placa.", 3000);
    return;
  }

  const palette = document.getElementById(`palette-container-${membroId}`);
  const isHidden = palette.classList.contains('hidden');

  // Fecha todas as outras paletas abertas
  document.querySelectorAll('.nameplate-palette').forEach(p => p.classList.add('hidden'));

  // Se a paleta estava escondida, cria e mostra
  if (isHidden) {
    createNameplateColorPalette(membroId);
    palette.classList.remove('hidden');
  }
}

// NOVA FUN√á√ÉO: Gera as cores dentro da paleta
function createNameplateColorPalette(membroId) {
  const paletteContainer = document.getElementById(`palette-container-${membroId}`);
  if (!paletteContainer || paletteContainer.innerHTML !== '') return; // N√£o recria se j√° existir

  const cores = [
    // Tons Past√©is e Claros
    '#FFFFFF', '#FADADD', '#FFD6A5', '#FDFFB6', '#CAFFBF', '#9BF6FF', 
    '#A0C4FF', '#BDB2FF', '#FFC6FF', '#EAE4E9', '#D4E09B', '#C3E0E5',
    '#F7D6E0', '#F3E9DD', '#D3E4CD',
    // Tons Vibrantes e Saturados
    '#FF1744', '#F50057', '#D500F9', '#651FFF', '#3D5AFE', '#2979FF',
    '#00B0FF', '#00E5FF', '#1DE9B6', '#00E676', '#76FF03', '#C6FF00',
    '#FFEA00', '#FFC400', '#FF9100', '#FF3D00',
    // Tons S√≥brios e Escuros
    '#F38375', '#FBC42C', '#57C479', '#57C5C8', '#578DC8', '#8A57C8',
    '#C857B2', '#4B4A49', '#ACACAC', '#795548', '#607D8B', '#000000',
    // Paleta Adicional
    '#E57373', '#BA68C8', '#7986CB', '#4FC3F7', '#4DB6AC', '#AED581',
    '#FFF176', '#FFB74D', '#A1887F', '#90A4AE', '#008F93', '#F08080',
    '#20B2AA', '#87CEEB', '#9370DB', '#DA70D6'
  ];

  cores.forEach(cor => {
    const corEl = document.createElement('div');
    corEl.className = 'nameplate-color-option';
    corEl.style.backgroundColor = cor;
    corEl.onclick = (event) => selectNameplateColor(event, membroId, cor);
    paletteContainer.appendChild(corEl);
  });
}

// NOVA FUN√á√ÉO: Seleciona uma cor, atualiza a interface e salva no banco de dados
async function selectNameplateColor(event, membroId, cor) {
  event.stopPropagation();

  const nameplate = document.getElementById(`nome-lote-${membroId}`);
  const palette = document.getElementById(`palette-container-${membroId}`);

  // Atualiza a cor na interface imediatamente
  nameplate.style.backgroundColor = cor;
  if (isColorDark(cor)) {
    nameplate.style.color = '#FFFFFF';
  } else {
    nameplate.style.color = '#000000';
  }

  // Fecha a paleta
  palette.classList.add('hidden');

  try {
    const membroRef = doc(db, "membros", membroId);
    // Salva a nova cor no Firestore
    await updateDoc(membroRef, {
      nomeLoteCor: cor
    });
    mostrarPopup("üé® Sucesso", "A cor da sua placa foi alterada!", 2000);
  } catch (error) {
    console.error("Erro ao salvar a cor da placa:", error);
    mostrarPopup("‚ùå Erro", "N√£o foi poss√≠vel salvar a nova cor.", 3000);
  }
}

// NOVA FUN√á√ÉO: Encontra a casa do usu√°rio e centraliza a tela nela
// Fun√ß√£o Corrigida
function findMyHouse() {
  if (!currentUser) return;

  const userLot = document.getElementById(`lote-${currentUser}`);
  const wrapper = document.getElementById('condominio-map-wrapper');

  if (userLot && wrapper) {
    // Posi√ß√£o do lote do usu√°rio dentro do mapa
    const lotTop = userLot.offsetTop;
    const lotLeft = userLot.offsetLeft;

    // Dimens√µes do lote e da √°rea vis√≠vel (wrapper)
    const lotHeight = userLot.clientHeight;
    const lotWidth = userLot.clientWidth;
    const wrapperHeight = wrapper.clientHeight;
    const wrapperWidth = wrapper.clientWidth;

    // Calcula a posi√ß√£o de rolagem para centralizar o lote
    const scrollTop = lotTop - (wrapperHeight / 2) + (lotHeight / 2);
    const scrollLeft = lotLeft - (wrapperWidth / 2) + (lotWidth / 2);

    // Executa a rolagem suave para a posi√ß√£o calculada
    wrapper.scrollTo({
      top: scrollTop,
      left: scrollLeft,
      behavior: 'smooth'
    });

    // Adiciona um destaque tempor√°rio para o lote
    userLot.classList.add('highlight');
    setTimeout(() => {
      userLot.classList.remove('highlight');
    }, 2500);
  } else {
    mostrarPopup("ü§î Hmm...", "N√£o conseguimos encontrar seu lote no mapa.", 3000);
  }
}
window.findMyHouse = findMyHouse;

// NOVA FUN√á√ÉO: Apaga os documentos de vantagem de semanas passadas
async function limparVantagensAntigas() {
  try {
    const semanaAtual = getSemanaAtual();
    // Cria o ID do documento da semana atual para compara√ß√£o
    const idSemanaAtual = `semana_${semanaAtual.numero}_${semanaAtual.inicio.getFullYear()}`;

    const vantagensRef = collection(db, "vantagemSemanal");
    const querySnapshot = await getDocs(vantagensRef);

    if (querySnapshot.empty) {
      console.log("Nenhum documento de vantagem encontrado para limpar.");
      return;
    }

    const batch = writeBatch(db);
    let documentosApagados = 0;

    querySnapshot.forEach(doc => {
      // Se o ID do documento for DIFERENTE do ID da semana atual, ele √© antigo
      if (doc.id !== idSemanaAtual) {
        console.log(`Marcando para apagar documento de vantagem antigo: ${doc.id}`);
        batch.delete(doc.ref);
        documentosApagados++;
      }
    });

    if (documentosApagados > 0) {
      await batch.commit();
      console.log(`‚úÖ Limpeza conclu√≠da: ${documentosApagados} documento(s) de vantagem antigos foram removidos.`);
    } else {
      console.log("Nenhum documento de vantagem antigo para apagar nesta verifica√ß√£o.");
    }
  } catch (error) {
    console.error("Erro ao limpar a cole√ß√£o 'vantagemSemanal':", error);
  }
}

// =============================================
// ===== NOVA FUN√á√ÉO DE LIMPEZA SEMANAL ======
// =============================================

// NOVA FUN√á√ÉO: Apaga os documentos de gerenciamento de semanas passadas.
async function limparGerenciamentoSemanalAntigo() {
  console.log("üßπ Verificando registros de gerenciamento semanal antigos...");
  try {
    // Pega a semana que acabou de terminar, pois seus dados ainda podem ser relevantes no domingo.
    const hoje = new Date();
    const semanaPassada = getSemanaAtual(new Date(hoje.getTime() - (24 * 60 * 60 * 1000)));
    const idSemanaPassada = `semana_${semanaPassada.numero}_${semanaPassada.inicio.getFullYear()}`;

    const gerenciamentoRef = collection(db, "gerenciamentoSemanal");
    const querySnapshot = await getDocs(gerenciamentoRef);

    if (querySnapshot.empty) {
      console.log("Nenhum documento de gerenciamento semanal encontrado para limpar.");
      return;
    }

    const batch = writeBatch(db);
    let documentosApagados = 0;

    querySnapshot.forEach(doc => {
      // Apaga qualquer documento que N√ÉO seja o da semana que acabou de passar.
      if (doc.id !== idSemanaPassada) {
        console.log(`Marcando para apagar documento de gerenciamento antigo: ${doc.id}`);
        batch.delete(doc.ref);
        documentosApagados++;
      }
    });

    if (documentosApagados > 0) {
      await batch.commit();
      console.log(`‚úÖ Limpeza conclu√≠da: ${documentosApagados} registro(s) de gerenciamento antigos foram removidos.`);
    } else {
      console.log("Nenhum registro de gerenciamento antigo para apagar nesta verifica√ß√£o.");
    }
  } catch (error) {
    console.error("Erro ao limpar a cole√ß√£o 'gerenciamentoSemanal':", error);
  }
}

// NOVA FUN√á√ÉO: Apaga os documentos de presen√ßa de semanas passadas
async function limparPresencasAntigas() {
  try {
    const semanaAtual = getSemanaAtual();
    // Pega a data de in√≠cio da semana atual no formato ISO (ex: "2024-05-13")
    const inicioSemanaISO = formatarDataISO(semanaAtual.inicio);

    // Cria uma consulta que busca todos os documentos cujo ID (a data)
    // seja MENOR que o in√≠cio da semana atual.
    const q = query(collection(db, "presencas"), where('__name__', '<', inicioSemanaISO));
    const querySnapshot = await getDocs(q);

    if (querySnapshot.empty) {
      console.log("Nenhum documento de presen√ßa antigo encontrado para limpar.");
      return;
    }

    const batch = writeBatch(db);
    let documentosApagados = 0;

    querySnapshot.forEach(doc => {
      console.log(`Marcando para apagar documento de presen√ßa antigo: ${doc.id}`);
      batch.delete(doc.ref);
      documentosApagados++;
    });

    if (documentosApagados > 0) {
      await batch.commit();
      console.log(`‚úÖ Limpeza conclu√≠da: ${documentosApagados} registro(s) de presen√ßa antigos foram removidos.`);
    }

  } catch (error) {
    console.error("Erro ao limpar a cole√ß√£o 'presencas':", error);
  }
}

// ADICIONE ESTA NOVA FUN√á√ÉO AO SEU JAVASCRIPT

async function carregarRankingImobiliario() {
  openModal('ranking-imobiliario-modal');

  const rankingMaisCasasLista = document.getElementById('ranking-mais-casas-lista');
  const rankingMaiorValorLista = document.getElementById('ranking-maior-valor-lista');
  rankingMaisCasasLista.innerHTML = '<p>Calculando...</p>';
  rankingMaiorValorLista.innerHTML = '<p>Calculando...</p>';

  try {
    // Buscamos apenas as casas (para saber os pre√ßos)
    const casasSnap = await getDocs(collection(db, "loja_casas"));

    const precosCasas = {};
    casasSnap.forEach(doc => {
      precosCasas[doc.id] = doc.data().preco || 0;
    });

    let dadosRanking = [];
    
    // Usamos a vari√°vel global 'todosMembros' em vez de 'membrosSnap'
    todosMembros.forEach(membro => {
      const inventario = membro.inventarioCasas || [];

      if (inventario.length > 0) {
        const quantidadeCasas = inventario.length;
        const valorTotal = inventario.reduce((soma, casaId) => soma + (precosCasas[casaId] || 0), 0);
        
        dadosRanking.push({
          nome: membro.nome, // No objeto global o ID √© 'nome'
          quantidadeCasas: quantidadeCasas,
          valorTotal: valorTotal
        });
      }
    });

    if (dadosRanking.length === 0) {
      const msg = '<p style="font-style: italic; text-align: center;">Ningu√©m comprou uma casa ainda.</p>';
      rankingMaisCasasLista.innerHTML = msg;
      rankingMaiorValorLista.innerHTML = msg;
      return;
    }

    // Gerar Ranking "Mais Casas"
    const rankingCasas = [...dadosRanking].sort((a, b) => b.quantidadeCasas - a.quantidadeCasas);
    rankingMaisCasasLista.innerHTML = '';
    rankingCasas.forEach((membro, index) => {
      const posicao = index + 1;
      let emoji = `${posicao}¬∫`;
      if (posicao === 1) emoji = 'ü•á';
      if (posicao === 2) emoji = 'ü•à';
      if (posicao === 3) emoji = 'ü•â';

      const itemEl = document.createElement('div');
      itemEl.className = 'ranking-imobiliario-item';
      itemEl.innerHTML = `
        <span class="posicao">${emoji}</span>
        <span class="nome">${membro.nome}</span>
        <span class="valor">üè† ${membro.quantidadeCasas}</span>
      `;
      rankingMaisCasasLista.appendChild(itemEl);
    });

    // Gerar Ranking "Maior Valor de Mercado"
    const rankingValor = [...dadosRanking].sort((a, b) => b.valorTotal - a.valorTotal);
    rankingMaiorValorLista.innerHTML = '';
    rankingValor.forEach((membro, index) => {
      const posicao = index + 1;
      let emoji = `${posicao}¬∫`;
      if (posicao === 1) emoji = 'ü•á';
      if (posicao === 2) emoji = 'ü•à';
      if (posicao === 3) emoji = 'ü•â';

      const itemEl = document.createElement('div');
      itemEl.className = 'ranking-imobiliario-item';
      itemEl.innerHTML = `
        <span class="posicao">${emoji}</span>
        <span class="nome">${membro.nome}</span>
        <span class="valor">üí∞ ${membro.valorTotal.toLocaleString('pt-BR')}</span>
      `;
      rankingMaiorValorLista.appendChild(itemEl);
    });

  } catch (error) {
    console.error("Erro ao carregar ranking imobili√°rio:", error);
    rankingMaisCasasLista.innerHTML = '<p>Erro ao carregar.</p>';
    rankingMaiorValorLista.innerHTML = '<p>Erro ao carregar.</p>';
  }
}

// NOVA FUN√á√ÉO: Carrega as configura√ß√µes de recompensas do Firestore
async function carregarConfiguracoesRecompensas() {
  try {
    const docRef = doc(db, "configuracoes", "recompensas");
    const docSnap = await getDoc(docRef);
    if (docSnap.exists()) {
      recompensasConfig = docSnap.data();
      console.log("Configura√ß√µes de recompensas carregadas:", recompensasConfig);
    } else {
      // Fallback com valores padr√£o caso o documento n√£o exista
      console.warn("Documento de recompensas n√£o encontrado! Usando valores padr√£o.");
      recompensasConfig = { focoDiario: 100, postarMural: 5, reagirConteudo: 1, vitoriaJogoVantagem: 50, top5Diario_1: 25, top5Diario_2: 20, top5Diario_3: 15, top5Diario_4: 10, top5Diario_5: 5, top5Vantagem_1: 50, top5Vantagem_2: 40, top5Vantagem_3: 30, top5Vantagem_4: 20, top5Vantagem_5: 10, vitoriaSemanal: 500 };
    }
  } catch (error) {
    console.error("Erro ao carregar configura√ß√µes de recompensas:", error);
  }
}

// NOVA FUN√á√ÉO: Popula o modal de recompensas com os valores carregados
function popularModalRecompensas() {
  // Itera sobre todas as chaves de configura√ß√£o de recompensas
  for (const key in recompensasConfig) {
    const spanElement = document.getElementById(`reward-${key}`);
    if (spanElement) {
      spanElement.textContent = recompensasConfig[key];
    }
  }

  // L√≥gica de visibilidade dos bot√µes de edi√ß√£o
  if (userRole === 'lider') {
    // Se o usu√°rio √© o l√≠der, REMOVE a classe 'hidden' para mostrar os bot√µes.
    document.querySelectorAll('.edit-reward-btn').forEach(btn => {
      btn.classList.remove('hidden');
    });
  } else {
    // Se N√ÉO for o l√≠der, ADICIONA a classe 'hidden' para garantir que fiquem escondidos.
    document.querySelectorAll('.edit-reward-btn').forEach(btn => {
      btn.classList.add('hidden');
    });
  }
}

// NOVA FUN√á√ÉO: Lida com o clique para iniciar a edi√ß√£o
function handleRewardEditClick(event) {
  if (event.target.classList.contains('edit-reward-btn')) {
    const key = event.target.dataset.key;
    iniciarEdicaoRecompensa(key);
  }
}

// NOVA FUN√á√ÉO: Ativa o modo de edi√ß√£o para um valor de recompensa
function iniciarEdicaoRecompensa(key) {
  const spanElement = document.getElementById(`reward-${key}`);
  if (!spanElement || spanElement.isContentEditable) return; // Previne re-edi√ß√£o

  const valorOriginal = spanElement.textContent;
  spanElement.contentEditable = true;
  spanElement.classList.add('editing');
  spanElement.focus();
  document.execCommand('selectAll', false, null); // Seleciona o texto

  const salvarEdicao = async () => {
    spanElement.contentEditable = false;
    spanElement.classList.remove('editing');
    spanElement.removeEventListener('blur', salvarEdicao);
    spanElement.removeEventListener('keydown', lidarComTeclas);

    const novoValorStr = spanElement.textContent.trim();
    const novoValor = parseInt(novoValorStr, 10);

    if (isNaN(novoValor) || novoValor < 0) {
      mostrarPopup("‚ùå Erro", "Por favor, insira um n√∫mero v√°lido.", 3000);
      spanElement.textContent = valorOriginal; // Restaura valor
      return;
    }

    if (novoValor.toString() === valorOriginal) return; // N√£o salva se n√£o houver mudan√ßa

    try {
      const configRef = doc(db, "configuracoes", "recompensas");
      await updateDoc(configRef, { [key]: novoValor });

      recompensasConfig[key] = novoValor; // Atualiza o objeto local
      mostrarPopup("‚úÖ Sucesso", "Valor da recompensa atualizado!", 3000);
    } catch (error) {
      console.error("Erro ao salvar recompensa:", error);
      mostrarPopup("‚ùå Erro", "Falha ao salvar. Tente novamente.", 4000);
      spanElement.textContent = valorOriginal; // Restaura em caso de erro
    }
  };

  const lidarComTeclas = (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      salvarEdicao();
    } else if (e.key === 'Escape') {
      spanElement.textContent = valorOriginal;
      salvarEdicao();
    }
  };

  spanElement.addEventListener('blur', salvarEdicao);
  spanElement.addEventListener('keydown', lidarComTeclas);
}

// NOVA FUN√á√ÉO: Atualiza o painel pessoal com as informa√ß√µes do usu√°rio
async function atualizarPainelPessoal() {
  const painel = document.getElementById('painel-pessoal-container');
  const saudacaoEl = document.getElementById('saudacao-pessoal');
  const botaoPainel = document.getElementById('botao-painel-usuario');
  const indicadorEquipeEl = document.getElementById('indicador-equipe-pessoal');

  if (!painel || !currentUser) return;

  // Exibe o painel
  painel.classList.remove('hidden');
  
  const avatarContainer = document.getElementById('avatar-display-pessoal');
  if (avatarContainer) {
    avatarContainer.innerHTML = ''; // Limpa o conte√∫do anterior
    await renderizarAvatar(currentUser, avatarContainer);
    avatarContainer.onclick = () => abrirEditorAvatar();
  }

  // 1. Atualiza a sauda√ß√£o
  saudacaoEl.innerHTML = `Ol√°, <span id="nome-usuario-saudacao">${currentUser}</span>!`;

  // Mostra o bot√£o do Painel do Usu√°rio para todos
botaoPainel.classList.remove('hidden');

  // 3. Atualiza o indicador da equipe
  if (userTeam) {
    const nomeEquipeCapitalizado = userTeam.charAt(0).toUpperCase() + userTeam.slice(1);
    indicadorEquipeEl.textContent = `Equipe ${nomeEquipeCapitalizado}`;
    
    // Limpa classes de cor antigas e adiciona a nova
    indicadorEquipeEl.classList.remove('abelha', 'joaninha', 'vagalume', 'sem-equipe');
    indicadorEquipeEl.classList.add(userTeam);
    indicadorEquipeEl.classList.remove('hidden');
  } else {
    // NOVO: L√≥gica para quem n√£o tem equipe
    indicadorEquipeEl.textContent = `Membro sem equipe`;
    indicadorEquipeEl.classList.remove('abelha', 'joaninha', 'vagalume');
    indicadorEquipeEl.classList.add('sem-equipe'); // Adiciona a classe para o estilo azul
    indicadorEquipeEl.classList.remove('hidden'); // Garante que seja exibido
  }
  
  // L√≥gica de visibilidade dos bot√µes de administrador
const btnPainelControle = document.getElementById('btn-abrir-painel-controle');
const btnGeradorCodigo = document.getElementById('btn-abrir-gerador-codigo');

if (btnPainelControle) {
  // Mostra o Painel de Controle para L√çDER GERAL e L√çDER DE EQUIPE
  if (userRole === 'lider' || userRole === 'lider-equipe') {
    btnPainelControle.classList.remove('hidden');
  } else {
    btnPainelControle.classList.add('hidden');
  }
}

if (btnGeradorCodigo) {
  // Mostra o Gerador de C√≥digos APENAS para o L√çDER GERAL
  if (userRole === 'lider') {
    btnGeradorCodigo.classList.remove('hidden');
  } else {
    btnGeradorCodigo.classList.add('hidden');
  }
}

const btnAddAvatarItem = document.getElementById('btn-abrir-add-avatar-item');
  if (btnAddAvatarItem) {
    // Mostra o bot√£o de Adicionar Item APENAS para o L√çDER GERAL
    if (userRole === 'lider') {
      btnAddAvatarItem.classList.remove('hidden');
    } else {
      btnAddAvatarItem.classList.add('hidden');
    }
  }
  
}

// =============================================
// L√ìGICA DO C√ìDIGO SECRETO (GERA√á√ÉO E RESGATE)
// =============================================

// Fun√ß√£o para o l√≠der abrir o gerador de c√≥digos
function abrirGeradorDeCodigos() {
  closeModal('user-panel-modal');
  document.getElementById('code-coin-value').value = '';
  document.getElementById('generated-code-result').classList.add('hidden');
  openModal('code-generator-modal');
}

// Fun√ß√£o para gerar um c√≥digo aleat√≥rio de 6 caracteres
function gerarCodigoAleatorio() {
  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  let result = '';
  for (let i = 0; i < 6; i++) {
    result += chars.charAt(Math.floor(Math.random() * chars.length));
  }
  return result;
}

// Fun√ß√£o que executa a gera√ß√£o do c√≥digo (lado do l√≠der)
async function handleGenerateCode() {
  const coinValueInput = document.getElementById('code-coin-value');
  const coinValue = parseInt(coinValueInput.value, 10);
  // NOVO: L√™ o estado da checkbox de restri√ß√£o
  const restrictLeaders = document.getElementById('code-restrict-leaders-single').checked;

  if (isNaN(coinValue) || coinValue <= 0) {
    mostrarPopup("‚ùå Erro", "Por favor, insira um valor de moedas v√°lido e positivo.", 4000);
    return;
  }

  const newCode = gerarCodigoAleatorio();
  const codigosRef = doc(db, "configuracoes", "codigos");

  // NOVO: Cria um objeto para armazenar os dados do c√≥digo
  const codeData = {
    valor: coinValue,
    liderPodeResgatar: !restrictLeaders // Salva 'false' se a caixa estiver marcada
  };

  try {
    // Salva o objeto codeData em vez de apenas o valor
    await setDoc(codigosRef, { [newCode]: codeData }, { merge: true });

    // Mostra o resultado para o l√≠der (sem altera√ß√£o aqui)
    document.getElementById('generated-code-display').textContent = newCode;
    document.getElementById('generated-code-result').classList.remove('hidden');
    mostrarPopup("‚úÖ Sucesso!", `C√≥digo "${newCode}" gerado com sucesso!`, 3000);

  } catch (error) {
    console.error("Erro ao gerar c√≥digo:", error);
    mostrarPopup("‚ùå Erro", "N√£o foi poss√≠vel salvar o novo c√≥digo no banco de dados.", 5000);
  }
}

// =============================================
// ===== FUN√á√ÉO ATUALIZADA: GERAR IMAGEM DE LOGIN =====
// =============================================
async function gerarImagemLogin(username, password, genero = 'indefinido') {
  const cardElement = document.createElement('div');
  cardElement.className = 'login-card-image';

  const bodyClass = document.body.className;
  if (bodyClass.includes('tema-manha')) {
    cardElement.classList.add('login-card-manha');
  } else if (bodyClass.includes('tema-tarde')) {
    cardElement.classList.add('login-card-tarde');
  } else if (bodyClass.includes('tema-noite')) {
    cardElement.classList.add('login-card-noite');
  } else {
    cardElement.classList.add('login-card-tarde');
  }
  
  // L√≥gica de G√™nero para o Texto da Imagem
  let textoBoasVindas = "Seja muito bem-vindo(a)!";
  if (genero === 'masculino') {
      textoBoasVindas = "Seja muito bem-vindo!";
  } else if (genero === 'feminino') {
      textoBoasVindas = "Seja muito bem-vinda!";
  }
  
  cardElement.innerHTML = `
    <h3 class="login-card-titulo">√âpicos ‰∫ó üå±</h3>
    <p class="login-card-subtitulo">${textoBoasVindas}</p>
    <div class="login-card-dados">
      <div>
        <strong>Usu√°rio:</strong>
        <span>${username}</span>
      </div>
      <div>
        <strong>Senha Provis√≥ria:</strong>
        <span>${password}</span>
      </div>
    </div>
    <p class="login-card-aviso">
      Anote seus dados. Voc√™ precisar√° criar uma senha definitiva no primeiro acesso.
    </p>
  `;

  document.body.appendChild(cardElement);

  await html2canvas(cardElement, {
    scale: 2,
    useCORS: true
  }).then(canvas => {
    const imageDataUrl = canvas.toDataURL('image/png');
    const container = document.getElementById('generated-login-card-container');
    const downloadBtn = document.getElementById('download-login-card-btn');
    
    container.innerHTML = `<img src="${imageDataUrl}" alt="Dados de Login">`;
    
    downloadBtn.onclick = () => {
      const link = document.createElement('a');
      link.download = `login-epicos-${username}.png`;
      link.href = imageDataUrl;
      link.click();
    };
  });

  document.body.removeChild(cardElement);
}

// FUN√á√ÉO DE RESGATE ATUALIZADA (CORRIGIDA)
async function handleRedeemCode() {
  const input = document.getElementById('secret-code-input');
  const codeToRedeem = input.value.trim().toUpperCase();

  if (codeToRedeem.length !== 6) {
    mostrarPopup("ü§î Aten√ß√£o", "O c√≥digo precisa ter exatamente 6 caracteres.", 3000);
    return;
  }

  const codigosRef = doc(db, "configuracoes", "codigos");
  const membroRef = doc(db, "membros", currentUser);

  try {
    const valorGanho = await runTransaction(db, async (transaction) => {
      const codigosDoc = await transaction.get(codigosRef);
      if (!codigosDoc.exists()) {
        throw "Nenhum c√≥digo secreto foi gerado ainda.";
      }

      const allCodes = codigosDoc.data();
      const codeData = allCodes[codeToRedeem];

      if (!codeData) {
        throw "C√≥digo inv√°lido ou j√° utilizado.";
      }

      // --- IN√çCIO DA NOVA L√ìGICA DE RESTRI√á√ÉO PARA L√çDERES ---
      // Verificamos se a propriedade liderPodeResgatar est√° definida como false
      // E se o usu√°rio que est√° resgatando √© um l√≠der de equipe.
      if (codeData.liderPodeResgatar === false && userRole === 'lider-equipe') {
        throw "L√≠deres de equipe n√£o podem resgatar este c√≥digo.";
      }
      // --- FIM DA NOVA L√ìGICA DE RESTRI√á√ÉO ---

      const coinValue = codeData.valor; // Agora sempre lemos de 'valor'
      const loteId = codeData.loteId;

      if (loteId) {
        const membroDoc = await transaction.get(membroRef);
        const lotesResgatados = membroDoc.data().lotesResgatados || [];

        if (lotesResgatados.includes(loteId)) {
          throw "Voc√™ j√° utilizou um dos c√≥digos deste lote.";
        }
        
        transaction.update(membroRef, {
          moedas: increment(coinValue),
          lotesResgatados: arrayUnion(loteId)
        });

      } else {
        transaction.update(membroRef, { moedas: increment(coinValue) });
      }

      transaction.update(codigosRef, { [codeToRedeem]: deleteField() });

      return coinValue;
    });

    mostrarPopup("üéâ Recompensa Resgatada!", `Voc√™ ganhou <strong>${valorGanho} üí∞ moedas</strong>!`, 5000);
    dispararConfete();
    input.value = '';

  } catch (error) {
    console.error("Erro ao resgatar c√≥digo:", error);
    mostrarPopup("‚ùå Falha no Resgate", error.toString(), 4000);
  }
}

// NOVA FUN√á√ÉO: Gera c√≥digos em lote
async function handleGenerateBatchCode() {
  const quantityInput = document.getElementById('batch-code-quantity');
  const valueInput = document.getElementById('batch-code-value');
  const resultContainer = document.getElementById('generated-batch-result');
  const resultTextarea = document.getElementById('batch-codes-result-display');
  // NOVO: L√™ o estado da checkbox de restri√ß√£o do lote
  const restrictLeaders = document.getElementById('code-restrict-leaders-batch').checked;

  const quantity = parseInt(quantityInput.value, 10);
  const coinValue = parseInt(valueInput.value, 10);

  if (isNaN(quantity) || quantity <= 0 || isNaN(coinValue) || coinValue <= 0) {
    mostrarPopup("‚ùå Erro", "Por favor, preencha a quantidade e o valor com n√∫meros v√°lidos.", 4000);
    return;
  }

  const batchId = `lote-${Date.now()}`;
  const codigosRef = doc(db, "configuracoes", "codigos");
  const generatedCodes = [];
  const batch = writeBatch(db);

  for (let i = 0; i < quantity; i++) {
    const newCode = gerarCodigoAleatorio();
    generatedCodes.push(newCode);

    // NOVO: Adiciona a flag de restri√ß√£o ao objeto do c√≥digo
    const codeData = {
      valor: coinValue,
      loteId: batchId,
      liderPodeResgatar: !restrictLeaders // Salva 'false' se a caixa estiver marcada
    };

    batch.set(codigosRef, { [newCode]: codeData }, { merge: true });
  }

  try {
    await batch.commit();

    resultTextarea.value = generatedCodes.join('\n');
    resultContainer.classList.remove('hidden');
    mostrarPopup("‚úÖ Sucesso!", `${quantity} c√≥digos foram gerados no lote!`, 4000);

  } catch (error) {
    console.error("Erro ao gerar lote de c√≥digos:", error);
    mostrarPopup("‚ùå Erro", "N√£o foi poss√≠vel salvar o lote de c√≥digos.", 5000);
  }
}

async function exibirPopupResultadoCompeticao() {
    const hoje = getHoje();
    if (hoje.getDay() !== 0) return;

    // Pega a semana que acabou de terminar (a de ontem, s√°bado)
    const semanaPassada = getSemanaAtual(new Date(hoje.getTime() - (24 * 60 * 60 * 1000)));
    const semanaId = `semana_${semanaPassada.numero}_${semanaPassada.inicio.getFullYear()}`;

    const resultadoRef = doc(db, "resultadosCompeticao", semanaId);

    try {
        const docSnap = await getDoc(resultadoRef);
        if (!docSnap.exists()) {
            console.log("Documento de resultado da semana passada ainda n√£o foi gerado.");
            return;
        }

        const dados = docSnap.data();
        
        // =======================================================
        // ===== IN√çCIO DA ALTERA√á√ÉO (PASSO 3.2) =====
        // =======================================================
        // L√™ a an√°lise salva no documento do Firestore
        const analiseSalva = dados.analiseOraculo;
        // =======================================================
        // ===== FIM DA ALTERA√á√ÉO =====
        // =======================================================
        
        const rankingDiv = document.getElementById('resumo-competicao-ranking');
        
        // =======================================================
        // ===== CORRE√á√ÉO PRINCIPAL EST√Å AQUI =====
        // =======================================================
        // Alvo: O novo div que criamos no HTML
        const bodyDiv = document.getElementById('resumo-membros-lista-container'); 
        // =======================================================
        // ===== FIM DA CORRE√á√ÉO =====
        // =======================================================
        
        // --- IN√çCIO DA MELHORIA VISUAL DO RANKING ---
        const emojisEquipe = { abelha: 'üêù', joaninha: 'üêû', vagalume: 'üí°' };
        
        const rankingHTML = Object.entries(dados.rankingEquipes)
            .filter(([equipe]) => ['abelha', 'joaninha', 'vagalume'].includes(equipe))
            .sort(([, posA], [, posB]) => posA - posB)
            .map(([equipe, pos]) => {
                const totalPontos = dados.pontosEquipes[equipe] || 0;
                const mediaPontos = (dados.mediaEquipes?.[equipe] ?? 0).toFixed(2);
                const nomeCapitalizado = equipe.charAt(0).toUpperCase() + equipe.slice(1);
                
                // Define classe e medalha baseada na posi√ß√£o
                let classeRank = '';
                let medalhaIcon = '';
                
                if (pos === 1) { classeRank = 'gold'; medalhaIcon = 'ü•á'; }
                else if (pos === 2) { classeRank = 'silver'; medalhaIcon = 'ü•à'; }
                else { classeRank = 'bronze'; medalhaIcon = 'ü•â'; }

                return `
                <div class="ranking-result-card ${classeRank}">
                    <div class="rank-info-left">
                        <div class="rank-pos">${medalhaIcon}</div>
                        <div class="rank-team-name">
                            <span>${emojisEquipe[equipe] || ''} ${nomeCapitalizado}</span>
                            <small>Total de Pontos: ${totalPontos}</small>
                        </div>
                    </div>
                    <div class="rank-stats-right">
                        <div>M√©dia Final</div>
                        <div class="rank-media-highlight">${mediaPontos}</div>
                    </div>
                </div>`;
            })
            .join('');
            
        // Envolve em um container para aplicar o gap (espa√ßamento)
        rankingDiv.innerHTML = `<div class="ranking-result-container">${rankingHTML}</div>`;
        // --- FIM DA MELHORIA VISUAL DO RANKING ---

        const equipesOrdenadas = Object.entries(dados.rankingEquipes)
            .filter(([equipe]) => ['abelha', 'joaninha', 'vagalume'].includes(equipe))
            .sort(([, posA], [, posB]) => posA - posB)
            .map(([equipe]) => equipe);

        let html = '';
        equipesOrdenadas.forEach(nomeEquipe => {
            const membrosDaEquipe = Object.values(dados.detalhesMembros)
                .filter(m => m.equipe === nomeEquipe)
                .sort((a,b) => b.pontuacao.total - a.pontuacao.total);

            if(membrosDaEquipe.length > 0) {
                html += `<div class="resumo-equipe-bloco">`;
                html += `<div class="resumo-equipe-header ${nomeEquipe}">${nomeEquipe.charAt(0).toUpperCase() + nomeEquipe.slice(1)}</div>`;
                
                // 1. Lista de Membros (CORRIGIDO: Sa√∫de vs F√©rias)
                membrosDaEquipe.forEach(membro => {
                    const ganhouBonus = membro.pontuacao.vantagem > 0;
                    const textoBonus = ganhouBonus ? 'Sim' : 'N√£o';
                    
                    // L√≥gica de exibi√ß√£o de status
                    let indicadorStatus = '';
                    if (membro.deFerias) {
                        if (membro.motivoAusencia === 'saude') {
                             indicadorStatus = '<span style="color: #e74c3c; font-style: italic; font-size: 0.9em; margin-left: 8px;">üò∑ (Sa√∫de)</span>';
                        } else {
                             indicadorStatus = '<span style="color: #3498db; font-style: italic; font-size: 0.9em; margin-left: 8px;">üå¥ (F√©rias)</span>';
                        }
                    }
                    
                    html += `
                        <div class="resumo-membro-item">
                            <span class="resumo-membro-nome">${membro.nome}${indicadorStatus}</span>
                            <span class="resumo-membro-pontos">(Foco: ${membro.pontuacao.foco} | B√¥nus: ${textoBonus})</span>
                            <span class="resumo-membro-total">${membro.pontuacao.total} pts</span>
                        </div>
                    `;
                });
                
                // 2. Poderes de Pontua√ß√£o (Adi√ß√µes)
                const adicoes = dados.adicoesPoderes?.[nomeEquipe];
                if (adicoes && Array.isArray(adicoes)) {
                    adicoes.forEach(add => {
                        html += `
                            <div class="resumo-membro-item resumo-ajuste-item positivo">
                                <span class="resumo-membro-nome">üíñ ${add.nomePoder} (usado pela equipe ${add.por})</span>
                                <span class="resumo-membro-total">+${add.valor} pts</span>
                            </div>
                        `;
                    });
                }

                // 3. Poderes de Pontua√ß√£o (Dedu√ß√µes)
                const deducoes = dados.deducoesPoderes?.[nomeEquipe];
                if (deducoes && Array.isArray(deducoes)) {
                    deducoes.forEach(ded => {
                        html += `
                            <div class="resumo-membro-item resumo-ajuste-item negativo">
                                <span class="resumo-membro-nome">üíÄ ${ded.nomePoder} (usado pela equipe ${ded.por})</span>
                                <span class="resumo-membro-total">${ded.valor} pts</span>
                            </div>
                        `;
                    });
                }

                // 4. Outros Poderes (Estrat√©gicos) - (CORRIGIDO: Alvo vs Origem)
                // Varre o hist√≥rico de TODAS as equipes para encontrar a√ß√µes relevantes para ESTA equipe (nomeEquipe)
                const historicoGeral = dados.historicoCompletoPoderes || {};
                const poderesEstrategicosParaMostrar = [];

                Object.entries(historicoGeral).forEach(([equipeAtacante, listaPoderes]) => {
                    listaPoderes.forEach(poder => {
                        // Ignora poderes de ponto (j√° mostrados acima)
                        if (poder.poderId === 'elixir_vida' || poder.poderId === 'maldicao_pilantragem') return;

                        // CASO A: Ataques CONTRA esta equipe (Kriptonita, Soft Block, Falha)
                        // Se o alvo √© a equipe atual, mostramos aqui.
                        if (poder.alvo === nomeEquipe) {
                            const nomeAtacante = equipeAtacante.charAt(0).toUpperCase() + equipeAtacante.slice(1);
                            poderesEstrategicosParaMostrar.push({
                                texto: `Equipe ${nomeAtacante} usou ${poder.nomePoder}`,
                                tipo: 'ataque' // Vermelho/Roxo
                            });
                        }

                        // CASO B: Defesas/B√¥nus DA pr√≥pria equipe (Amuleto, Po√ß√£o)
                        // Se n√£o tem alvo (ou alvo √© null) e quem usou foi a equipe atual.
                        else if (!poder.alvo && equipeAtacante === nomeEquipe) {
                             poderesEstrategicosParaMostrar.push({
                                texto: `Usou ${poder.nomePoder}`,
                                tipo: 'defesa' // Azul/Verde
                            });
                        }
                    });
                });

                // Renderiza os poderes estrat√©gicos encontrados
                if (poderesEstrategicosParaMostrar.length > 0) {
                    poderesEstrategicosParaMostrar.forEach(p => {
                        const estilo = p.tipo === 'ataque' 
                            ? 'background-color: rgba(231, 76, 60, 0.1); border-left: 3px solid #e74c3c;' // Vermelho para ataques sofridos
                            : 'background-color: rgba(52, 152, 219, 0.1); border-left: 3px solid #3498db;'; // Azul para defesas pr√≥prias
                        
                        html += `
                            <div class="resumo-membro-item resumo-ajuste-item estrategico" style="${estilo}">
                                <span class="resumo-membro-nome">${p.texto}</span>
                                <span class="resumo-membro-total" style="font-size: 0.9em; opacity: 0.8;">Estrat√©gia</span>
                            </div>
                        `;
                    });
                }

                // 5. Ajustes Manuais do L√≠der
                const ajuste = dados.ajustesManuais?.[nomeEquipe];
                if (ajuste && ajuste !== 0) {
                    const tipoAjuste = ajuste > 0 ? 'positivo' : 'negativo';
                    const textoAjuste = ajuste > 0 ? 'Adi√ß√£o de pontos pelo l√≠der' : 'Remo√ß√£o de pontos pelo l√≠der';
                    html += `
                        <div class="resumo-membro-item resumo-ajuste-item ${tipoAjuste}">
                            <span class="resumo-membro-nome">${textoAjuste}</span>
                            <span class="resumo-membro-total">${ajuste > 0 ? '+' : ''}${ajuste} pts</span>
                        </div>
                    `;
                }
                
                html += `</div>`;
            }
        });

        // Esta linha agora preenche o novo div, sem apagar o ranking.
        bodyDiv.innerHTML = html; 

        openModal('resumo-competicao-modal');

        // =======================================================
        // ===== IN√çCIO DA ALTERA√á√ÉO (PASSO 3.3) =====
        // =======================================================
        // Capturamos o bot√£o e definimos sua nova a√ß√£o em cadeia.
        const closeBtn = document.getElementById('resumo-competicao-close-btn');
        if (closeBtn) {
            closeBtn.onclick = () => {
                // 1. Primeiro, fecha o modal de resultados.
                closeModal('resumo-competicao-modal');
                // 2. Em seguida, chama a fun√ß√£o para mostrar o popup do Or√°culo,
                //    passando o texto que lemos do Firestore.
                mostrarPopupAnaliseOraculo(analiseSalva);
            };
        }
        // =======================================================
        // ===== FIM DA ALTERA√á√ÉO =====
        // =======================================================

    } catch (error) {
        console.error("Erro ao exibir popup de resultado da competi√ß√£o:", error);
    }
}

// NOVA FUN√á√ÉO: Atualiza a interface de rea√ß√£o instantaneamente
async function atualizarReacaoOtimista(containerSelector, itemId, emoji) {
    if (!currentUser) return;

    // Encontra o card (seja do mural ou do feed)
    const itemEl = document.querySelector(`${containerSelector} [data-id="${itemId}"]`);
    if (!itemEl) return;

    // Encontra o container de rea√ß√µes dentro do card
    let reacoesContainer = itemEl.querySelector('.reacoes-display-container, .feed-card-reacoes');
    if (!reacoesContainer) {
        // Se n√£o existir, cria um (importante para o primeiro like de um post)
        const feedReacoes = itemEl.querySelector('.feed-card-reacoes');
        if(feedReacoes) {
            reacoesContainer = feedReacoes;
        } else {
            // Fallback para o mural, se necess√°rio
            const newContainer = document.createElement('div');
            newContainer.className = 'reacoes-display-container';
            itemEl.querySelector('.mensagem-info').insertAdjacentElement('beforebegin', newContainer);
            reacoesContainer = newContainer;
        }
    }
    
    const reacaoAntigaEl = reacoesContainer.querySelector('.reacao-display.reacted');
    const reacaoClicadaEl = reacoesContainer.querySelector(`.reacao-display[data-emoji="${emoji}"]`);
    
    const tinhaReacaoAntiga = !!reacaoAntigaEl; // Verifica se o usu√°rio j√° tinha reagido ANTES do clique

    // 1. Lida com a rea√ß√£o antiga, se houver e for DIFERENTE da clicada
    if (reacaoAntigaEl && reacaoAntigaEl !== reacaoClicadaEl) {
        reacaoAntigaEl.classList.remove('reacted');
        const contadorAntigo = reacaoAntigaEl.querySelector('.contador-display');
        let contagemAntiga = parseInt(contadorAntigo.textContent, 10) - 1;
        if (contagemAntiga <= 0) {
            reacaoAntigaEl.remove();
        } else {
            contadorAntigo.textContent = contagemAntiga;
        }
    }

    // 2. Lida com a rea√ß√£o que foi clicada
    if (reacaoClicadaEl) {
        // Se o usu√°rio est√° DESFAZENDO a rea√ß√£o
        if (reacaoClicadaEl.classList.contains('reacted')) {
            reacaoClicadaEl.classList.remove('reacted');
            const contador = reacaoClicadaEl.querySelector('.contador-display');
            let contagem = parseInt(contador.textContent, 10) - 1;
            if (contagem <= 0) {
                reacaoClicadaEl.remove();
            } else {
                contador.textContent = contagem;
            }
        } else { // Se o usu√°rio est√° ADICIONANDO ou TROCANDO para esta rea√ß√£o
            reacaoClicadaEl.classList.add('reacted');
            const contador = reacaoClicadaEl.querySelector('.contador-display');
            contador.textContent = parseInt(contador.textContent, 10) + 1;
        }
    } else { // Se a rea√ß√£o clicada n√£o existia no card, cria uma nova
        const novaReacaoEl = document.createElement('div');
        novaReacaoEl.className = 'reacao-display reacted';
        novaReacaoEl.dataset.emoji = emoji;
        novaReacaoEl.innerHTML = `${emoji} <span class="contador-display">1</span>`;
        
        // Adiciona a fun√ß√£o de clique correta dependendo do container
        if(containerSelector === '#feed-semanal-cards'){
            novaReacaoEl.onclick = (e) => toggleReacaoFeed(e, itemId, emoji);
        } else {
            novaReacaoEl.onclick = () => window.abrirModalReagentes(itemId, emoji);
        }

        reacoesContainer.appendChild(novaReacaoEl);
    }
    
    // 3. Mostra o popup de moedas de forma otimista
    // S√≥ mostra se o usu√°rio n√£o tinha uma rea√ß√£o antes e agora tem.
    // N√£o mostra se ele apenas trocou de rea√ß√£o ou removeu.
    const temReacaoNova = !!reacoesContainer.querySelector('.reacao-display.reacted');
    if (!tinhaReacaoAntiga && temReacaoNova) {
        mostrarPopupMoedas(recompensasConfig.reagirConteudo || 1);
    }
}

async function verificarELimparNaSegunda() {
  const hoje = getHoje();

  // 1. A fun√ß√£o s√≥ continua se hoje for segunda-feira
  if (hoje.getDay() !== 1) {
    return; 
  }

  // 2. Cria a mesma "chave" √∫nica para a semana atual
  const semana = getSemanaAtual();
  const chaveSemanaAtual = `semana_${semana.numero}_${semana.inicio.getFullYear()}`;

  // 3. ALTERADO: L√™ o status do Firestore, n√£o do localStorage
  const statusRef = doc(db, "appState", "statusLimpeza");

  try {
    const docSnap = await getDoc(statusRef);
    const ultimaLimpeza = docSnap.exists() ? docSnap.data().ultimaLimpezaRealizada : null;

    // 4. Verifica se a √∫ltima limpeza registrada no Firestore √© a desta semana
    if (ultimaLimpeza === chaveSemanaAtual) {
      console.log("Limpeza de segunda-feira j√° realizada para esta semana (verificado no Firestore).");
      return; // A√ß√£o j√° foi feita por algu√©m do grupo. Fim.
    }

    // 5. Se n√£o foi feita, executa a limpeza!
    console.log("Primeira vez na segunda-feira para o grupo. Executando limpeza semanal centralizada...");
    
    // ATIVA O BLOQUEIO
    await setGlobalLock(true, "üßπ Limpeza Semanal: Preparando o grupo para a nova semana...");

    try {
      await Promise.all([
      limparFeedSemanal(),
	  limparTodosOsComentariosDoMural(),
      limparTodoOMural(),
	  limparPresencasAntigas(),
      limparVantagensAntigas(),
      limparResultadosCompeticaoAntigos(),
	  limparNotificacoesAntigas(),
	  limparPopupStateAntigo(),
	  limparStatusPoderesAntigos(),
	  limparHistoricoNotificacoesOraculo(),
	  limparHistoricoPoderesAntigos(),
	  limparPixTransacoesAntigas(),
	  limparEnviosDiariosAntigos(),
	  limparGerenciamentoSemanalAntigo(),
	  limparHistoricoTopicosOraculo(),
	  limparApostasLoteriaAntigas(),
	  limparMensagensDiariasAntigas(),
	  limparPalavrasSemanaAntigas(),
	  limparRecompensasLideresAntigas(),
    ]);

    // 6. ALTERADO: Salva o status no Firestore, para que todos saibam
    await setDoc(statusRef, { ultimaLimpezaRealizada: chaveSemanaAtual });

    mostrarPopup("‚ú® Nova Semana!", "O mural e o resumo da semana foram reiniciados.", 5000);
    console.log("Limpeza semanal conclu√≠da e registrada no Firestore para todo o grupo.");

  } catch (error) {
      console.error("Erro durante a limpeza centralizada de segunda-feira:", error);
      mostrarPopup("‚ùå Erro", "Ocorreu uma falha ao reiniciar o mural e o feed.", 4000);
    } finally {
      // DESATIVA O BLOQUEIO
      await setGlobalLock(false);
    }
  
  } catch (error) {
    console.error("Erro geral ao verificar status de limpeza:", error);
  }
}

// NOVA FUN√á√ÉO: Apaga os resultados de competi√ß√µes de semanas muito antigas
async function limparResultadosCompeticaoAntigos() {
  try {
    // Precisamos manter o resultado da semana que ACABOU de terminar.
    const hoje = getHoje();
    const semanaPassada = getSemanaAtual(new Date(hoje.getTime() - (24 * 60 * 60 * 1000)));
    const idSemanaPassada = `semana_${semanaPassada.numero}_${semanaPassada.inicio.getFullYear()}`;

    const resultadosRef = collection(db, "resultadosCompeticao");
    const querySnapshot = await getDocs(resultadosRef);

    if (querySnapshot.empty) {
      console.log("Nenhum documento de resultado de competi√ß√£o encontrado para limpar.");
      return;
    }

    const batch = writeBatch(db);
    let documentosApagados = 0;

    querySnapshot.forEach(doc => {
      // Se o ID do documento for DIFERENTE do ID da semana passada, ele √© antigo e pode ser apagado.
      if (doc.id !== idSemanaPassada) {
        console.log(`Marcando para apagar documento de resultado antigo: ${doc.id}`);
        batch.delete(doc.ref);
        documentosApagados++;
      }
    });

    if (documentosApagados > 0) {
      await batch.commit();
      console.log(`‚úÖ Limpeza conclu√≠da: ${documentosApagados} resultado(s) de competi√ß√£o antigos foram removidos.`);
    } else {
      console.log("Nenhum resultado de competi√ß√£o antigo para apagar nesta verifica√ß√£o.");
    }
  } catch (error) {
    console.error("Erro ao limpar a cole√ß√£o 'resultadosCompeticao':", error);
  }
}

// NOVA FUN√á√ÉO PARA O PAINEL SECRETO
window.forcarRegeracaoQuiz = async function() {
  if (!confirm("Tem certeza que deseja apagar e recriar o Quiz da Vantagem desta semana?")) {
    return;
  }

  try {
    const semana = getSemanaAtual();
    const docId = `semana_${semana.numero}_${semana.inicio.getFullYear()}`;
    const advantageRef = doc(db, "vantagemSemanal", docId);

    // Apaga o campo do quiz, mantendo o resto do documento (como quem j√° completou)
    await updateDoc(advantageRef, {
      quizDaSemana: deleteField()
    });

    mostrarPopup("‚úÖ Sucesso", "Quiz antigo apagado. Recarregando para gerar um novo...", 4000);

    // For√ßa o Jogo da Vantagem a recarregar e gerar um novo quiz
    setTimeout(async () => {
      await loadAdvantageState();
      mostrarPopup("üé≤ Novo Quiz", "Um novo quiz foi gerado com sucesso!", 3000);
    }, 1500);

  } catch (error) {
    console.error("Erro ao for√ßar recria√ß√£o do quiz:", error);
    mostrarPopup("‚ùå Erro", "N√£o foi poss√≠vel apagar o quiz antigo. Tente manualmente.", 5000);
  }
}

// NOVA FUN√á√ÉO: Carrega a ordem dos jogos personalizada do Firestore.
async function carregarOrdemJogos() {
  try {
    const docRef = doc(db, "configuracoes", "ordemJogosVantagem");
    const docSnap = await getDoc(docRef);
    if (docSnap.exists() && docSnap.data().ordem) {
      ordemJogosConfigurada = docSnap.data().ordem;
      console.log("Ordem de jogos personalizada carregada:", ordemJogosConfigurada);
    } else {
      console.log("Nenhuma ordem de jogos personalizada encontrada. Usando ordem padr√£o.");
      // Se n√£o existir, a vari√°vel global permanecer√° um array vazio.
      ordemJogosConfigurada = []; 
    }
  } catch (error) {
    console.error("Erro ao carregar ordem dos jogos:", error);
    ordemJogosConfigurada = [];
  }
}

// NOVA FUN√á√ÉO: Salva a nova ordem de jogos no Firestore.
async function salvarNovaOrdemJogos() {
  const list = document.getElementById('game-order-list');
  const novaOrdem = Array.from(list.children).map(item => item.dataset.gameName);

  if (novaOrdem.length === 0) {
    mostrarPopup("‚ùå Erro", "A lista de jogos est√° vazia.", 4000);
    return;
  }

  // Pega o n√∫mero da semana atual para usar como ponto de partida
  const semanaDeInicio = getSemanaAtual().numero;

  try {
    const docRef = doc(db, "configuracoes", "ordemJogosVantagem");
    // Agora salvamos a ordem E a semana em que essa ordem foi definida
    await setDoc(docRef, { 
      ordem: novaOrdem,
      semanaDeInicio: semanaDeInicio 
    });
    
    ordemJogosConfigurada = novaOrdem;

    mostrarPopup("‚úÖ Sucesso!", "A nova ordem dos jogos foi salva.", 3000);
    popularPainelOrdemJogos(); 

  } catch (error) {
    console.error("Erro ao salvar nova ordem de jogos:", error);
    mostrarPopup("‚ùå Erro", "N√£o foi poss√≠vel salvar a nova ordem.", 4000);
  }
}

// NOVA FUN√á√ÉO: Cria a lista de jogos arrast√°veis no painel do l√≠der.
function popularPainelOrdemJogos() {
  const list = document.getElementById('game-order-list');
  if (!list) return;

  list.innerHTML = ''; // Limpa a lista antes de popular

  // Usa a ordem configurada se existir, sen√£o, usa a ordem padr√£o
  const ordemAtual = ordemJogosConfigurada.length > 0 
    ? ordemJogosConfigurada 
    : todosOsJogos.map(j => j.nome);

  ordemAtual.forEach((nomeJogo, index) => {
    const item = document.createElement('li');
    item.className = 'game-order-item';
    item.draggable = true;
    item.dataset.gameName = nomeJogo;

    let weekIndicator = '';
    if (index === 0) {
      weekIndicator = '<span class="week-indicator">Esta Semana</span>';
    } else if (index === 1) {
      weekIndicator = '<span class="week-indicator">Pr√≥xima</span>';
    }

    item.innerHTML = `
      <span class="drag-handle">‚ò∞</span>
      <span class="game-name">${nomeJogo}</span>
      ${weekIndicator}
    `;
    list.appendChild(item);
  });

  // Adiciona os eventos de arrastar e soltar
  const items = list.querySelectorAll('.game-order-item');
  let draggedItem = null;

  items.forEach(item => {
    item.addEventListener('dragstart', () => {
      draggedItem = item;
      setTimeout(() => item.classList.add('dragging'), 0);
    });

    item.addEventListener('dragend', () => {
      setTimeout(() => {
        draggedItem.classList.remove('dragging');
        draggedItem = null;
      }, 0);
    });

    item.addEventListener('dragover', e => {
      e.preventDefault();
      const afterElement = getDragAfterElement(list, e.clientY);
      if (afterElement == null) {
        list.appendChild(draggedItem);
      } else {
        list.insertBefore(draggedItem, afterElement);
      }
    });
  });

  function getDragAfterElement(container, y) {
    const draggableElements = [...container.querySelectorAll('.game-order-item:not(.dragging)')];
    return draggableElements.reduce((closest, child) => {
      const box = child.getBoundingClientRect();
      const offset = y - box.top - box.height / 2;
      if (offset < 0 && offset > closest.offset) {
        return { offset: offset, element: child };
      } else {
        return closest;
      }
    }, { offset: Number.NEGATIVE_INFINITY }).element;
  }
}

let membroIdParaSalvarAniversario = null;
let novaDataAniversario = null;

async function abrirModalListaAniversarios() {
  const listaContainer = document.getElementById('lista-completa-aniversarios-container');
  listaContainer.innerHTML = '<div class="ociosos-placeholder">Carregando lista de membros...</div>';
  openModal('lista-aniversarios-modal');

  try {
    // Removemos a leitura do Firestore e usamos o cache
    listaContainer.innerHTML = ''; // Limpa a mensagem de "carregando"

    // Mapeia a vari√°vel global para o formato esperado pela fun√ß√£o
    const membrosArray = todosMembros.map(m => ({ id: m.nome, ...m }));

    // Ordena os membros em ordem alfab√©tica
    membrosArray.sort((a, b) => a.id.localeCompare(b.id));

    membrosArray.forEach(membro => {
      const dados = membro;
      const itemEl = document.createElement('div');
      itemEl.className = 'aniversario-item';

      const podeEditar = (currentUser === membro.id && !dados.aniversarioDefinido);

      itemEl.innerHTML = `
        <span class="aniversario-nome-membro">${membro.id}</span>
        <div class="aniversario-data-container">
          <span id="data-aniversario-${membro.id}" class="aniversario-data-membro">
            ${dados.aniversario || 'N√£o definido'}
          </span>
          <button class="edit-aniversario-btn ${podeEditar ? '' : 'hidden'}" 
                  onclick="editarAniversario(event, '${membro.id}')" 
                  title="Definir seu anivers√°rio (s√≥ pode ser feito uma vez!)">
            ‚úèÔ∏è
          </button>
        </div>
      `;
      listaContainer.appendChild(itemEl);
    });

  } catch (error) {
    console.error("Erro ao carregar lista de anivers√°rios:", error);
    listaContainer.innerHTML = '<div class="ociosos-placeholder">Falha ao carregar a lista.</div>';
  }
}

window.editarAniversario = function(event, membroId) {
  event.stopPropagation();
  const spanElement = document.getElementById(`data-aniversario-${membroId}`);

  if (!spanElement || spanElement.isContentEditable) return;

  const valorOriginal = spanElement.textContent.trim();
  spanElement.textContent = ''; // Limpa o texto para o placeholder aparecer
  spanElement.contentEditable = true;
  spanElement.classList.add('editing');
  spanElement.setAttribute('placeholder', 'DD/MM'); // Adiciona um placeholder
  spanElement.focus();

  const salvar = () => {
    handleSalvarAniversario(membroId, spanElement, valorOriginal);
  };

  const lidarComTeclas = (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      spanElement.blur(); // Dispara o evento 'blur' que chama o 'salvar'
    } else if (e.key === 'Escape') {
      spanElement.textContent = valorOriginal;
      spanElement.contentEditable = false;
      spanElement.classList.remove('editing');
      spanElement.removeAttribute('placeholder');
      spanElement.removeEventListener('blur', salvar);
      spanElement.removeEventListener('keydown', lidarComTeclas);
    }
  };

  spanElement.addEventListener('blur', salvar);
  spanElement.addEventListener('keydown', lidarComTeclas);
}

function handleSalvarAniversario(membroId, spanElement, valorOriginal) {
  // Limpa os listeners para evitar execu√ß√µes m√∫ltiplas
  spanElement.contentEditable = false;
  spanElement.classList.remove('editing');
  spanElement.removeAttribute('placeholder');

  const novaData = spanElement.textContent.trim();

  // Se n√£o houver mudan√ßa ou o campo estiver vazio, restaura o valor original.
  if (novaData === '' || novaData === valorOriginal) {
    spanElement.textContent = valorOriginal;
    return;
  }

  // Valida√ß√£o do formato DD/MM
  const regexData = /^([0-2][0-9]|(3)[0-1])(\/)(((0)[0-9])|((1)[0-2]))$/;
  if (!regexData.test(novaData)) {
    mostrarPopup("‚ùå Formato Inv√°lido", "Use o formato DD/MM (ex: 25/12).", 4000);
    spanElement.textContent = valorOriginal;
    return;
  }

  // Se a valida√ß√£o passou, abre o modal de confirma√ß√£o
  membroIdParaSalvarAniversario = membroId;
  novaDataAniversario = novaData;

  const textoConfirmacao = document.getElementById('confirm-aniversario-texto');
  textoConfirmacao.innerHTML = `Voc√™ est√° prestes a definir seu anivers√°rio como <strong>${novaData}</strong>.
                                <br><br>
                                Lembre-se: <strong>esta altera√ß√£o s√≥ pode ser feita uma √∫nica vez!</strong> Tem certeza que a data est√° correta?`;

  const btnConfirmar = document.getElementById('confirm-aniversario-btn');
  btnConfirmar.onclick = executarSalvarAniversario;

  openModal('confirm-aniversario-modal');
}


// NOVO C√ìDIGO OTIMIZADO (R√ÅPIDO)
async function executarSalvarAniversario() {
  if (!membroIdParaSalvarAniversario || !novaDataAniversario) return;

  // Guarda os valores em vari√°veis locais para usar depois
  const membroId = membroIdParaSalvarAniversario;
  const novaData = novaDataAniversario;
  const membroRef = doc(db, "membros", membroId);

  // Limpa as vari√°veis globais imediatamente
  membroIdParaSalvarAniversario = null;
  novaDataAniversario = null;

  // --- A√á√ÉO IMEDIATA (ATUALIZA√á√ÉO OTIMISTA) ---
  // 1. Fecha o modal de confirma√ß√£o e mostra a mensagem de sucesso na hora.
  closeModal('confirm-aniversario-modal');
  mostrarPopup("‚úÖ Sucesso!", "Sua data de anivers√°rio foi salva!", 4000);

  // 2. Atualiza a interface da lista de anivers√°rios manualmente.
  const spanElement = document.getElementById(`data-aniversario-${membroId}`);
  const editBtn = document.querySelector(`.edit-aniversario-btn[onclick*="'${membroId}'"]`);
  
  if (spanElement) {
    spanElement.textContent = novaData;
  }
  if (editBtn) {
    editBtn.classList.add('hidden');
  }
  // --- FIM DA A√á√ÉO IMEDIATA ---


  // --- SALVAMENTO EM SEGUNDO PLANO ---
  // O `try...catch` agora roda sem travar a experi√™ncia do usu√°rio.
  try {
    await updateDoc(membroRef, {
      aniversario: novaData,
      aniversarioDefinido: true
    });

    // Atualiza a se√ß√£o principal de aniversariantes silenciosamente.
    await carregarAniversariantes();
    console.log(`Anivers√°rio de ${membroId} salvo com sucesso no banco de dados.`);

  } catch (error) {
    console.error("Erro ao salvar anivers√°rio em segundo plano:", error);
    mostrarPopup("‚ùå Falha na Sincroniza√ß√£o", "Sua altera√ß√£o n√£o foi salva. Por favor, recarregue e tente novamente.", 5000);

    // REVERS√ÉO EM CASO DE ERRO: Desfaz a mudan√ßa visual se o salvamento falhar.
    if (spanElement) {
      spanElement.textContent = 'N√£o definido'; // Volta para um estado padr√£o
    }
    if (editBtn) {
      editBtn.classList.remove('hidden'); // Mostra o bot√£o de editar novamente
    }
  }
}

// SUBSTITUA A SUA FUN√á√ÉO ANTIGA POR ESTA VERS√ÉO CORRIGIDA
async function marcarPresencaAniversario(membro) {
  if (!membro || !membro.nome) return;

  const nome = membro.nome;
  const equipeDoMembro = membro.equipe;
  const hojeISO = getHojeISO();
  const isDomingo = getHoje().getDay() === 0;

  try {
    const membroRef = doc(db, "membros", nome);
    const presencaRef = doc(db, "presencas", hojeISO);
    const pontosRef = doc(db, "semanas", "pontosSemanais");
    const taskRef = doc(db, "appState", "dailyTasks");

    // --- IN√çCIO DA L√ìGICA CORRIGIDA ---

    // 1. Verifica se a presen√ßa j√° foi marcada no banco de dados
    const presencaDoc = await getDoc(presencaRef);
    const jaMarcadoPresente = presencaDoc.exists() && presencaDoc.data()[nome];

    // 2. Pega o streak atual do cache local
    let novoStreak = streaksCache[nome] || 0;

    // 3. Se a presen√ßa ainda n√£o foi marcada, executa a transa√ß√£o
    if (!jaMarcadoPresente) {
      console.log(`Marcando presen√ßa, streak e moedas de anivers√°rio para ${nome}.`);
      
      const recompensaMoedas = recompensasConfig.focoDiario || 100;

      const { streakDepoisDaTransacao } = await runTransaction(db, async (transaction) => {
        const membroSnap = await transaction.get(membroRef);
        if (!membroSnap.exists()) throw "Membro n√£o encontrado.";
        
        const streakAtual = membroSnap.data().streak || 0;
        const novoStreakCalc = streakAtual + 1;

        // Escrita 1: Marca a presen√ßa
        transaction.set(presencaRef, { [nome]: new Date() }, { merge: true });
        
        // Escrita 2: Atualiza o membro (Streak + Moedas)
        transaction.update(membroRef, { 
          streak: novoStreakCalc,
          moedas: increment(recompensaMoedas) 
        });

        // Escrita 3: Atualiza pontos da equipe
        if (!isDomingo && equipeDoMembro) {
          transaction.update(pontosRef, { [equipeDoMembro]: increment(1) });
        }
        
        return { streakDepoisDaTransacao: novoStreakCalc };
      });

      // 4. Atualiza os caches locais e a UI ap√≥s a transa√ß√£o
      novoStreak = streakDepoisDaTransacao;
      streaksCache[nome] = novoStreak;
      
      if (equipeDoMembro && !isDomingo) {
        pontosSemanais[equipeDoMembro]++;
      }

      // Mostra o popup de moedas se for o usu√°rio logado
      if (nome === currentUser) {
        mostrarPopupMoedas(recompensaMoedas);
      }
      
    } else {
      console.log(`Presen√ßa de ${nome} j√° havia sido marcada (pela folga ou manualmente).`);
    }

    // 5. L√≥gica do Feed (separada da l√≥gica de presen√ßa)
    const anivIdUnico = `${nome}_${hojeISO}`;
    const taskDoc = await getDoc(taskRef);
    const aniversariosJaPostados = taskDoc.exists() ? taskDoc.data().aniversariosFeedPostados || [] : [];

    if (!aniversariosJaPostados.includes(anivIdUnico)) {
      console.log(`Postando feed de anivers√°rio para ${nome}.`);
      const textoFeed = `Hoje o foco de <strong>${nome}</strong> foi marcado como um presente especial! Desejamos um dia incr√≠vel e muitas felicidades. Parab√©ns!`;
      
      await adicionarEventoAoFeed(
        'geral',
        `üéÇ Feliz Anivers√°rio, ${nome}!`,
        textoFeed,
        { nomeMembro: nome }
      );
      
      // Trava o feed
      await setDoc(taskRef, {
        aniversariosFeedPostados: arrayUnion(anivIdUnico)
      }, { merge: true });

      // 6. Verifica se ganhou medalha (s√≥ verifica na primeira vez para evitar spam)
      const streakAntes = novoStreak - 1;
      const niveisMedalha = Object.keys(medalhas).map(Number).sort((a, b) => a - b);
      for (const nivel of niveisMedalha) {
          if (novoStreak >= nivel && streakAntes < nivel) {
              const medalha = medalhas[nivel];
              await adicionarEventoAoFeed(
                  'medalha',
                  'üèÖ Nova Conquista!',
                  `<strong>${nome}</strong> alcan√ßou <strong>${novoStreak} dias</strong> de foco e ganhou a medalha ${medalha.emoji} <strong>${medalha.nome}</strong>!`,
                  { nomeMembro: nome, medalha: medalha.nome }
              );
              break; 
          }
      }

    } else {
        // Este √© o log que voc√™ estava vendo, mas agora ele n√£o impede as outras a√ß√µes
        console.log(`Feed de anivers√°rio para ${nome} j√° foi postado hoje. Ignorando.`);
    }

    // 7. ATUALIZA√á√ÉO VISUAL DA INTERFACE (A CORRE√á√ÉO PRINCIPAL)
    const checkbox = document.getElementById(nome);
    if (checkbox && !checkbox.checked) {
      checkbox.checked = true;
    }
    
    // Atualiza os contadores, medalhas e resumos na tela
    await atualizarResumo(); 
    atualizarMedalhas();

    // --- FIM DA L√ìGICA CORRIGIDA ---

    console.log(`Presen√ßa de anivers√°rio de ${nome} processada com sucesso.`);

  } catch (error) {
    console.error(`Erro ao marcar presen√ßa de anivers√°rio para ${nome}:`, error);
  }
}

// COLE ESTA NOVA FUN√á√ÉO NO SEU SCRIPT
async function handleAjusteManualPontos(acao) {
  const equipeSelecionada = document.getElementById('select-equipe-ajuste').value;
  const inputPontos = document.getElementById('input-pontos-ajuste');
  const pontos = parseInt(inputPontos.value, 10);

  if (!equipeSelecionada) {
    mostrarPopup("‚ö†Ô∏è Aten√ß√£o", "Por favor, selecione uma equipe.", 4000);
    return;
  }
  if (isNaN(pontos) || pontos <= 0) {
    mostrarPopup("‚ö†Ô∏è Aten√ß√£o", "Por favor, insira um n√∫mero de pontos v√°lido e positivo.", 4000);
    return;
  }

  const valorAjuste = acao === 'adicionar' ? pontos : -pontos;
  const textoAcao = acao === 'adicionar' ? 'adicionados' : 'removidos';
  const preposicao = acao === 'adicionar' ? 'para a' : 'da'; // <-- LINHA ADICIONADA
  const emojiAcao = acao === 'adicionar' ? 'üìà' : 'üìâ';
  const nomeEquipeCapitalizado = equipeSelecionada.charAt(0).toUpperCase() + equipeSelecionada.slice(1);

  if (!confirm(`Tem certeza que deseja ${acao} ${pontos} pontos ${preposicao} equipe ${nomeEquipeCapitalizado}?`)) { // <-- LINHA MODIFICADA
    return;
  }

  try {
    const semana = getSemanaAtual();
    const semanaId = `semana_${semana.numero}_${semana.inicio.getFullYear()}`;
    const pontosRef = doc(db, "semanas", "pontosSemanais");
    const ajustesRef = doc(db, "vantagemSemanal", semanaId);
    const batch = writeBatch(db);
    batch.update(pontosRef, { [equipeSelecionada]: increment(valorAjuste) });
    batch.set(ajustesRef, {
      ajustesManuais: { [equipeSelecionada]: increment(valorAjuste) }
    }, { merge: true });
    await batch.commit();

    pontosSemanais[equipeSelecionada] += valorAjuste;
    atualizarPlacarSemanal();
    inputPontos.value = '';

    // --- IN√çCIO DA ADI√á√ÉO ---
    // Adiciona o evento ao feed para registrar a a√ß√£o do l√≠der.
    const emojiAcao = acao === 'adicionar' ? 'üìà' : 'üìâ';
    await adicionarEventoAoFeed(
      'geral',
      `${emojiAcao} Ajuste de Pontos!`,
      `O L√≠der Geral ajustou a pontua√ß√£o: <strong>${pontos}</strong> pontos foram <strong>${textoAcao}</strong> ${preposicao} equipe <strong>${nomeEquipeCapitalizado}</strong>.`,
      { equipe: equipeSelecionada, ajuste: valorAjuste }
    );
    // --- FIM DA ADI√á√ÉO ---

    mostrarPopup("‚úÖ Sucesso!", `Pontos ${textoAcao} ${preposicao} equipe ${nomeEquipeCapitalizado}.`, 4000);

  } catch (error) {
    console.error("Erro ao ajustar pontos manualmente:", error);
    mostrarPopup("‚ùå Erro", "Ocorreu uma falha ao tentar ajustar os pontos.", 5000);
  }
}

async function criarNotificacao(destinatarioId, remetenteNome, tipo, conteudo, acao) {
  try {
    const notificacoesRef = collection(db, "notificacoes");
    await addDoc(notificacoesRef, {
      destinatarioId: destinatarioId,
      remetenteNome: remetenteNome,
      tipo: tipo, // 'mural' ou 'feed'
      conteudo: conteudo, // O emoji da rea√ß√£o
      acao: acao, // A descri√ß√£o da a√ß√£o
      lida: false,
      timestamp: new Date()
    });
  } catch (error) {
    console.error("Erro ao criar notifica√ß√£o:", error);
  }
}

// SUBSTITUA a fun√ß√£o configurarNotificacoesTempoReal por esta:

function configurarNotificacoesTempoReal() {
¬† if (!currentUser) return;

¬† // Desliga qualquer ouvinte de notifica√ß√£o que j√° esteja ativo
¬† if (unsubscribeNotificacoes) {
¬† ¬† unsubscribeNotificacoes();
¬† ¬† console.log("Ouvinte de notifica√ß√µes anterior desligado.");
¬† }

¬† const q = query(
¬† ¬† collection(db, "notificacoes"),
¬† ¬† where("destinatarioId", "==", currentUser),
¬† ¬† orderBy("timestamp", "desc")
¬† );

¬† unsubscribeNotificacoes = onSnapshot(q, async (querySnapshot) => {
¬† ¬† const listaEl = document.getElementById('notificacoes-lista');
¬† ¬† const contadorEl = document.getElementById('notificacoes-contador');

¬† ¬† if (!listaEl || !contadorEl) {
¬† ¬† ¬† console.error("Elementos da interface de notifica√ß√£o n√£o foram encontrados. A atualiza√ß√£o da UI ser√° ignorada.");
¬† ¬† ¬† return;¬†
¬† ¬† }

    // --- L√ìGICA DE POPUPS (PIX, RECOMPENSAS, MEDALHAS) ---
    for (const change of querySnapshot.docChanges()) {
      if (change.type === "added") {
        const notificacao = change.doc.data();
        const notificacaoId = change.doc.id;
        
        // 1. Popup de PIX Recebido (L√≥gica existente)
        if (notificacao.tipo === 'moedas' && notificacao.popupVisto === false) {
            
            const remetente = notificacao.remetenteNome;
            const transacaoId = notificacao.transacaoId;
            const agradecimentoEnviado = notificacao.agradecimentoEnviado || false;
            const acao = notificacao.acao || "";

            const valorMatch = acao.match(/<strong>(.*?)\s*üí∞ moedas<\/strong>/);
            const valor = valorMatch ? valorMatch[1] : 'um valor';
            const comentarioMatch = acao.match(/Coment√°rio: "(.*?)"/);
            const comentario = comentarioMatch ? comentarioMatch[1] : '';

            mostrarPopupPixRecebido(
                remetente, 
                valor, 
                comentario, 
                notificacaoId,
                transacaoId,
                agradecimentoEnviado
            );
            
            try {
                await updateDoc(doc(db, "notificacoes", notificacaoId), { popupVisto: true });
            } catch (e) {
                console.error("Erro ao marcar popup de Pix como visto:", e);
            }
        
        // 2. ===== IN√çCIO DO NOVO BLOCO =====
        // Popup de RECOMPENSA (L√≠der ou Membro)
        } else if (
            (notificacao.tipo === 'recompensa_lider' || notificacao.tipo === 'recompensa_membro') 
            && notificacao.popupVisto === false
          ) {
          
            const remetente = notificacao.remetenteNome;
            const valor = notificacao.valor || 0;
            const agradecimentoEnviado = notificacao.agradecimentoEnviado || false;

            // Chama a nova fun√ß√£o de popup de recompensa
            mostrarPopupRecompensaRecebida(
                remetente,
                valor,
                notificacaoId,
                agradecimentoEnviado
            );

            // Marca o popup como visto no banco de dados
            try {
                await updateDoc(doc(db, "notificacoes", notificacaoId), { 
                    popupVisto: true 
                });
            } catch (e) {
                console.error("Erro ao marcar popup de Recompensa como visto:", e);
            }
        }
        // ===== FIM DO NOVO BLOCO =====
      }
    } 
    // --- FIM DA L√ìGICA DE POPUPS ---


    // --- L√ìGICA DE ATUALIZA√á√ÉO DA LISTA (Sem altera√ß√µes) ---
¬† ¬† let unreadCount = 0;
¬† ¬† listaEl.innerHTML = '';¬†

¬† ¬† if (querySnapshot.empty) {
¬† ¬† ¬† listaEl.innerHTML = '<div class="ociosos-placeholder">Nenhuma notifica√ß√£o por aqui.</div>';
¬† ¬† ¬† contadorEl.classList.add('hidden');
¬† ¬† } else {
¬† ¬† ¬† querySnapshot.forEach(doc => { 
¬† ¬† ¬† ¬† const notificacao = doc.data();

¬† ¬† ¬† ¬† if (!notificacao.lida) {
¬† ¬† ¬† ¬† ¬† unreadCount++;
¬† ¬† ¬† ¬† }
¬† ¬† ¬† ¬† const itemEl = criarElementoNotificacao(notificacao);
¬† ¬† ¬† ¬† listaEl.appendChild(itemEl);
¬† ¬† ¬† });
¬† ¬† } 
¬† ¬†¬†
¬† ¬† const painelPessoal = document.getElementById('painel-pessoal-container');

¬† ¬† if (unreadCount > 0) {
¬† ¬† ¬† contadorEl.textContent = `${unreadCount}`;
¬† ¬† ¬† contadorEl.classList.remove('hidden');
¬† ¬† ¬† if (painelPessoal) {
¬† ¬† ¬† ¬† painelPessoal.classList.add('notificacao-neon-border');
¬† ¬† ¬† }
¬† ¬† } else {
¬† ¬† ¬† contadorEl.classList.add('hidden');
¬† ¬† ¬† if (painelPessoal) {
¬† ¬† ¬† ¬† painelPessoal.classList.remove('notificacao-neon-border');
¬† ¬† ¬† }
¬† ¬† }
¬† });
¬† console.log(`Ouvinte de notifica√ß√µes ativado para: ${currentUser}`);
}

function criarElementoNotificacao(notificacao) {
    const itemEl = document.createElement('div');
    itemEl.className = 'notificacao-item';
    if (!notificacao.lida) {
        itemEl.classList.add('nao-lida');
    }

    const data = notificacao.timestamp.toDate();
    const dataFormatada = data.toLocaleDateString('pt-BR');
    const horaFormatada = data.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit'});

    itemEl.innerHTML = `
        <div class="notificacao-conteudo">
            <strong>${notificacao.remetenteNome}</strong> ${notificacao.acao} 
            <span style="font-size: 1.2rem;">${notificacao.conteudo}</span>
        </div>
        <div class="notificacao-horario">
            ${dataFormatada}<br>${horaFormatada}
        </div>
    `;
    return itemEl;
}

async function marcarNotificacoesComoLidas() {
  const q = query(
    collection(db, "notificacoes"),
    where("destinatarioId", "==", currentUser),
    where("lida", "==", false)
  );

  try {
    const querySnapshot = await getDocs(q);
    if (querySnapshot.empty) return; // Nenhuma para marcar

    const batch = writeBatch(db);
    querySnapshot.forEach(doc => {
      batch.update(doc.ref, { lida: true });
    });
    await batch.commit();
    console.log("Notifica√ß√µes marcadas como lidas.");
  } catch (error) {
    console.error("Erro ao marcar notifica√ß√µes como lidas:", error);
  }
}

// NOVA FUN√á√ÉO: Encontra e apaga todas as notifica√ß√µes do usu√°rio logado.
async function apagarTodasAsNotificacoes() {
  if (!currentUser) return;

  console.log(`Iniciando exclus√£o for√ßada de notifica√ß√µes para ${currentUser}...`);

  try {
    // 1. Busca TODAS as notifica√ß√µes do usu√°rio (lidas ou n√£o)
    const q = query(
      collection(db, "notificacoes"),
      where("destinatarioId", "==", currentUser)
    );

    const querySnapshot = await getDocs(q);
    
    if (querySnapshot.empty) {
      console.log("Nenhuma notifica√ß√£o encontrada no banco para apagar.");
      return;
    }

    // 2. Executa a exclus√£o em lotes (Batch)
    const batch = writeBatch(db);
    querySnapshot.forEach(doc => {
      batch.delete(doc.ref);
    });

    await batch.commit();
    
    console.log(`SUCESSO: ${querySnapshot.size} notifica√ß√µes apagadas permanentemente.`);

    // Limpa a lista visualmente na hora para dar feedback instant√¢neo se o modal ainda estiver aberto
    const listaEl = document.getElementById('notificacoes-lista');
    if (listaEl) {
        listaEl.innerHTML = '<div class="ociosos-placeholder">Todas as notifica√ß√µes foram limpas.</div>';
    }

  } catch (error) {
    console.error("Erro ao apagar notifica√ß√µes:", error);
    mostrarPopup("‚ùå Erro", "N√£o foi poss√≠vel limpar suas notifica√ß√µes. Tente novamente.", 4000);
    throw error; // Lan√ßa o erro para a fun√ß√£o do bot√£o saber que falhou
  }
}

// NOVA FUN√á√ÉO: Chamada pelo bot√£o "Fechar" do modal de notifica√ß√µes.
window.fecharEApagarNotificacoes = async function() {
  // Primeiro, chama a fun√ß√£o para apagar as notifica√ß√µes do banco de dados.
  await apagarTodasAsNotificacoes();
  
  // Depois que a exclus√£o terminar, fecha o modal da interface.
  closeModal('notificacoes-modal');
}

// NOVA FUN√á√ÉO: Gera um novo tema para a Batalha de Desenhos
async function gerarNovoTemaDesenho() {
  if (!genAI) return;

  console.log("üé® Or√°culo: Escolhendo novo tema de desenho...");
  
  const categorias = ["objetos", "comida", "animais"];
  const categoriaEscolhida = categorias[Math.floor(Math.random() * categorias.length)];

  const prompt = `
    Voc√™ √© o organizador de uma competi√ß√£o de desenho.
    Sua tarefa √© escolher um tema EXTREMAMENTE SIMPLES e f√°cil de desenhar para a rodada desta semana.
    A categoria sorteada foi: "${categoriaEscolhida}".
    
    O tema deve ser, preferencialmente, UMA √öNICA PALAVRA ou um objeto muito comum.
    Exemplos bons: "Cadeira", "Sol", "Gato", "Ma√ß√£", "Rel√≥gio", "√Årvore".
    N√ÉO crie temas complexos ou abstratos como "Instrumentos abandonados" ou "Paisagem melanc√≥lica". Seja direto.
    
    Sua resposta DEVE ser um JSON v√°lido no formato: {"tema": "SEU_TEMA_AQUI"}.
    Apenas o JSON.
  `;

  try {
    const text = await callGenerativeAIWithRetry(prompt);
    const jsonMatch = text.match(/{[\s\S]*}/);
    if (!jsonMatch) throw new Error("JSON inv√°lido do Or√°culo.");
    
    const dados = JSON.parse(jsonMatch[0]);
    const novoTema = dados.tema;

    // Salva no Firestore
    await setDoc(doc(db, "configuracoes", "temaDesenho"), {
        tema: novoTema,
        dataGeracao: new Date(),
        ativo: true
    });

    // Anuncia no Feed
    await adicionarEventoAoFeed(
        'geral',
        'üé® Novo Tema de Desenho!',
        `O Or√°culo decretou! O tema da Batalha de Desenhos desta semana √©: <strong>${novoTema}</strong>. Equipes, preparem seus pinc√©is! O prazo acaba segunda-feira. Os membros da equipe com melhor desenho levam <strong>5.000 moedas</strong> cada.`
    );
    
    return novoTema;

  } catch (error) {
    console.error("Erro ao gerar tema de desenho:", error);
    return "Livre"; // Fallback
  }
}

async function carregarTemaDesenho() {
    try {
        const docSnap = await getDoc(doc(db, "configuracoes", "temaDesenho"));
        const container = document.getElementById('tema-desenho-container');
        const textoEl = document.getElementById('tema-atual-texto');
        
        if (docSnap.exists() && docSnap.data().ativo) {
            textoEl.textContent = docSnap.data().tema;
            container.classList.remove('hidden');
        } else {
            // Se n√£o houver tema ativo (ex: ter√ßa/quarta antes do sorteio), esconde ou mostra "Aguardando"
            container.classList.add('hidden');
        }
    } catch (e) {
        console.error("Erro ao carregar tema:", e);
    }
}

// NOVA FUN√á√ÉO: Captura as telas das 3 equipes para envio √† IA
async function capturarDesenhosParaJulgamento() {
    const equipes = ['abelha', 'joaninha', 'vagalume'];
    const capturas = {};

    // Precisamos recriar os contextos temporariamente para garantir que o desenho esteja carregado no canvas
    // Nota: Assume-se que os dados de tra√ßos j√° est√£o no Firestore.
    // Esta fun√ß√£o deve desenhar os tra√ßos em um canvas invis√≠vel ou no vis√≠vel rapidamente.
    
    // Simplifica√ß√£o: Vamos capturar o que est√° nos elementos canvas atuais.
    // IMPORTANTE: Para isso funcionar na rotina autom√°tica, os dados dos desenhos devem ser pr√©-carregados.
    // Vamos usar a fun√ß√£o 'configurarTelaDeDesenho' modificada para desenhar offscreen e retornar o dataURL.
    
    for (const equipe of equipes) {
        // Cria um canvas tempor√°rio na mem√≥ria
        const canvasTemp = document.createElement('canvas');
        canvasTemp.width = 800;
        canvasTemp.height = 600;
        const ctxTemp = canvasTemp.getContext('2d');
        
        // Pinta o fundo de branco (para n√£o ficar transparente na IA)
        ctxTemp.fillStyle = "#ffffff";
        ctxTemp.fillRect(0, 0, 800, 600);

        // Busca os tra√ßos do banco
        const q = query(collection(db, `desenhos_${equipe}`), orderBy("timestamp"));
        const snapshot = await getDocs(q);
        
        if (snapshot.empty) {
            capturas[equipe] = null; // Tela vazia
            continue;
        }

        // Redesenha os tra√ßos
        snapshot.forEach(doc => {
            const dados = doc.data();
            const pontos = dados.pontos;
            if (!pontos || pontos.length < 2) return;
            
            ctxTemp.beginPath();
            ctxTemp.strokeStyle = dados.cor;
            ctxTemp.lineWidth = dados.tamanho;
            ctxTemp.lineCap = 'round';
            ctxTemp.lineJoin = 'round';
            ctxTemp.moveTo(pontos[0].x, pontos[0].y);
            for (let i = 1; i < pontos.length; i++) {
                ctxTemp.lineTo(pontos[i].x, pontos[i].y);
            }
            ctxTemp.stroke();
        });

        // Converte para Base64 (JPEG comprimido para respeitar limites)
        // Remove o prefixo "data:image/jpeg;base64," para o Gemini
        const dataURL = canvasTemp.toDataURL('image/jpeg', 0.5); 
        capturas[equipe] = dataURL.split(',')[1]; 
    }
    
    return capturas;
}

// VERS√ÉO ATUALIZADA: Com Autores, Detalhes e Persist√™ncia
async function executarJulgamentoDesenhos() {
    showLoadingOverlay("üé® O Or√°culo est√° julgando as obras de arte...");
    
    try {
        // 1. Carrega o tema atual
        const temaDoc = await getDoc(doc(db, "configuracoes", "temaDesenho"));
        const temaAtual = temaDoc.exists() ? temaDoc.data().tema : "Tema Livre";

        // 2. Captura as imagens
        const imagensBase64 = await capturarDesenhosParaJulgamento();

        // --- IN√çCIO DA ALTERA√á√ÉO (Detectar Sem Participa√ß√£o) ---
        // Verifica se todas as equipes retornaram null (sem desenho)
        const todasVazias = Object.values(imagensBase64).every(img => img === null);

        if (todasVazias) {
            console.log("Nenhuma equipe desenhou. Iniciando protocolo de 'Sem Participa√ß√£o'.");
            
            const semana = getSemanaAtual();
            const idResultado = `desenho_sem_${semana.numero}_${semana.inicio.getFullYear()}`;

            const batch = writeBatch(db);

            // Salva um resultado especial indicando que n√£o houve participa√ß√£o
            batch.set(doc(db, "resultadosDesenho", idResultado), {
                tema: temaAtual,
                semParticipacao: true, // FLAG IMPORTANTE
                data: new Date(),
                processado: true,
                idUnicoPopup: idResultado
            });

            // Desativa o tema
            batch.update(doc(db, "configuracoes", "temaDesenho"), { ativo: false });
            await batch.commit();

            // Feed de Decep√ß√£o
            await adicionarEventoAoFeed(
                'geral', // Tipo geral (cor roxa/padr√£o) em vez de vit√≥ria
                'üé® Batalha de Arte: Resultado',
                `O tema era "<strong>${temaAtual}</strong>", mas... As telas ficaram em branco. Nenhuma equipe entregou a obra a tempo. O Or√°culo est√° decepcionado. Ningu√©m pontuou nesta rodada.`,
                { nomeMembro: "Or√°culo" }
            );

            hideLoadingOverlay();
            await carregarTemaDesenho();
            await verificarUltimoResultadoDesenho(); // Exibe o popup triste
            return; // Encerra a fun√ß√£o aqui, sem dar moedas
        }
        // --- FIM DA ALTERA√á√ÉO ---
        
        // 3. Prepara inputs IA e recupera AUTORES
        const inputsImagem = [];
        const nomesEquipesOrdem = [];
        const mapaAutores = {}; // Guarda os autores por equipe

        for (const [equipe, base64] of Object.entries(imagensBase64)) {
            // Busca autores antes de julgar
            const autoresLista = await obterAutoresPorEquipe(equipe);
            mapaAutores[equipe] = autoresLista;

            if (base64) {
                inputsImagem.push({
                    inlineData: { data: base64, mimeType: "image/jpeg" }
                });
                nomesEquipesOrdem.push(equipe);
            }
        }
        
        // 4. Prompt Detalhado
        const promptTexto = `
            Voc√™ √© o juiz de uma competi√ß√£o de arte. O tema da semana foi: "${temaAtual}".
            
            Abaixo est√£o os desenhos das equipes na seguinte ordem: ${nomesEquipesOrdem.join(', ')}.
            (Se alguma equipe n√£o est√° na lista, considere que ela entregou uma tela em branco e deve receber nota 0).

            Analise cada desenho com seriedade, mesmo que pare√ßam simples. Considere Criatividade, Uso de Cores, Originalidade, Coer√™ncia com o Tema e Esfor√ßo.

            Sua resposta DEVE ser estritamente um JSON neste formato para CADA equipe:
            {
                "avaliacoes": {
                    "abelha": { "criatividade": 0-10, "cores": 0-10, "originalidade": 0-10, "comentario": "..." },
                    "joaninha": { "criatividade": 0-10, "cores": 0-10, "originalidade": 0-10, "comentario": "..." },
                    "vagalume": { "criatividade": 0-10, "cores": 0-10, "originalidade": 0-10, "comentario": "..." }
                }
            }
            
            Se o desenho for muito ruim ou rabiscado, d√™ notas baixas e fa√ßa um coment√°rio construtivo ou engra√ßado (estilo Or√°culo). Se for tela vazia, notas 0.
        `;

        // 5. Chama o Gemini
        const model = genAI.getGenerativeModel({ model: "gemini-2.5-flash-lite" });
        const result = await model.generateContent([promptTexto, ...inputsImagem]);
        const responseText = result.response.text();
        const jsonString = responseText.replace(/```json/g, "").replace(/```/g, "").trim();
        const resultadoIA = JSON.parse(jsonString);
        
        // 6. Processa Classifica√ß√£o
        const pontuacoesFinais = [];
        
        for (const equipe of ['abelha', 'joaninha', 'vagalume']) {
            const notas = resultadoIA.avaliacoes[equipe] || { criatividade: 0, cores: 0, originalidade: 0, comentario: "N√£o participou." };
            const total = (notas.criatividade + notas.cores + notas.originalidade);
            
            pontuacoesFinais.push({
                equipe: equipe,
                total: total,
                detalhes: notas,
                autores: mapaAutores[equipe] || [] // Salva autores aqui
            });
        }
        
        pontuacoesFinais.sort((a, b) => b.total - a.total);
        
        // 7. Salva Resultado Completo e Premia
        const vencedores = pontuacoesFinais.filter(p => p.total === pontuacoesFinais[0].total);
        const nomesVencedores = vencedores.map(v => v.equipe);
        const batch = writeBatch(db);
        
        vencedores.forEach(vencedor => {
            // Premia apenas quem participou (se quiser premiar todos, use todosMembros)
            const membrosDaEquipe = todosMembros.filter(m => m.equipe === vencedor.equipe);
            membrosDaEquipe.forEach(m => {
                batch.update(doc(db, "membros", m.nome), { moedas: increment(5000) });
            });
        });

        const semana = getSemanaAtual();
        const idResultado = `desenho_sem_${semana.numero}_${semana.inicio.getFullYear()}`; // ID √öNICO DA SEMANA
        
        batch.set(doc(db, "resultadosDesenho", idResultado), {
            tema: temaAtual,
            ranking: pontuacoesFinais,
            data: new Date(),
            processado: true,
            idUnicoPopup: idResultado // Usado para o "N√£o ver novamente"
        });
        
        batch.update(doc(db, "configuracoes", "temaDesenho"), { ativo: false });
        await batch.commit();

        // 8. Notifica e Atualiza Tela (Chama a fun√ß√£o de verifica√ß√£o para exibir)
        await carregarTemaDesenho(); // Atualiza o tema para "Inativo"
        await verificarUltimoResultadoDesenho(); // Exibe o popup e atualiza as caixas na tela

        // Feed
        const nomesFormatados = nomesVencedores.map(n => n.charAt(0).toUpperCase() + n.slice(1)).join(' e ');
        await adicionarEventoAoFeed(
            'vitoria',
            'üé® Vencedores da Batalha de Arte!',
            `O tema era "<strong>${temaAtual}</strong>". A equipe <strong>${nomesFormatados}</strong> venceu a batalha e seus membros receram <strong>5.000 moedas</strong> cada um!`
        );

    } catch (error) {
        console.error("Erro no julgamento:", error);
        mostrarPopup("‚ùå Erro", "Falha ao julgar. Tente novamente.", 4000);
    } finally {
        hideLoadingOverlay();
    }
}

// Expondo as fun√ß√µes para o HTML (onclick)
window.forcarNovoTemaManual = forcarNovoTemaManual;
window.forcarJulgamentoManual = forcarJulgamentoManual;

// NOVA FUN√á√ÉO: Verifica resultado, exibe popup persistente e atualiza campos na tela
async function verificarUltimoResultadoDesenho() {
    // Busca o √∫ltimo resultado gerado
    try {
        const q = query(collection(db, "resultadosDesenho"), orderBy("data", "desc"), limit(1));
        const snapshot = await getDocs(q);
        
        if (snapshot.empty) {
            // Esconde as caixas se n√£o houver resultado
            document.querySelectorAll('.avaliacao-oraculo-box').forEach(el => el.classList.add('hidden'));
            return;
        }

        const dados = snapshot.docs[0].data();
        // ADICIONE ESTA LINHA:
        const semParticipacao = dados.semParticipacao || false;
        
        const pontuacoes = dados.ranking || []; // Fallback para array vazio se n√£o houver ranking
        const idPopup = dados.idUnicoPopup;
        const temaDaBatalha = dados.tema || "Tema Livre"; 
        
        // 1. Atualiza as caixas fixas na tela (Sempre vis√≠veis se houver resultado)
        if (semParticipacao) {
             document.querySelectorAll('.avaliacao-oraculo-box').forEach(el => {
                el.innerHTML = `
                    <span class="tema-avaliacao-destaque">üé® Tema: ${temaDaBatalha}</span>
                    <strong>üßô‚Äç Or√°culo:</strong><br>
                    <span style="font-style: italic;">"Onde est√° a arte? Ningu√©m desenhou nada..."</span>
                `;
                el.classList.remove('hidden');
             });
        } else {
            pontuacoes.forEach(p => {
                const caixaEl = document.getElementById(`avaliacao-oraculo-${p.equipe}`);
                if (caixaEl) {
                    caixaEl.innerHTML = `
                        <span class="tema-avaliacao-destaque">üé® Tema: ${temaDaBatalha}</span>
                        <strong>üßô‚Äç Avalia√ß√£o do Or√°culo:</strong><br>
                        <span style="font-size: 0.9em; font-style: italic;">"${p.detalhes.comentario}"</span><br>
                        <div class="criteria-text">
                        <strong>${p.total} pts</strong> (üí° Criatividade: ${p.detalhes.criatividade} | üåà Cores: ${p.detalhes.cores} | ‚ú® Originalidade: ${p.detalhes.originalidade})
                        </div>
                    `;
                    caixaEl.classList.remove('hidden');
                }
            });
        }

        // === MUDAN√áA AQUI: TRAVA DE DIA (Igual √† Loteria) ===
        // O popup autom√°tico s√≥ deve aparecer na Ter√ßa-feira (dia 2).
        // Nos outros dias, o c√≥digo para aqui (as caixas acima continuam vis√≠veis).
        const hojeDia = getHoje().getDay();
        if (hojeDia !== 2) {
             return; 
        }
        // ====================================================

        // 2. Verifica se deve mostrar o Popup (L√≥gica de "N√£o ver novamente")
        if (currentUser) {
             const membro = todosMembros.find(m => m.nome === currentUser);
             if (membro && membro.bloqueiosPopups && membro.bloqueiosPopups[`resultado_desenho_${idPopup}`]) {
                return; 
            }
        }

        // 3. Constr√≥i o HTML Rico do Popup
        let htmlPopup = `<div style="display: flex; flex-direction: column; gap: 15px;">`;
        
        // --- IN√çCIO DA ALTERA√á√ÉO: HTML DIFERENTE SE N√ÉO HOUVE DESENHO ---
        if (semParticipacao) {
            htmlPopup += `
            <div class="result-card-popup" style="text-align: center; background-color: #fff0f0; border-color: #e74c3c;">
                <div style="font-size: 3rem; margin-bottom: 10px;">üçÉ</div>
                <div style="font-weight: bold; font-size: 1.2rem; color: #c0392b; margin-bottom: 10px;">
                    O Vento Levou...
                </div>
                <div style="font-style: italic; color: #555;">
                    "Eu preparei meus olhos para contemplar a beleza, mas encontrei apenas o vazio. Nenhuma equipe apresentou sua obra para o tema <strong>${temaDaBatalha}</strong>."
                </div>
                <hr style="margin: 15px 0; border: 0; border-top: 1px solid rgba(0,0,0,0.1);">
                <div style="font-size: 0.9rem; font-weight: bold;">
                    Ningu√©m pontuou. Sem vencedores.
                </div>
            </div>`;
        } else {
            // Loop normal de pontua√ß√µes (COM CORRE√á√ÉO PARA ZERADOS)
            pontuacoes.forEach((p, index) => {
                let medalha;
                let classeCss = "";
                let textoAutores = "";
                
                // Formata o nome da equipe (Ex: Vaga-lume)
                let nomeEquipe = p.equipe === 'vagalume' ? 'Vaga-lume' : p.equipe.charAt(0).toUpperCase() + p.equipe.slice(1);

                if (p.total === 0) {
                    // SE A PONTUA√á√ÉO FOR 0: N√£o ganha medalha, ganha um c√≠rculo cinza
                    medalha = '‚ö™'; 
                    classeCss = "opacity: 0.7; border: 1px dashed #ccc;"; // Visual de "desativado"
                    textoAutores = "Sem participa√ß√£o";
                } else {
                    // L√≥gica normal de medalhas para quem pontuou
                    if (index === 0) medalha = 'ü•á';
                    else if (index === 1) medalha = 'ü•à';
                    else medalha = 'ü•â';
                    
                    // Ajuste fino para empates visuais
                    // Se a pontua√ß√£o for igual √† do anterior E for maior que 0
                    if (index > 0 && p.total === pontuacoes[index-1].total && p.total > 0) {
                        if (index === 1) medalha = 'ü•á'; // Empate duplo no topo (dois ouros)
                        if (index === 2 && pontuacoes[1].total === pontuacoes[0].total) medalha = 'ü•á'; // Empate triplo (tr√™s ouros)
                        else if (index === 2) medalha = 'ü•à'; // Empate no segundo lugar (duas pratas)
                    }
                    
                    let listaAutores = p.autores.length > 0 ? p.autores.join(', ') : "Equipe";
                    textoAutores = `üé® Artistas: ${listaAutores}`;
                }

                htmlPopup += `
                <div class="result-card-popup" style="${classeCss}">
                    <div class="result-header">
                        <span class="result-rank">${medalha}</span>
                        <span class="result-team">${nomeEquipe}</span>
                        <span class="result-total">${p.total} pts</span>
                    </div>
                    <div class="result-authors" style="font-size: 0.85rem;">${textoAutores}</div>
                    <div class="result-criteria">
                        <span>üí° Criat: ${p.detalhes.criatividade}</span>
                        <span>üåà Cores: ${p.detalhes.cores}</span>
                        <span>‚ú® Orig: ${p.detalhes.originalidade}</span>
                    </div>
                    <div class="result-comment">
                        üßô‚Äç "${p.detalhes.comentario}"
                    </div>
                </div>`;
            });
        }
        // --- FIM DA ALTERA√á√ÉO ---
        
        htmlPopup += `
            <button class="btn-conferir-resultados" onclick="irParaSecaoDesenhos()">
                üé® Conferir Telas
            </button>
        </div>`;

        // 4. Mostra o Popup
        mostrarCardPopup(
            semParticipacao ? `üé® Resultado: Decep√ß√£o` : `üé® Resultado: ${temaDaBatalha}`, // T√≠tulo din√¢mico
            htmlPopup, 
            semParticipacao ? null : dispararConfete, // Sem confete se ningu√©m participou
            null, 
            `resultado_desenho_${idPopup}` 
        );

    } catch (e) {
        console.error("Erro ao verificar resultado do desenho:", e);
    }
}

// =======================================================
// ===== FUN√á√ïES MANUAIS PARA O PAINEL DE CONTROLE =====
// =======================================================

// 1. For√ßar gera√ß√£o de tema (Bot√£o Azul)
async function forcarNovoTemaManual() {
    if (!confirm("‚ö†Ô∏è ATEN√á√ÉO: Isso ir√° LIMPAR todas as telas de desenho atuais e gerar um novo tema, iniciando uma nova rodada de competi√ß√£o.\n\nDeseja continuar?")) {
        return;
    }

    try {
        // Fecha o painel para mostrar o loading
        closeModal('control-panel-modal');
        showLoadingOverlay("üé® O Or√°culo est√° escolhendo um novo tema...");

        // Executa a limpeza das telas
        await limparTodasAsTelasDeDesenho();
        
        // Gera o tema com a IA
        const novoTema = await gerarNovoTemaDesenho();
        
        hideLoadingOverlay();
        
        if (novoTema) {
            // Atualiza a interface imediatamente
            await carregarTemaDesenho();
            mostrarPopup("‚úÖ Sucesso", `Novo tema definido: "${novoTema}"`, 4000);
        } else {
            mostrarPopup("‚ùå Erro", "N√£o foi poss√≠vel gerar o tema. Verifique a IA.", 4000);
        }
    } catch (error) {
        console.error("Erro ao for√ßar tema:", error);
        hideLoadingOverlay();
        mostrarPopup("‚ùå Erro", "Falha na opera√ß√£o manual.", 4000);
    }
}

// 2. For√ßar julgamento (Bot√£o Laranja)
async function forcarJulgamentoManual() {
    if (!confirm("‚ö†Ô∏è ATEN√á√ÉO: Isso ir√° encerrar a rodada atual, capturar os desenhos existentes e realizar o julgamento com premia√ß√£o.\n\nCertifique-se de que h√° desenhos para avaliar.\n\nDeseja continuar?")) {
        return;
    }

    try {
        // Fecha o painel
        closeModal('control-panel-modal');
        
        // A fun√ß√£o executarJulgamentoDesenhos j√° possui o loading overlay e tratamento de erros
        await executarJulgamentoDesenhos();
        
        // Ap√≥s o julgamento, atualizamos o tema na tela (ele deve sumir ou mudar de estado)
        await carregarTemaDesenho();

    } catch (error) {
        console.error("Erro ao for√ßar julgamento:", error);
    }
}

// NOVA FUN√á√ÉO: Obt√©m os nomes dos autores de uma equipe
async function obterAutoresPorEquipe(equipeId) {
    const autores = new Set();
    try {
        const desenhosRef = collection(db, `desenhos_${equipeId}`);
        const snapshot = await getDocs(desenhosRef);
        snapshot.forEach(doc => {
            if (doc.data().desenhadoPor) {
                autores.add(doc.data().desenhadoPor);
            }
        });
    } catch (e) {
        console.error("Erro ao buscar autores:", e);
    }
    return Array.from(autores);
}

// NOVA FUN√á√ÉO: Rola a tela at√© a se√ß√£o de desenho (para o bot√£o do popup)
window.irParaSecaoDesenhos = function() {
    // Fecha o popup
    const closeBtn = document.getElementById('card-popup-close-btn');
    if(closeBtn) closeBtn.click();
    
    // Rola at√© a se√ß√£o
    const secao = document.getElementById('secao-desenho');
    if(secao) secao.scrollIntoView({ behavior: 'smooth' });
}

// =============================================
// ESTADO GLOBAL E CONTROLES DA BARRA DE FERRAMENTAS
// =============================================
let modoAtual = 'pincel';
let corPincel = '#000000';
let tamanhoPincel = 5;

// Vari√°veis de controle para a lupa arrast√°vel
let isLupaDragging = false;
let lupaOffsetX = 0;
let lupaOffsetY = 0;

// COLE A FUN√á√ÉO AQUI, FORA DE QUALQUER OUTRA FUN√á√ÉO
function getTransformedPoint(screenX, screenY) {
  const fullscreenCanvas = document.getElementById('tela-desenho-fullscreen');
  if (!fullscreenCanvas) return { x: 0, y: 0 }; // Seguran√ßa caso o canvas n√£o seja encontrado

  const rect = fullscreenCanvas.getBoundingClientRect();
  const scaleX = fullscreenCanvas.width / rect.width;
  const scaleY = fullscreenCanvas.height / rect.height;
  return {
    x: (screenX - rect.left) * scaleX,
    y: (screenY - rect.top) * scaleY,
  };
}

function atualizarCursorDinamico() {
    const fullscreenCanvas = document.getElementById('tela-desenho-fullscreen');
    if (!fullscreenCanvas) return;

    let cursorFinal = 'default';
    if (modoAtual === 'pincel') {
        cursorFinal = 'crosshair';
    } else if (modoAtual === 'borracha') {
        const tamanhoCursor = Math.round(24 + ((parseInt(tamanhoPincel, 10) - 1) / 49) * 24);
        const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${tamanhoCursor}" height="${tamanhoCursor}" viewBox="0 0 32 32"><text x="2" y="26" font-size="24" font-weight="bold" fill="black" stroke="white" stroke-width="2" paint-order="stroke">„Äá</text></svg>`;
        cursorFinal = `url("data:image/svg+xml,${encodeURIComponent(svg)}") 16 16, auto`;
    } else if (modoAtual === 'arrastar') {
        cursorFinal = 'grab';
    } else if (modoAtual === 'conta-gotas') {
        // Quando o conta-gotas est√° ativo, o cursor √© a pr√≥pria lupa.
        // Deixamos o cursor do canvas invis√≠vel para n√£o confundir.
        cursorFinal = 'none';
    }
    fullscreenCanvas.style.cursor = cursorFinal;
}

// --- FUN√á√ÉO ATUALIZADA ---
function definirModoGlobal(novoModo) {
    modoAtual = novoModo;
    const botoes = {
        pincel: document.getElementById('pincel-btn'),
        borracha: document.getElementById('borracha-btn'),
        contaGotas: document.getElementById('conta-gotas-btn')
    };
    const lupa = document.getElementById('lupa-conta-gotas');
    const lupaPreview = document.getElementById('lupa-cor-preview');
    const canvas = document.getElementById('tela-desenho-fullscreen');

    Object.values(botoes).forEach(btn => btn?.classList.remove('ativo'));

    if (novoModo === 'conta-gotas') {
        botoes.contaGotas?.classList.add('ativo');
        if (lupa && canvas && lupaPreview) {
            // OTIMIZA√á√ÉO: Gera a imagem do canvas APENAS UMA VEZ.
            lupaPreview.style.backgroundImage = `url(${canvas.toDataURL()})`;
            
            lupa.style.left = `${window.innerWidth / 2}px`;
            lupa.style.top = `${window.innerHeight / 2}px`;
            lupa.classList.remove('hidden');
            
            // Simula um evento de movimento para posicionar o zoom inicial
            const eventoInicial = { clientX: window.innerWidth / 2, clientY: window.innerHeight / 2 };
            atualizarZoomLupa(eventoInicial);
        }
    } else {
        lupa?.classList.add('hidden');
        if (novoModo === 'pincel') botoes.pincel?.classList.add('ativo');
        if (novoModo === 'borracha') botoes.borracha?.classList.add('ativo');
    }
    
    atualizarCursorDinamico();
}

// --- NOVA FUN√á√ÉO OTIMIZADA PARA O ZOOM ---
function atualizarZoomLupa(event) {
    const ZOOM_LEVEL = 8; // Aumente para mais zoom
    const canvas = document.getElementById('tela-desenho-fullscreen');
    const lupa = document.getElementById('lupa-conta-gotas');
    const lupaPreview = document.getElementById('lupa-cor-preview');
    if (!canvas || !lupa || !lupaPreview) return;

    const canvasRect = canvas.getBoundingClientRect();

    // Compatibilidade com mouse e toque
    const clientX = event.touches ? event.touches[0].clientX : event.clientX;
    const clientY = event.touches ? event.touches[0].clientY : event.clientY;

    // 1. Calcula a posi√ß√£o do cursor RELATIVA ao canto superior esquerdo do canvas
    const x = clientX - canvasRect.left;
    const y = clientY - canvasRect.top;

    // 2. Define o tamanho do fundo (imagem ampliada)
    lupaPreview.style.backgroundSize = `${canvasRect.width * ZOOM_LEVEL}px ${canvasRect.height * ZOOM_LEVEL}px`;

    // 3. Define a posi√ß√£o do fundo para centralizar o ponto exato do cursor
    lupaPreview.style.backgroundPosition = `-${x * ZOOM_LEVEL - lupa.offsetWidth / 2}px -${y * ZOOM_LEVEL - lupa.offsetHeight / 2}px`;
    
    // 4. ATUALIZA√á√ÉO DA BORDA EM TEMPO REAL (Resolve o Problema 2)
    const pontoTransformado = getTransformedPoint(clientX, clientY); // Converte para as coordenadas REAIS do canvas
    const ctx = canvas.getContext('2d');
    const pixel = ctx.getImageData(pontoTransformado.x, pontoTransformado.y, 1, 1).data;
    const corHex = `#${('0' + pixel[0].toString(16)).slice(-2)}${('0' + pixel[1].toString(16)).slice(-2)}${('0' + pixel[2].toString(16)).slice(-2)}`;
    lupa.style.borderColor = corHex;
}


// --- FUN√á√ÉO ATUALIZADA (l√≥gica interna mantida, mas agora sabemos que recebe os dados corretos) ---
function pegarCorDoCanvas(x, y) {
  const canvas = document.getElementById('tela-desenho-fullscreen');
  if (!canvas) return;
  
  const ctx = canvas.getContext('2d');
  
  // A fun√ß√£o agora recebe as coordenadas J√Å CORRIGIDAS, resolvendo o Problema 3.
  const pixel = ctx.getImageData(x, y, 1, 1).data;
  const r = pixel[0];
  const g = pixel[1];
  const b = pixel[2];

  const paraHex = c => ('0' + c.toString(16)).slice(-2);
  const corHex = `#${paraHex(r)}${paraHex(g)}${paraHex(b)}`;

  corPincel = corHex;
  const seletorCorEl = document.getElementById('cor-pincel');
  if (seletorCorEl) {
    seletorCorEl.value = corHex;
  }
  
  mostrarPopup("üíß Cor Capturada", `A cor ${corHex} foi selecionada!`, 2000);
  definirModoGlobal('pincel'); // Volta para o modo pincel automaticamente
}


// --- FUN√á√ÉO PRINCIPAL DE CONFIGURA√á√ÉO (com os novos listeners) ---
function configurarTelaDeDesenho(equipeId) {
  const previewCanvas = document.getElementById(`preview-canvas-${equipeId}`);
  const fullscreenCanvas = document.getElementById('tela-desenho-fullscreen');
  const previewContainer = document.getElementById(`preview-container-${equipeId}`);
  const lupaEl = document.getElementById('lupa-conta-gotas');

  if (!previewCanvas || !fullscreenCanvas || !lupaEl) {
      console.error(`Elementos essenciais para o desenho da equipe ${equipeId} n√£o encontrados.`);
      return {};
  }
  
  const bufferCanvas = document.createElement('canvas');
  const bufferCtx = bufferCanvas.getContext('2d');
  const previewCtx = previewCanvas.getContext('2d');
  const fullCtx = fullscreenCanvas.getContext('2d');

  const CANVAS_LARGURA_FIXA = 800;
  const CANVAS_ALTURA_FIXA = 600;
  
  let desenhando = false;
  let caminhoAtual = [];
  let todosOsCaminhos = [];
  let ultimoPonto = null;
  let unsubscribeListener = null;

  function setupCanvases() {
    fullscreenCanvas.width = CANVAS_LARGURA_FIXA;
    fullscreenCanvas.height = CANVAS_ALTURA_FIXA;
    bufferCanvas.width = CANVAS_LARGURA_FIXA;
    bufferCanvas.height = CANVAS_ALTURA_FIXA;
    const rectPreview = previewContainer.getBoundingClientRect();
    previewCanvas.width = rectPreview.width;
    previewCanvas.height = rectPreview.height;
    redesenharTudo(true);
  }

  function getCorAtual() {
      return modoAtual === 'borracha' ? '#FFFFFF' : corPincel;
  }

  function iniciarDesenho(ponto) {
    if (!podeDesenhar(equipeId) || modoAtual === 'conta-gotas') return;
    desenhando = true;
    ultimoPonto = ponto;
    caminhoAtual = { pontos: [ponto], cor: getCorAtual(), tamanho: tamanhoPincel };
  }

  function desenhar(ponto) {
    if (!desenhando || !podeDesenhar(equipeId) || modoAtual === 'conta-gotas') return;
    caminhoAtual.pontos.push(ponto);
    fullCtx.beginPath();
    fullCtx.moveTo(ultimoPonto.x, ultimoPonto.y);
    fullCtx.lineTo(ponto.x, ponto.y);
    fullCtx.strokeStyle = getCorAtual();
    fullCtx.lineWidth = tamanhoPincel; 
    fullCtx.lineCap = 'round';
    fullCtx.lineJoin = 'round';
    fullCtx.stroke();
    ultimoPonto = ponto;
  }

  function pararDesenho() {
    if (!desenhando) return;
    desenhando = false;
    ultimoPonto = null;
    if (caminhoAtual.pontos.length > 1) {
      todosOsCaminhos.push(caminhoAtual);
      salvarCaminhoNoFirestore(caminhoAtual.pontos, caminhoAtual.cor, caminhoAtual.tamanho);
    }
    caminhoAtual = [];
    redesenharTudo(true);
  }
  
  function redesenharTudo(redesenhoCompleto = false) {
    if (redesenhoCompleto) {
      bufferCtx.clearRect(0, 0, bufferCanvas.width, bufferCanvas.height);
      previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
      const scaleXPreview = previewCanvas.width / CANVAS_LARGURA_FIXA;

      todosOsCaminhos.forEach(caminho => {
        if (!caminho || !caminho.pontos || caminho.pontos.length < 2) return;
        const contextosParaDesenhar = [bufferCtx, previewCtx];
        contextosParaDesenhar.forEach(ctx => {
            ctx.beginPath();
            ctx.strokeStyle = caminho.cor;
            ctx.lineWidth = (ctx === previewCtx) ? (caminho.tamanho * scaleXPreview) : caminho.tamanho;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            const scale = (ctx === previewCtx) ? scaleXPreview : 1;
            ctx.moveTo(caminho.pontos[0].x * scale, caminho.pontos[0].y * scale);
            for (let i = 1; i < caminho.pontos.length; i++) {
                ctx.lineTo(caminho.pontos[i].x * scale, caminho.pontos[i].y * scale);
            }
            ctx.stroke();
        });
      });
    }

    if (activeDrawingTeam === equipeId) {
      fullCtx.clearRect(0, 0, fullscreenCanvas.width, fullscreenCanvas.height);
      fullCtx.drawImage(bufferCanvas, 0, 0);
    }
  }

  const desenhosRef = collection(db, `desenhos_${equipeId}`);
  
  async function salvarCaminhoNoFirestore(pontos, cor, tamanho) {
    try {
      await limparHistoricoRefazer(equipeId);
      await addDoc(desenhosRef, { pontos, cor, tamanho, timestamp: new Date(), desenhadoPor: currentUser });
    } catch (error) { console.error("Erro ao salvar:", error); }
  }
  
  // VERS√ÉO SIMPLIFICADA: Apenas carrega os tra√ßos e redesenha.
  unsubscribeListener = onSnapshot(query(desenhosRef, orderBy("timestamp")), (snapshot) => {
    todosOsCaminhos = [];
    snapshot.forEach(doc => todosOsCaminhos.push(doc.data()));
    redesenharTudo(true);
  });

  const onMouseDown = (e) => {
    if (modoAtual !== 'pincel' && modoAtual !== 'borracha') return;
    iniciarDesenho(getTransformedPoint(e.clientX, e.clientY));
  };
  const onMouseMove = (e) => {
    if (!desenhando) return;
    desenhar(getTransformedPoint(e.clientX, e.clientY));
  };
  const onMouseUp = () => pararDesenho();
  
  const onTouchStart = (e) => {
    if (modoAtual !== 'pincel' && modoAtual !== 'borracha' || e.touches.length > 1) return;
    iniciarDesenho(getTransformedPoint(e.touches[0].clientX, e.touches[0].clientY));
  };
  const onTouchMove = (e) => {
    if (!desenhando || e.touches.length > 1) return;
    desenhar(getTransformedPoint(e.touches[0].clientX, e.touches[0].clientY));
  };
  const onTouchEnd = () => pararDesenho();

  const iniciarArrastoLupa = (e) => {
    if (modoAtual !== 'conta-gotas' || !podeDesenhar(activeDrawingTeam)) return;
    e.preventDefault(); isLupaDragging = true; lupaEl.style.cursor = 'grabbing';
  };
  const arrastarLupa = (e) => {
    if (!isLupaDragging || (e.touches && e.touches.length > 1)) return;
    e.preventDefault();
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    lupaEl.style.left = `${clientX}px`; lupaEl.style.top = `${clientY}px`;
    atualizarZoomLupa(e);
  };
  const finalizarArrastoLupa = (e) => {
    if (!isLupaDragging) return;
    e.preventDefault(); isLupaDragging = false; lupaEl.style.cursor = 'grab';
    const clientX = e.changedTouches ? e.changedTouches[0].clientX : e.clientX;
    const clientY = e.changedTouches ? e.changedTouches[0].clientY : e.clientY;
    pegarCorDoCanvas(getTransformedPoint(clientX, clientY).x, getTransformedPoint(clientX, clientY).y);
  };

  function addEventListeners() {
    fullscreenCanvas.addEventListener('mousedown', onMouseDown);
    fullscreenCanvas.addEventListener('mousemove', onMouseMove);
    document.addEventListener('mouseup', onMouseUp);
    fullscreenCanvas.addEventListener('mouseleave', onMouseUp);
    fullscreenCanvas.addEventListener('touchstart', onTouchStart, { passive: false });
    fullscreenCanvas.addEventListener('touchmove', onTouchMove, { passive: false });
    document.addEventListener('touchend', onTouchEnd);
    lupaEl.addEventListener('mousedown', iniciarArrastoLupa);
    lupaEl.addEventListener('touchstart', iniciarArrastoLupa, { passive: false });
    window.addEventListener('mousemove', arrastarLupa);
    window.addEventListener('touchmove', arrastarLupa, { passive: false });
    window.addEventListener('mouseup', finalizarArrastoLupa);
    window.addEventListener('touchend', finalizarArrastoLupa);
    document.getElementById('desfazer-btn').onclick = window.desfazerAcao;
    document.getElementById('refazer-btn').onclick = window.refazerAcao;
  }

  function removeEventListeners() {
    fullscreenCanvas.removeEventListener('mousedown', onMouseDown);
    fullscreenCanvas.removeEventListener('mousemove', onMouseMove);
    document.removeEventListener('mouseup', onMouseUp);
    fullscreenCanvas.removeEventListener('mouseleave', onMouseUp);
    fullscreenCanvas.removeEventListener('touchstart', onTouchStart);
    fullscreenCanvas.removeEventListener('touchmove', onTouchMove);
    document.removeEventListener('touchend', onTouchEnd);
    lupaEl.removeEventListener('mousedown', iniciarArrastoLupa);
    lupaEl.removeEventListener('touchstart', iniciarArrastoLupa);
    window.removeEventListener('mousemove', arrastarLupa);
    window.removeEventListener('touchmove', arrastarLupa);
    window.removeEventListener('mouseup', finalizarArrastoLupa);
    window.removeEventListener('touchend', finalizarArrastoLupa);
  }
  
  window.addEventListener('resize', () => { if(activeDrawingTeam === equipeId) setupCanvases(); });

  return { setupCanvases, addEventListeners, removeEventListeners, unsubscribe: unsubscribeListener };
}
// ========================================================================
// FIM DO BLOCO DE C√ìDIGO CORRIGIDO
// ========================================================================

// FUN√á√ÉO SIMPLIFICADA E CORRIGIDA (Visualiza√ß√£o em Tela Cheia permitida)
async function abrirModalDesenho(equipeId) {
  
  openModal('desenho-modal'); 

  if (!drawingContexts[equipeId]) {
    console.log(`Contexto de desenho criado sob demanda para a equipe ${equipeId}.`);
    drawingContexts[equipeId] = configurarTelaDeDesenho(equipeId);
  }

  if (activeDrawingTeam && drawingContexts[activeDrawingTeam]) {
    const contextoAnterior = drawingContexts[activeDrawingTeam];
    if (contextoAnterior.removeEventListeners) contextoAnterior.removeEventListeners();
  }

  activeDrawingTeam = equipeId;
  const podeEditar = podeDesenhar(equipeId);
  const toolbar = document.getElementById('desenho-toolbar');
  
  // Remove qualquer overlay de bloqueio antigo, se existir
  let overlayBloqueio = document.getElementById('desenho-modal-overlay-bloqueio');
  if (overlayBloqueio) overlayBloqueio.remove();

  if (podeEditar) {
    // Se pode editar: Mostra barra de ferramentas e ativa o pincel
    toolbar.style.display = 'flex';
    definirModoGlobal('pincel');
  } else {
    // Se N√ÉO pode editar (Ter√ßa/Quarta ou n√£o √© da equipe):
    // 1. Esconde a barra de ferramentas (l√°pis, borracha, cores)
    toolbar.style.display = 'none';
    
    // 2. For√ßa o modo de apenas "Arrastar/Zoom" (M√£ozinha)
    definirModoGlobal('arrastar');
    
    // 3. Mostra um aviso discreto (Card Popup) em vez de bloquear a tela toda
    mostrarPopup("üîí Apenas Visualiza√ß√£o", "A edi√ß√£o est√° fechada. Voc√™ pode dar zoom e arrastar para ver os detalhes.", 3000);
  }

  const contextoAtual = drawingContexts[equipeId];
  if (contextoAtual) {
    setTimeout(() => {
      if (contextoAtual.setupCanvases) contextoAtual.setupCanvases();
      if (contextoAtual.addEventListeners) contextoAtual.addEventListeners();
    }, 50);
  }
}

// NOVA FUN√á√ÉO para salvar a "foto" do canvas
async function salvarSnapshotAoFechar() {
  if (!activeDrawingTeam) return;

  try {
    const canvas = document.getElementById('tela-desenho-fullscreen');

    // --- ALTERA√á√ÉO PRINCIPAL AQUI ---
    // ANTES (com compress√£o para economizar espa√ßo):
    // const dataURL = canvas.toDataURL('image/webp', 0.8);

    // DEPOIS (qualidade m√°xima, sem perdas, usando PNG):
    const dataURL = canvas.toDataURL('image/png');
    // --------------------------------

    const semana = getSemanaAtual();
    const docId = `semana_${semana.numero}_${semana.inicio.getFullYear()}`;
    const previewsRef = doc(db, "vantagemSemanal", docId);

    const updateData = {
      desenhoPreviews: {
        [activeDrawingTeam]: {
          imageDataURL: dataURL,
          timestamp: new Date()
        }
      }
    };

    await setDoc(previewsRef, updateData, { merge: true });
    console.log(`Snapshot (em PNG de alta qualidade) do desenho da equipe ${activeDrawingTeam} salvo com sucesso.`);

  } catch (error) {
    console.error("Erro ao salvar o snapshot do desenho:", error);
  }
}

// FUN√á√ÉO ATUALIZADA para fechar o modal
window.fecharModalDesenho = async function() {
  // PRIMEIRO, salva o snapshot do desenho atual
  await salvarSnapshotAoFechar();

  const lupa = document.getElementById('lupa-conta-gotas');
  if (lupa) {
    lupa.classList.add('hidden');
  }
  
  definirModoGlobal('pincel');
  closeModal('desenho-modal');
}

// NOVA FUN√á√ÉO: Desliga todos os ouvintes de desenho ativos
function desligarTodosOsOuvintesDeDesenho() {
  console.log("Desligando todos os ouvintes de desenho...");
  for (const equipeId in drawingContexts) {
    const context = drawingContexts[equipeId];
    if (context && context.desligarOuvinte) {
      context.desligarOuvinte(); // Chama a fun√ß√£o para parar de ouvir
      console.log(`- Ouvinte da equipe ${equipeId} desligado.`);
    }
  }
  drawingContexts = {}; // Limpa o objeto de contextos
}

// Limpa a tela da equipe correta no Firestore
async function limparTelaDeDesenho(equipeId) {
  console.log(`üßπ Limpando a tela de desenho da equipe: ${equipeId}...`);
  try {
    const q = query(collection(db, `desenhos_${equipeId}`));
    const querySnapshot = await getDocs(q);
    if (querySnapshot.empty) return;

    const batch = writeBatch(db);
    querySnapshot.forEach(doc => batch.delete(doc.ref));
    await batch.commit();
    console.log(`‚úÖ Tela de ${equipeId} limpa com sucesso.`);
  } catch(error) {
    console.error(`Erro ao limpar a tela de ${equipeId}:`, error);
  }
}

// Fun√ß√£o que abre o popup de confirma√ß√£o
function confirmarLimpezaDeTela(equipeId) { // CORRE√á√ÉO: Adicionamos o par√¢metro `equipeId`
  // Verifica se a equipe ativa no modal pode ser editada pelo usu√°rio
  if (podeDesenhar(equipeId)) {
    const nomeEquipeCapitalizado = equipeId.charAt(0).toUpperCase() + equipeId.slice(1);
    document.getElementById('confirm-clear-canvas-text').innerHTML = 
      `Voc√™ tem certeza que deseja apagar permanentemente todo o desenho da equipe <strong>${nomeEquipeCapitalizado}</strong>? <br><br>Esta a√ß√£o n√£o pode ser desfeita.`;
    
    // Configura o bot√£o de confirma√ß√£o para chamar a fun√ß√£o de limpeza com a equipe correta
    document.getElementById('confirm-clear-canvas-btn').onclick = () => executarLimpezaDeTela(equipeId);
    
    openModal('confirm-clear-canvas-modal');
  } else {
    // Caso o usu√°rio n√£o tenha permiss√£o (medida de seguran√ßa)
    mostrarPopup("üö´ Acesso Negado", "Voc√™ n√£o tem permiss√£o para limpar esta tela.", 4000);
  }
}

// Fun√ß√£o que de fato executa a limpeza ap√≥s a confirma√ß√£o
function executarLimpezaDeTela(equipeId) {
  limparTelaDeDesenho(equipeId);
  closeModal('confirm-clear-canvas-modal');
  mostrarPopup("‚úÖ Sucesso", `A tela da equipe ${equipeId} foi limpa.`, 3000);
}

// =============================================
// NOVAS FUN√á√ïES PARA DESFAZER E REFAZER DESENHO
// =============================================

// Fun√ß√£o para limpar o hist√≥rico de "refazer" (necess√°rio quando um novo tra√ßo √© feito)
async function limparHistoricoRefazer(equipeId) {
  const historicoRef = collection(db, `historicoDesfeito_${equipeId}`);
  try {
    const querySnapshot = await getDocs(historicoRef);
    if (querySnapshot.empty) return;

    const batch = writeBatch(db);
    querySnapshot.forEach(doc => {
      batch.delete(doc.ref);
    });
    await batch.commit();
    console.log(`Hist√≥rico de "refazer" para a equipe ${equipeId} foi limpo.`);
  } catch (error) {
    console.error("Erro ao limpar hist√≥rico de refazer:", error);
  }
}

// Fun√ß√£o chamada pelo bot√£o "Desfazer"
window.desfazerAcao = async function() {
  if (!activeDrawingTeam) return;

  const desenhosRef = collection(db, `desenhos_${activeDrawingTeam}`);
  const historicoRef = collection(db, `historicoDesfeito_${activeDrawingTeam}`);
  
  // 1. Encontra o √∫ltimo tra√ßo feito
  const q = query(desenhosRef, orderBy("timestamp", "desc"), limit(1));
  
  try {
    const snapshot = await getDocs(q);
    if (snapshot.empty) {
      mostrarPopup("‚ÑπÔ∏è", "N√£o h√° nada para desfazer.", 2000);
      return;
    }

    const ultimoTracoDoc = snapshot.docs[0];
    const dadosTraco = ultimoTracoDoc.data();

    // 2. Move o tra√ßo para o hist√≥rico de "desfeitos"
    const batch = writeBatch(db);
    batch.set(doc(historicoRef), dadosTraco); // Adiciona ao hist√≥rico
    batch.delete(ultimoTracoDoc.ref); // Remove do desenho principal
    
    await batch.commit();

  } catch (error) {
    console.error("Erro ao desfazer:", error);
    mostrarPopup("‚ùå Erro", "N√£o foi poss√≠vel desfazer a a√ß√£o.", 3000);
  }
};

// Fun√ß√£o chamada pelo bot√£o "Refazer"
window.refazerAcao = async function() {
  if (!activeDrawingTeam) return;

  const desenhosRef = collection(db, `desenhos_${activeDrawingTeam}`);
  const historicoRef = collection(db, `historicoDesfeito_${activeDrawingTeam}`);
  
  // 1. Encontra o √∫ltimo tra√ßo que foi desfeito
  const q = query(historicoRef, orderBy("timestamp", "desc"), limit(1));
  
  try {
    const snapshot = await getDocs(q);
    if (snapshot.empty) {
      mostrarPopup("‚ÑπÔ∏è", "N√£o h√° nada para refazer.", 2000);
      return;
    }

    const ultimoDesfeitoDoc = snapshot.docs[0];
    const dadosTraco = ultimoDesfeitoDoc.data();

    // 2. Move o tra√ßo de volta para o desenho principal
    const batch = writeBatch(db);
    batch.set(doc(desenhosRef), dadosTraco); // Adiciona de volta ao desenho
    batch.delete(ultimoDesfeitoDoc.ref); // Remove do hist√≥rico de desfeitos
    
    await batch.commit();

  } catch (error) {
    console.error("Erro ao refazer:", error);
    mostrarPopup("‚ùå Erro", "N√£o foi poss√≠vel refazer a a√ß√£o.", 3000);
  }
};

// --- Fun√ß√µes do Carrossel de Desenho ---
function iniciarCarrosselDesenho() {
  if (carrosselDesenhoInterval) clearInterval(carrosselDesenhoInterval);

  carrosselDesenhoInterval = setInterval(() => {
    if (!carrosselDesenhoPausado) {
      currentCarrosselDesenhoIndex = (currentCarrosselDesenhoIndex + 1) % 3;
      irParaSlideDesenho(currentCarrosselDesenhoIndex);
    }
  }, 10000);
}

// C√ìDIGO FINAL (CORRIGIDO)
window.irParaSlideDesenho = function(index) {
  const carrosselContainer = document.getElementById("carrossel-container-desenho");
  carrosselContainer.style.transform = `translateX(-${index * 100}%)`;

  const indicadores = document.querySelectorAll('#carrossel-indicadores-desenho .carrossel-indicador');

  // A M√ÅGICA EST√Å AQUI:
  // Este loop faz tudo de uma vez: remove 'ativo' dos antigos e adiciona no novo.
  indicadores.forEach((indicador, i) => {
    indicador.classList.toggle('ativo', i === index);
  });

  currentCarrosselDesenhoIndex = index;
  if (!carrosselDesenhoPausado) {
    iniciarBarraProgressoDesenho(); // A fun√ß√£o da barra de tempo que j√° corrigimos.
  }
}

// FUN√á√ÉO CORRIGIDA
function reiniciarIntervaloCarrosselDesenho() {
  clearInterval(carrosselDesenhoInterval);
  iniciarCarrosselDesenho();
  iniciarBarraProgressoDesenho(); // Adiciona a chamada para reiniciar a barra
}

// Fun√ß√£o de mudar o slide ATUALIZADA
window.mudarSlideDesenho = function(direction) {
  // Agora, esta fun√ß√£o apenas reinicia o intervalo
  reiniciarIntervaloCarrosselDesenho(); 
  
  // O resto da l√≥gica permanece o mesmo
  const totalSlides = 3;
  currentCarrosselDesenhoIndex = (currentCarrosselDesenhoIndex + direction + totalSlides) % totalSlides;
  irParaSlideDesenho(currentCarrosselDesenhoIndex);
}

// C√ìDIGO CORRIGIDO E SIMPLIFICADO
window.togglePausaDesenho = function() {
  carrosselDesenhoPausado = !carrosselDesenhoPausado;
  const botaoPausa = document.getElementById('botao-pausa-desenho');
  const barra = document.getElementById('progresso-indicador-barra-desenho');

  if (carrosselDesenhoPausado) {
    clearInterval(carrosselDesenhoInterval);
    botaoPausa.textContent = '‚ñ∂';
    if (barra) {
      // Para pausar, simplesmente removemos a classe de anima√ß√£o
      const computedWidth = window.getComputedStyle(barra).width;
      barra.classList.remove('animar');
      barra.style.width = computedWidth; // Trava a largura atual
    }
  } else {
    botaoPausa.textContent = '‚è∏';
    if (barra) {
      // Para retomar, adicionamos a classe de anima√ß√£o e reiniciamos o carrossel
      barra.classList.add('animar');
    }
    iniciarCarrosselDesenho(); // Esta fun√ß√£o j√° reinicia a barra corretamente
  }
}

// C√ìDIGO CORRIGIDO

function iniciarBarraProgressoDesenho() {
  const barra = document.getElementById('progresso-indicador-barra-desenho');
  if (barra) {
    // Resetar a barra
    barra.style.transition = 'none';
    barra.style.width = '0%';
    
    // For√ßar reflow para que o reset seja aplicado
    void barra.offsetWidth;
    
    // Agora ativar a anima√ß√£o
    barra.style.transition = 'width 10s linear';
    setTimeout(() => {
      if (!carrosselDesenhoPausado) {
        barra.style.width = '100%';
      }
    }, 10);
    
    // --- IN√çCIO DA L√ìGICA ADICIONADA ---
    // Limpa qualquer timer anterior que estivesse rodando
    if (progressoBarraDesenho) {
      clearTimeout(progressoBarraDesenho);
    }
    
    // Cria um novo timer JS para garantir que a barra zere no final
    progressoBarraDesenho = setTimeout(() => {
      barra.style.width = '0%';
    }, 10000);
    // --- FIM DA L√ìGICA ADICIONADA ---
  }
}

// SUBSTITUA A SUA FUN√á√ÉO ANTIGA POR ESTA

async function enviarComentario(messageId) {
  const sendBtn = document.getElementById('send-comment-btn-modal');
  sendBtn.disabled = true;
  sendBtn.textContent = '‚è≥';

  try {
    const textarea = document.getElementById('comment-textarea-modal');
    const commentTextHTML = textarea.innerHTML.trim();
    const commentTextPuro = textarea.innerText.trim();

    if (!commentTextPuro || commentTextHTML === "<br>") {
      mostrarPopup("‚úçÔ∏è Aten√ß√£o", "Escreva algo para comentar.", 3000);
      return; 
    }

    const messageRef = doc(db, "mural", messageId);
    const commentsRef = collection(db, "mural", messageId, "comments");
    const membroRef = doc(db, "membros", currentUser);
    const newCommentRef = doc(commentsRef); // Pega a refer√™ncia ANTES para ter o ID

    try {
      const userCommentsQuery = query(commentsRef, where("userId", "==", currentUser));
      const userCommentsSnap = await getDocs(userCommentsQuery);

      if (userCommentsSnap.size >= 3) {
        mostrarPopup("üö´ Limite Atingido", "Voc√™ j√° adicionou o m√°ximo de 3 coment√°rios nesta mensagem.", 5000);
        return;
      }

      let messageData;
      let feedEventId = null; 

      await runTransaction(db, async (transaction) => {
        const messageSnap = await transaction.get(messageRef);
        if (!messageSnap.exists()) {
          throw "A mensagem original n√£o foi encontrada.";
        }
        messageData = messageSnap.data();

        const dadosComentario = {
          userId: currentUser,
          texto: commentTextHTML,
          timestamp: new Date(),
          reacoes: EMOJIS_MURAL.reduce((acc, emoji) => ({...acc, [emoji]: []}), {})
        };

        const authorId = messageData.userId;
        if (authorId && authorId !== currentUser && authorId !== 'Or√°culo' && authorId !== 'An√¥nimo') {
          const notificacoesRef = collection(db, "notificacoes");
          const newNotificacaoRef = doc(notificacoesRef);
          transaction.set(newNotificacaoRef, {
             destinatarioId: authorId,
             remetenteNome: currentUser,
             tipo: 'mural-comment',
             conteudo: 'üí¨',
             acao: `comentou na sua mensagem: "${messageData.texto.replace(/<[^>]*>/g, " ").substring(0, 30)}..."`,
             lida: false,
             timestamp: new Date()
          });
          dadosComentario.notificationId = newNotificacaoRef.id;
        }
        
        transaction.set(newCommentRef, dadosComentario);
        transaction.update(messageRef, { commentCount: increment(1) });
        transaction.update(membroRef, { moedas: increment(25) });
      });
      
      mostrarPopup("‚úÖ Sucesso", "Coment√°rio enviado!", 3000);
	  atualizarProgressoProtecao('comentar', newCommentRef.id);
      tocarSom('som-envio');
      mostrarPopupMoedas(25);
      textarea.innerHTML = '';

      const mencoesRegex = /@([\w√°√©√≠√≥√∫√Å√â√ç√ì√ö√¢√™√Æ√¥√ª√Ç√ä√é√î√õ√†√®√¨√≤√π√Ä√à√å√í√ô√£√µ√É√ï√ß√á]+)/g;
      const mencoesEncontradas = commentTextPuro.match(mencoesRegex)?.map(m => m.substring(1)) || [];
      const destinatariosNotificacao = new Set();
      
      if (mencoesEncontradas.length > 0) {
        mencoesEncontradas.forEach(mencao => {
          const autorPostOriginal = messageData.userId;
          if (mencao.toLowerCase() === 'todos') {
            todosMembros.forEach(m => {
              if (m.nome !== currentUser && m.nome !== autorPostOriginal) destinatariosNotificacao.add(m.nome);
            });
          } else if (mencao.toLowerCase().startsWith('equipe')) {
            const nomeEquipe = mencao.substring(6).toLowerCase();
            if (equipes[nomeEquipe]) {
              equipes[nomeEquipe].membros.forEach(m => {
                if (m.nome !== currentUser && m.nome !== autorPostOriginal) destinatariosNotificacao.add(m.nome);
              });
            }
          } else {
            const membroMencionado = todosMembros.find(m => m.nome.toLowerCase() === mencao.toLowerCase());
            if (membroMencionado && membroMencionado.nome !== currentUser && membroMencionado.nome !== autorPostOriginal) {
              destinatariosNotificacao.add(membroMencionado.nome);
            }
          }
        });
      }

      let tituloFeed = 'üí¨ Novo Coment√°rio no Mural!';
      let textoFeed;

      if (destinatariosNotificacao.size > 0) {
        const nomesMencionados = Array.from(destinatariosNotificacao).slice(0, 2);
        let nomesTexto = `<strong>${nomesMencionados.join('</strong> e <strong>')}</strong>`;
        if (destinatariosNotificacao.size > 2) {
          nomesTexto += ` e outros`;
        }
        textoFeed = `<strong>${currentUser}</strong> comentou na mensagem de <strong>${messageData.userId}</strong> e mencionou ${nomesTexto}.`;
      } else {
        textoFeed = `<strong>${currentUser}</strong> comentou na mensagem de <strong>${messageData.userId}</strong> no Mural de Mensagens.`;
      }
      
      feedEventId = await adicionarEventoAoFeed('geral', tituloFeed, textoFeed, { nomeMembro: currentUser, autorMensagem: messageData.userId });

      if (feedEventId) {
          await updateDoc(newCommentRef, { feedEventId: feedEventId });
      }

      // O Or√°culo agora observa e interage com todos os coment√°rios
      setTimeout(() => {
          // Chama a fun√ß√£o de resposta independentemente de men√ß√£o
          gerarRespostaOraculoParaComentario(messageId, newCommentRef.id, commentTextPuro, currentUser);
      }, 2000);

    } catch (error) {
      console.error("Erro no envio de coment√°rio:", error);
      mostrarPopup("‚ùå Erro", error.toString(), 5000);
    }
  } finally {
    sendBtn.disabled = false;
    sendBtn.textContent = '‚û§';
  }
}

// SUBSTITUA A SUA FUN√á√ÉO openCommentsModal() POR ESTA
window.openCommentsModal = async function(messageId) {
  const modalOverlay = document.getElementById('comments-modal');
  openModal('comments-modal');
  
  modalOverlay.removeAttribute('data-theme');
  if (document.body.classList.contains('tema-noite')) modalOverlay.dataset.theme = 'noite';
  else if (document.body.classList.contains('tema-manha')) modalOverlay.dataset.theme = 'manha';
  else if (document.body.classList.contains('tema-tarde')) modalOverlay.dataset.theme = 'tarde';
  
  const commentsList = document.getElementById('comments-list');
  commentsList.innerHTML = '<p class="no-comments">Carregando coment√°rios...</p>';

  const sendBtn = document.getElementById('send-comment-btn-modal');
  sendBtn.onclick = () => enviarComentario(messageId);
  
  const textarea = document.getElementById('comment-textarea-modal');
  const messageRef = doc(db, "mural", messageId);

  // --- IN√çCIO DA CORRE√á√ÉO ---
  try {
    const messageSnap = await getDoc(messageRef);
    if (messageSnap.exists()) {
      const author = messageSnap.data().userId;
      if (author && author !== currentUser && author !== 'Or√°culo' && author !== 'An√¥nimo') {
        // CORRE√á√ÉO 1: Usar .innerHTML em vez de .value para a DIV
        textarea.innerHTML = `@${author},&nbsp;`; // Adiciona um espa√ßo inquebr√°vel
        textarea.focus();

        // CORRE√á√ÉO 2: L√≥gica correta para mover o cursor para o final de uma div contenteditable
        const range = document.createRange();
        const sel = window.getSelection();
        range.selectNodeContents(textarea);
        range.collapse(false); // 'false' colapsa o range para o final
        sel.removeAllRanges();
        sel.addRange(range);
        
      } else {
        textarea.innerHTML = '';
      }
    }
  } catch (e) {
    console.error("Erro ao buscar autor da mensagem:", e);
    textarea.innerHTML = '';
  }
  // --- FIM DA CORRE√á√ÉO ---
  
  const commentsRef = collection(db, "mural", messageId, "comments");
  const q = query(commentsRef, orderBy("timestamp", "asc"));

  onSnapshot(q, (querySnapshot) => {
    commentsList.innerHTML = ''; 
    if (querySnapshot.empty) {
      commentsList.innerHTML = '<p class="no-comments">Nenhum coment√°rio ainda. Seja o primeiro!</p>';
      return;
    }
    querySnapshot.forEach(doc => {
      const comment = doc.data();
      const commentEl = document.createElement('div');
      commentEl.className = 'comment-item';
      
      const timestamp = comment.timestamp.toDate();
      const dataFormatada = timestamp.toLocaleDateString('pt-BR', { day: '2-digit', month: '2-digit' });
      const horaFormatada = timestamp.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit'});
      
      let optionsHTML = '';
      if (comment.userId === currentUser || userRole === 'lider') {
          optionsHTML = `<div class="comment-options-container"><button class="options-btn" onclick="window.openOptionsMenu(event, 'comment', '${messageId}', '${doc.id}')">‚ãÆ</button></div>`;
      }
      
      const reacoes = comment.reacoes || {};
      let reacoesHTML = '';
      let temReacoes = false;
      const emojisOrdenados = Object.keys(reacoes).sort((a, b) => (reacoes[b]?.length || 0) - (reacoes[a]?.length || 0));

      for (const emoji of emojisOrdenados) {
        const reagentes = Array.isArray(reacoes[emoji]) ? reacoes[emoji] : [];
        if (reagentes.length > 0) {
          temReacoes = true;
          const userHasReacted = reagentes.includes(currentUser);
          const reactedClass = userHasReacted ? 'reacted' : '';
          reacoesHTML += `<div class="reacao-display ${reactedClass}" title="Reagido por: ${reagentes.join(', ')}">${emoji} <span class="contador-display">${reagentes.length}</span></div>`;
        }
      }
      const reacoesDisplayContainer = temReacoes ? `<div class="reacoes-display-container">${reacoesHTML}</div>` : '';

      commentEl.innerHTML = `
          <div class="comment-header">
              <strong class="comment-author">${comment.userId}</strong>
              <span class="comment-timestamp">${dataFormatada} √†s ${horaFormatada}</span>
              ${optionsHTML}
          </div>
${(() => {
    let textoComentario = comment.texto || "";
    textoComentario = textoComentario.replace(/@([\w√°√©√≠√≥√∫√Å√â√ç√ì√ö√¢√™√Æ√¥√ª√Ç√ä√é√î√õ√†√®√¨√≤√π√Ä√à√å√í√ô√£√µ√É√ï√ß√á]+)/g, '<span class="mention">@$1</span>');
    return `<p class="comment-text">${textoComentario.replace(/\n/g, '<br>')}</p>`;
})()}
          ${reacoesDisplayContainer}
          <div class="reacao-seletor-bar hidden">
            ${EMOJIS_MURAL.map(emoji => `<button onclick="event.stopPropagation(); window.toggleReacaoComentario(event, '${messageId}', '${doc.id}', '${emoji}')">${emoji}</button>`).join('')}
          </div>
      `;
      commentsList.appendChild(commentEl);
      
      // --- IN√çCIO DA ALTERA√á√ÉO ---
      let pressTimer = null, longPressTriggered = false;

      // Fun√ß√£o reutiliz√°vel para mostrar a barra de rea√ß√µes
      const toggleReactionSelector = () => {
        // Remove outras barras de rea√ß√£o que possam estar abertas
        document.querySelectorAll('.comment-item .reacao-seletor-bar').forEach(bar => {
            if (bar !== commentEl.querySelector('.reacao-seletor-bar')) {
                bar.classList.add('hidden');
            }
        });

        const seletorBar = commentEl.querySelector('.reacao-seletor-bar');
        if (seletorBar) {
          seletorBar.classList.toggle('hidden');
          
          // L√≥gica para fechar ao clicar fora (apenas se a barra foi aberta)
          if (!seletorBar.classList.contains('hidden')) {
            const closeReactionBar = (event) => {
              if (!commentEl.contains(event.target)) {
                seletorBar.classList.add('hidden');
                document.removeEventListener('click', closeReactionBar, true);
              }
            };
            setTimeout(() => document.addEventListener('click', closeReactionBar, true), 100);
          }
        }
      };

      const startPress = (e) => {
        if (e.target.closest('button, a, .reacao-display, .mention')) return;
        longPressTriggered = false;
        pressTimer = setTimeout(() => {
          longPressTriggered = true;
          toggleReactionSelector(); // Chama a fun√ß√£o no toque longo
        }, 500);
      };
      
      const cancelPress = () => clearTimeout(pressTimer);
      
      const endPress = (e) => {
        clearTimeout(pressTimer);
        // Se N√ÉO foi um toque longo, e o clique foi no card (n√£o em um bot√£o)...
        if (!longPressTriggered && !e.target.closest('button, a, .reacao-display, .mention')) {
            toggleReactionSelector(); // ...chama a mesma fun√ß√£o no clique curto!
        }
      };

      commentEl.addEventListener('mousedown', startPress);
      commentEl.addEventListener('mouseup', endPress);
      commentEl.addEventListener('mouseleave', cancelPress);
      commentEl.addEventListener('touchstart', startPress, { passive: true });
      commentEl.addEventListener('touchend', endPress);
      // --- FIM DA ALTERA√á√ÉO ---
    });
    commentsList.scrollTop = commentsList.scrollHeight;
  });
}

// COLE ESTA NOVA FUN√á√ÉO NO SEU C√ìDIGO

// NOVA FUN√á√ÉO "MESTRA": Gera rea√ß√£o e resposta em uma √∫nica chamada de IA.
async function gerarReacaoERespostaCombinadaComIA(contexto, instrucoesEspecificas) {
  if (!genAI) return null;

  const prompt = `
    Voc√™ √© o Or√°culo, o mentor s√°bio e carinhoso do Grupo √âpicos.
    Sua tarefa √© analisar um conte√∫do e fornecer DUAS coisas:
    1.  Um emoji de rea√ß√£o apropriado.
    2.  Um texto de resposta curto e acolhedor.

    CONTEXTO PARA SUA AN√ÅLISE:
    ${contexto}

    INSTRU√á√ïES PARA SUA RESPOSTA:
    ${instrucoesEspecificas}

    FORMATO OBRIGAT√ìRIO DA RESPOSTA:
    Sua resposta DEVE ser um JSON v√°lido no formato:
    {
      "emoji": "SEU_EMOJI_AQUI",
      "resposta": "SEU_TEXTO_DE_RESPOSTA_AQUI"
    }
    Apenas o JSON, sem nenhuma outra palavra, explica√ß√£o ou formata√ß√£o.
  `;

  try {
    const textoGerado = await callGenerativeAIWithRetry(prompt);
    const jsonString = textoGerado.match(/{[\s\S]*}/)[0];
    const dados = JSON.parse(jsonString);

    if (dados.emoji && dados.resposta && EMOJIS_MURAL.includes(dados.emoji)) {
      return dados; // Retorna o objeto { emoji, resposta } com sucesso
    }
    throw new Error("JSON da IA est√° incompleto ou o emoji √© inv√°lido.");
  } catch (error) {
    console.error("Or√°culo (Combinado): Erro ao gerar rea√ß√£o e resposta.", error);
    return null; // Retorna nulo em caso de erro
  }
}

// =============================================
// NOVAS FUN√á√ïES PARA GERENCIAR COMENT√ÅRIOS      
// =============================================

async function executarExclusaoComentario() {
  if (!commentIdToDelete || !messageIdForCommentAction) return;

  const messageRef = doc(db, "mural", messageIdForCommentAction);
  const commentRef = doc(messageRef, "comments", commentIdToDelete);

  // Vari√°vel para guardar se o usu√°rio atual era o dono
  let eraMeuComentario = false;

  try {
    await runTransaction(db, async (transaction) => {
      const commentSnap = await transaction.get(commentRef);
      if (commentSnap.exists()) {
          const commentData = commentSnap.data();
          
          // Verifica se o coment√°rio pertence ao usu√°rio logado
          if (commentData.userId === currentUser) {
              eraMeuComentario = true;
          }

          const feedEventId = commentData.feedEventId;
          const notificationId = commentData.notificationId;

          // Apaga o evento do feed, se houver
          if (feedEventId) {
              transaction.delete(doc(db, "resumoSemanalFeed", feedEventId));
          }
          // Apaga a notifica√ß√£o, se houver
          if (notificationId) {
              transaction.delete(doc(db, "notificacoes", notificationId));
          }
      }
      
      transaction.delete(commentRef);
      transaction.update(messageRef, { commentCount: increment(-1) });
    });

    mostrarPopup("‚úÖ Sucesso", "Coment√°rio exclu√≠do!", 3000);
	
	// CORRE√á√ÉO: Verifica se era meu coment√°rio antes de reverter e usa AWAIT
    if (eraMeuComentario) {
        console.log("Removendo progresso de coment√°rio para:", currentUser);
        await reverterProgressoProtecao('comentar', commentIdToDelete);
    }
    
  } catch (error) {
    console.error("Erro ao excluir coment√°rio:", error);
    mostrarPopup("‚ùå Erro", "Falha ao excluir o coment√°rio.", 4000);
  } finally {
    closeModal('confirm-delete-comment-modal');
    commentIdToDelete = null;
    messageIdForCommentAction = null;
  }
}

window.editarComentario = async function(event, messageId, commentId) {
  event.stopPropagation();
  editingCommentId = commentId;
  messageIdForCommentAction = messageId;

  const commentRef = doc(db, "mural", messageId, "comments", commentId);

  try {
    const docSnap = await getDoc(commentRef);
    if (docSnap.exists()) {
      const commentText = docSnap.data().texto;
      document.getElementById('edit-comment-textarea').value = commentText;
      openModal('edit-comment-modal');
    } else {
      throw new Error("Coment√°rio n√£o encontrado.");
    }
  } catch (error) {
    console.error("Erro ao buscar coment√°rio para editar:", error);
    mostrarPopup("‚ùå Erro", "N√£o foi poss√≠vel carregar o coment√°rio para edi√ß√£o.", 4000);
  }
}

// --- NOVA FUN√á√ÉO (Corre√ß√£o do Erro): Prepara a exclus√£o do coment√°rio ---
window.excluirComentario = function(event, messageId, commentId) {
  // Esconde o menu de op√ß√µes
  document.getElementById('global-options-menu').classList.add('hidden'); 
  event.stopPropagation();

  // Define as vari√°veis globais para a fun√ß√£o de execu√ß√£o saber o que apagar
  commentIdToDelete = commentId;
  messageIdForCommentAction = messageId;

  // Abre o modal de confirma√ß√£o existente
  openModal('confirm-delete-comment-modal');
}

async function salvarEdicaoComentario() {
  if (!editingCommentId || !messageIdForCommentAction) return;

  const newText = document.getElementById('edit-comment-textarea').value.trim();
  if (!newText) {
    mostrarPopup("‚úçÔ∏è Aten√ß√£o", "O coment√°rio n√£o pode ficar vazio.", 3000);
    return;
  }

  const commentRef = doc(db, "mural", messageIdForCommentAction, "comments", editingCommentId);

  try {
    await updateDoc(commentRef, {
      texto: newText
    });
    mostrarPopup("‚úÖ Sucesso", "Coment√°rio atualizado!", 3000);
  } catch (error) {
    console.error("Erro ao salvar edi√ß√£o do coment√°rio:", error);
    mostrarPopup("‚ùå Erro", "N√£o foi poss√≠vel salvar as altera√ß√µes.", 4000);
  } finally {
    closeModal('edit-comment-modal');
    editingCommentId = null;
    messageIdForCommentAction = null;
  }
}

// =============================================
// FUN√á√ÉO CORRIGIDA E DEFINITIVA PARA O MENU GLOBAL (v3.0)
// =============================================
window.openOptionsMenu = function(event, type, itemId, commentId = null) {
  event.stopPropagation();
  const menu = document.getElementById('global-options-menu');

  // A l√≥gica de abrir/fechar que j√° funciona continua aqui
  if (!menu.classList.contains('hidden')) {
      menu.classList.add('hidden');
      if (window.closeMenuOnClickOutside) {
        document.removeEventListener('click', window.closeMenuOnClickOutside, true);
      }
      return; 
  }

  if (window.closeMenuOnClickOutside) {
    document.removeEventListener('click', window.closeMenuOnClickOutside, true);
  }

  // Popula o menu (sem altera√ß√µes)
  menu.innerHTML = '';
  if (type === 'message') {
    menu.innerHTML = `
      <button onclick="window.editarMensagem(event, '${itemId}')">Editar</button>
      <button onclick="window.excluirMensagem(event, '${itemId}')">Excluir</button>
    `;
  } else if (type === 'comment') {
    menu.innerHTML = `
      <button onclick="window.editarComentario(event, '${itemId}', '${commentId}')">Editar</button>
      <button onclick="window.excluirComentario(event, '${itemId}', '${commentId}')">Excluir</button>
    `;
  }
  
  const buttonRect = event.target.getBoundingClientRect();
  
  // --- IN√çCIO DA CORRE√á√ÉO DEFINITIVA PARA O POSICIONAMENTO ---
  // Capturamos o quanto a p√°gina foi rolada na vertical.
  const scrollTop = window.scrollY || document.documentElement.scrollTop;
  
  // Somamos a rolagem da p√°gina (scrollTop) √† posi√ß√£o do bot√£o na tela (buttonRect.bottom).
  // Isso nos d√° a posi√ß√£o absoluta correta no documento.
  menu.style.top = `${scrollTop + buttonRect.bottom + 5}px`;
  // --- FIM DA CORRE√á√ÉO DEFINITIVA ---
  
  // A l√≥gica de posicionamento horizontal continua a mesma
  const menuWidth = 140; 
  const spaceRight = window.innerWidth - buttonRect.right;
  const spaceLeft = buttonRect.left;
  if (spaceRight < menuWidth && spaceLeft > spaceRight) {
    menu.style.left = 'auto';
    menu.style.right = `${window.innerWidth - buttonRect.right}px`;
  } else {
    menu.style.left = `${buttonRect.left}px`;
    menu.style.right = 'auto';
  }

  menu.classList.remove('hidden');

  // A l√≥gica de fechar ao clicar fora continua a mesma
  window.closeMenuOnClickOutside = (e) => {
    if (e.target.closest('.options-btn')) {
      return;
    }

    if (!menu.contains(e.target)) {
      menu.classList.add('hidden');
      document.removeEventListener('click', window.closeMenuOnClickOutside, true);
    }
  };

  setTimeout(() => {
    document.addEventListener('click', window.closeMenuOnClickOutside, true);
  }, 0);
}

// NOVA FUN√á√ÉO: Gerencia o carregamento sequencial e a contagem regressiva.
async function iniciarCarregamentoAutomaticoDesenhos() {
    const equipes = ['abelha', 'joaninha', 'vagalume'];
    const TEMPO_CONTAGEM = 5; // Segundos para a contagem regressiva

    // Fun√ß√£o interna que processa uma equipe por vez
    async function processarEquipe(index) {
        if (index >= equipes.length) {
            console.log("Todos os desenhos foram pr√©-carregados.");
            return; // Termina o ciclo
        }

        const equipeAtual = equipes[index];
        const proximaEquipe = equipes[index + 1];

        const previewAtual = document.getElementById(`preview-container-${equipeAtual}`);
        const overlayAtual = previewAtual.querySelector('.loading-overlay');

        // 1. Mostra "Carregando..." na equipe atual
        previewAtual.classList.add('is-loading');
        overlayAtual.textContent = 'Carregando...';
        overlayAtual.classList.remove('hidden');

        // 2. Inicia o carregamento da equipe atual (se ainda n√£o foi carregada)
        console.log(`Pr√©-carregando desenho da equipe: ${equipeAtual}`);
        if (!drawingContexts[equipeAtual]) {
            drawingContexts[equipeAtual] = configurarTelaDeDesenho(equipeAtual);
        }

        // 3. Aguarda um tempo m√≠nimo para a percep√ß√£o de carregamento (opcional)
        await new Promise(resolve => setTimeout(resolve, 1500));

        // 4. Esconde o "Carregando..."
        previewAtual.classList.remove('is-loading');
        overlayAtual.classList.add('hidden');
        console.log(`Desenho da equipe ${equipeAtual} pr√©-carregado.`);

        // 5. Inicia a contagem na PR√ìXIMA equipe (se houver uma)
        if (proximaEquipe) {
            const previewProximo = document.getElementById(`preview-container-${proximaEquipe}`);
            const overlayProximo = previewProximo.querySelector('.loading-overlay');
            let contador = TEMPO_CONTAGEM;

            overlayProximo.textContent = `Carregando em ${contador}...`;
            overlayProximo.classList.remove('hidden');

            const countdownInterval = setInterval(() => {
                contador--;
                overlayProximo.textContent = `Carregando em ${contador}...`;
                if (contador <= 0) {
                    clearInterval(countdownInterval);
                    processarEquipe(index + 1); // Chama o processo para a pr√≥xima equipe
                }
            }, 1000);

            // Permite interromper a contagem com um clique
            previewProximo.onclick = () => {
                clearInterval(countdownInterval);
                overlayProximo.classList.add('hidden');
                abrirModalDesenho(proximaEquipe);
            };
        }
    }

    // Inicia o processo com a primeira equipe da lista
    processarEquipe(0);
}

// Fun√ß√£o que lida com os cliques no √≠cone para revelar a senha
function handleSecretIconClick() {
  maintenanceClickCount++;

  // Reinicia o timer a cada clique
  clearTimeout(maintenanceClickTimer);
  maintenanceClickTimer = setTimeout(() => {
    maintenanceClickCount = 0; // Reseta a contagem se o usu√°rio demorar
  }, 2000); // O usu√°rio tem 2 segundos entre os cliques

  // Se o usu√°rio clicar 5 vezes
  if (maintenanceClickCount === 5) {
    clearTimeout(maintenanceClickTimer); // Para o timer
    maintenanceClickCount = 0; // Reseta a contagem

    const passwordWrapper = document.getElementById('maintenance-password').parentElement;
    if (passwordWrapper) {
      passwordWrapper.classList.remove('hidden');
      // Foca automaticamente no campo de senha para o l√≠der digitar
      document.getElementById('maintenance-password').focus();
    }
  }
}

// =============================================
// L√ìGICA DO MODO DE MANUTEN√á√ÉO
// =============================================

async function handleMaintenanceBypass(event) {
  event.preventDefault();
  
  const passwordInput = document.getElementById('maintenance-password');
  const typedPassword = passwordInput.value.trim();

  // Feedback visual de carregamento (opcional, mas bom ter)
  passwordInput.disabled = true;

  try {
    // Busca a senha no Firestore
    const segredosRef = doc(db, "configuracoes", "segredos");
    const docSnap = await getDoc(segredosRef);

    let senhaCorreta = null;
    if (docSnap.exists()) {
        senhaCorreta = docSnap.data().maintenancePassword;
    }

    // Verifica
    if (senhaCorreta && typedPassword === senhaCorreta) {
      sessionStorage.setItem('maintenanceBypass', 'true');
      location.reload();
    } else {
      throw new Error("Senha incorreta");
    }

  } catch (error) {
    console.error("Erro na verifica√ß√£o de manuten√ß√£o:", error);
    passwordInput.disabled = false;
    passwordInput.classList.add('error');
    setTimeout(() => passwordInput.classList.remove('error'), 500);
    passwordInput.focus();
  }
}

// --- L√≥gica do Backdoor de Administrador ---
let adminSeedClickCount = 0;
let adminSeedTimer = null;

function setupAdminBackdoor() {
    const seedBtn = document.getElementById('admin-trigger-seed');
    if (!seedBtn) return;

    seedBtn.addEventListener('click', () => {
        adminSeedClickCount++;
        
        clearTimeout(adminSeedTimer);
        adminSeedTimer = setTimeout(() => {
            adminSeedClickCount = 0;
        }, 2000); // Reseta se parar de clicar por 2 segundos

        if (adminSeedClickCount === 5) {
            adminSeedClickCount = 0;
            clearTimeout(adminSeedTimer);
            abrirAdminModal();
        }
    });

    // Listener para o bot√£o de verificar senha
    document.getElementById('btn-admin-verify').addEventListener('click', verificarSenhaMestra);
	
	// --- C√ìDIGO NOVO: Permite apertar Enter no input ---
    document.getElementById('admin-master-password').addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            verificarSenhaMestra();
        }
    });
    
    // Listener para busca/filtro
    document.getElementById('admin-search-user').addEventListener('input', (e) => {
        filtrarListaUsuariosAdmin(e.target.value);
    });
}

function abrirAdminModal() {
    // Reseta o estado do modal
    document.getElementById('admin-backdoor-step-1').classList.remove('hidden');
    document.getElementById('admin-backdoor-step-2').classList.add('hidden');
    document.getElementById('admin-master-password').value = '';
    openModal('admin-backdoor-modal');
}

async function verificarSenhaMestra() {
    const input = document.getElementById('admin-master-password');
    const btn = document.getElementById('btn-admin-verify');
    const senhaDigitada = input.value.trim();

    if (!senhaDigitada) return;

    btn.textContent = "Verificando...";
    btn.disabled = true;

    try {
        const segredosRef = doc(db, "configuracoes", "segredos");
        const docSnap = await getDoc(segredosRef);

        if (docSnap.exists() && docSnap.data().adminMasterPassword === senhaDigitada) {
            // Sucesso! Carregar usu√°rios
            await carregarListaUsuariosAdmin();
            document.getElementById('admin-backdoor-step-1').classList.add('hidden');
            document.getElementById('admin-backdoor-step-2').classList.remove('hidden');
        } else {
            mostrarPopup("üö´ Acesso Negado", "Senha secreta incorreta.", 3000);
            input.value = '';
        }
    } catch (error) {
        console.error("Erro ao verificar senha secreta:", error);
        mostrarPopup("‚ùå Erro", "Falha na conex√£o.", 3000);
    } finally {
        btn.textContent = "Acessar";
        btn.disabled = false;
    }
}

let cacheMembrosAdmin = [];

async function carregarListaUsuariosAdmin() {
    const listaDiv = document.getElementById('admin-users-list');
    listaDiv.innerHTML = '<div class="ociosos-placeholder">Carregando membros...</div>';

    try {
        // Busca todos os membros
        const querySnapshot = await getDocs(collection(db, "membros"));
        cacheMembrosAdmin = [];

        querySnapshot.forEach((doc) => {
            const data = doc.data();
            cacheMembrosAdmin.push({
                nome: doc.id, // O ID √© o nome de usu√°rio
                equipe: data.equipe || 'Sem Equipe',
                papel: data.papel || 'membro'
            });
        });

        // Ordena alfabeticamente
        cacheMembrosAdmin.sort((a, b) => a.nome.localeCompare(b.nome));
        
        renderizarListaAdmin(cacheMembrosAdmin);

    } catch (error) {
        listaDiv.innerHTML = '<div class="ociosos-placeholder">Erro ao carregar lista.</div>';
    }
}

function renderizarListaAdmin(lista) {
    const listaDiv = document.getElementById('admin-users-list');
    listaDiv.innerHTML = '';

    lista.forEach(membro => {
        const div = document.createElement('div');
        div.className = 'admin-user-item';
        
        let icon = 'üë§';
        if (membro.papel === 'lider') icon = 'üëë';
        else if (membro.papel === 'lider-equipe') icon = '‚≠ê';

        div.innerHTML = `
            <span>${icon} <strong>${membro.nome}</strong> <small>(${membro.equipe})</small></span>
            <span style="font-size: 0.8rem; color: #27ae60;">Entrar ‚û§</span>
        `;
        
        div.onclick = () => realizarLoginForcado(membro.nome);
        listaDiv.appendChild(div);
    });
}

function filtrarListaUsuariosAdmin(termo) {
    const termoLower = termo.toLowerCase();
    const filtrados = cacheMembrosAdmin.filter(m => 
        m.nome.toLowerCase().includes(termoLower) || 
        m.equipe.toLowerCase().includes(termoLower)
    );
    renderizarListaAdmin(filtrados);
}

async function realizarLoginForcado(username) {
    closeModal('admin-backdoor-modal');
    
    // Define o usu√°rio no localStorage para persist√™ncia
    localStorage.setItem('loggedInUser', username);
    
    // Reseta vari√°veis globais cr√≠ticas se necess√°rio
    currentUser = username;
    
    mostrarPopup("üöÄ Admin Mode", `Entrando como ${username}...`, 2000);
    
    // Chama a fun√ß√£o de login existente no seu c√≥digo
    // Nota: O terceiro par√¢metro 'true' ativa o Bypass de Admin (ignora bloqueios)
    await performSuccessfulLogin(username, false, true);
}

// =============================================
// NOVA FUN√á√ÉO DE VERIFICA√á√ÉO INICIAL (PASSO 1)
// =============================================
async function verificarEstadoManutencaoInicial() {
  // Se o usu√°rio j√° tem o bypass na sess√£o, a manuten√ß√£o n√£o est√° ativa para ele.
  if (sessionStorage.getItem('maintenanceBypass') === 'true') {
    return false; // Retorna 'false' (n√£o est√° em manuten√ß√£o)
  }

  try {
    const statusRef = doc(db, "appState", "status");
    const docSnap = await getDoc(statusRef);
    
    // Verifica se a manuten√ß√£o est√° ativa no banco de dados.
    const maintenanceActive = docSnap.exists() && docSnap.data().maintenanceActive === true;
    
    return maintenanceActive; // Retorna 'true' ou 'false'
  } catch (error) {
    console.error("Erro ao verificar estado inicial de manuten√ß√£o:", error);
    return false; // Em caso de erro, assume que n√£o est√° em manuten√ß√£o para n√£o bloquear o app.
  }
}


function setupMaintenanceListenerAndCheck() {
  const statusRef = doc(db, "appState", "status");
  const maintenanceOverlay = document.getElementById('maintenance-overlay');
  const maintenancePasswordInput = document.getElementById('maintenance-password');
  const maintenanceBtn = document.getElementById('toggle-maintenance-btn');
  const maintenanceIcon = document.getElementById('maintenance-icon');

  onSnapshot(statusRef, (docSnap) => {
    const maintenanceActive = docSnap.exists() && docSnap.data().maintenanceActive === true;
    const hasBypass = sessionStorage.getItem('maintenanceBypass') === 'true';

    if (maintenanceActive && !hasBypass) {
      maintenanceOverlay.classList.remove('hidden');
      document.body.style.overflow = 'hidden';
    } else {
      maintenanceOverlay.classList.add('hidden');
      document.body.style.overflow = 'auto';
    }

    if (maintenanceBtn) {
      if (maintenanceActive) {
        maintenanceBtn.textContent = 'Desativar Modo de Manuten√ß√£o';
        maintenanceBtn.style.backgroundColor = '#2ecc71';
      } else {
        maintenanceBtn.textContent = 'Ativar Modo de Manuten√ß√£o';
        maintenanceBtn.style.backgroundColor = '#e67e22';
      }
    }
  });

  // --- IN√çCIO DA CORRE√á√ÉO ---
  // Encontra o formul√°rio que acabamos de criar no HTML
  const maintenanceForm = document.getElementById('maintenance-form');

  // Adiciona o listener de "submit" ao formul√°rio, em vez do "keydown" no input
  if (maintenanceForm) {
    maintenanceForm.addEventListener('submit', handleMaintenanceBypass);
  }
  // --- FIM DA CORRE√á√ÉO ---
  
  maintenanceIcon.addEventListener('click', handleSecretIconClick);
}

setupMaintenanceListenerAndCheck();

async function refreshAppUI() {
  mostrarPopup("üîÑ Atualizando", "Aguarde, recarregando a interface...", 2000);
  
  // A ordem √© importante para garantir que a interface seja reconstru√≠da corretamente
  await carregarMembros();
  construirInterface();
  iniciarCalendario();
  
  // Carrega todos os outros componentes da interface em paralelo
  await Promise.all([
    carregarPresenca(),
    carregarPontosSemanais(),
    carregarRankingGeral(),
    carregarAniversariantes(),
    carregarArvoreEpica(),
    carregarStreaks(),
    exibirQuadroFolgas(),
    carregarInformacoesMembros()
  ]);

  // Atualiza os resumos e contadores
  await atualizarResumo();
  atualizarPlacarSemanal();
  atualizarRankingGeral();
  atualizarVisualBloqueio();
  await carregarEExibirMembrosOciosos();
  
  mostrarPopup("‚úÖ Pronto!", "Interface atualizada com sucesso!", 3000);
}

// SUBSTITUA A FUN√á√ÉO openControlPanel PELA VERS√ÉO ABAIXO
async function openControlPanel() {
  const sessoesLiderGeral = document.querySelectorAll('.lider-geral-only');

  if (userRole === 'lider') {
    sessoesLiderGeral.forEach(secao => secao.classList.remove('hidden'));
  } else {
    sessoesLiderGeral.forEach(secao => secao.classList.add('hidden'));
  }

  const selectRemove = document.getElementById('select-member-to-remove');
  const selectTeam = document.getElementById('new-member-team');
  const selectRole = document.getElementById('new-member-role');

  selectRemove.innerHTML = '<option value="">Selecione um membro para remover...</option>';

  todosMembros.forEach(membro => {
    if (membro.nome === currentUser) return;

    if (userRole === 'lider' || (userRole === 'lider-equipe' && membro.equipe === userTeam)) {
      const option = new Option(`${membro.nome} (${membro.equipe || 'Sem equipe'})`, membro.nome);
      selectRemove.appendChild(option);
    }
  });

  if (userRole === 'lider-equipe') {
    selectTeam.value = userTeam;
    selectTeam.disabled = true;
    selectRole.value = 'membro';
  } else {
    selectTeam.disabled = false;
  }

  document.getElementById('new-member-result').textContent = '';
  
  // =======================================================
  // IN√çCIO DO BLOCO DE C√ìDIGO ATUALIZADO (DOMINGO OU SEGUNDA)
  // =======================================================
  const hoje = getHoje();
  const diaSemana = hoje.getDay();
  const semana = getSemanaAtual();
  const popupStateRef = doc(db, "appState", `popupState_${semana.numero}_${semana.inicio.getFullYear()}`);
  
  const btnAvaliacao = document.getElementById('btn-abrir-avaliacao-lideres');
  const btnRecompensa = document.getElementById('btn-abrir-recompensa-equipe');

  // Esconde ambos os bot√µes por padr√£o para resetar o estado
  btnAvaliacao.classList.add('hidden');
  btnRecompensa.classList.add('hidden');
  
  try {
    const popupStateSnap = await getDoc(popupStateRef);
    const popupData = popupStateSnap.exists() ? popupStateSnap.data() : {};

    // L√≥gica para o bot√£o de Avalia√ß√£o do L√çDER GERAL (Domingo) - Sem altera√ß√£o
    if (userRole === 'lider' && diaSemana === 0) { 
      btnAvaliacao.classList.remove('hidden'); // Mostra o bot√£o
      const avaliacaoJaFeita = (popupData.liderGeralAvaliacaoVista || []).includes(currentUser);

      if (avaliacaoJaFeita) {
        btnAvaliacao.textContent = "‚úîÔ∏è Avalia√ß√£o Enviada";
        btnAvaliacao.disabled = true;
      } else {
        btnAvaliacao.textContent = "üëë Avalia√ß√£o Semanal de L√≠deres";
        btnAvaliacao.disabled = false;
        btnAvaliacao.onclick = abrirPopupAvaliacaoLideres;
      }
    }

    // ALTERADO: L√≥gica para o bot√£o de Recompensa do L√çDER DE EQUIPE (Domingo ou Segunda)
    if (userRole === 'lider-equipe' && (diaSemana === 0 || diaSemana === 1)) { 
      const semanaPassada = getSemanaAtual(new Date(hoje.getTime() - 24 * 60 * 60 * 1000));
      const recompensaRef = doc(db, "recompensasLideres", `semana_${semanaPassada.numero}_${semanaPassada.inicio.getFullYear()}`);
      const docSnap = await getDoc(recompensaRef);

      // Mostra o bot√£o APENAS se o l√≠der foi aprovado na avalia√ß√£o
      if (docSnap.exists() && docSnap.data().aprovados.includes(currentUser)) {
        btnRecompensa.classList.remove('hidden'); // Mostra o bot√£o
        
        // Verifica a trava da semana ATUAL (se √© domingo) ou da semana PASSADA (se for segunda)
        let recompensaJaFeita = false;
        if (diaSemana === 0) { // Domingo (usa trava da semana atual)
            recompensaJaFeita = (popupData.liderEquipeRecompensaVista || []).includes(currentUser);
        } else { // Segunda (usa trava da semana atual, pois o popupStateRef j√° √© da semana atual)
            recompensaJaFeita = (popupData.liderEquipeRecompensaVista || []).includes(currentUser);
        }

        if (recompensaJaFeita) {
          btnRecompensa.textContent = "‚úîÔ∏è Recompensas Enviadas";
          btnRecompensa.disabled = true;
        } else {
          btnRecompensa.textContent = "üèÜ Recompensa da Equipe";
          btnRecompensa.disabled = false;
          btnRecompensa.onclick = abrirPopupRecompensaEquipe;
        }
      }
    }
  } catch(e) {
    console.error("Erro ao configurar bot√µes de a√ß√µes semanais:", e);
  }
  // =======================================================
  // FIM DO BLOCO DE C√ìDIGO ATUALIZADO
  // =======================================================
  
  popularPainelOrdemJogos();
  popularPainelAusencia();
  popularPainelGeneros();
  popularPainelIdiomas();
  openModal('control-panel-modal');
}

window.abrirPlacarVantagem = async function() {
  const semana = getSemanaAtual();
  const docId = `semana_${semana.numero}_${semana.inicio.getFullYear()}`;
  const advantageRef = doc(db, "vantagemSemanal", docId);

  const placarCompletosEl = document.getElementById('placar-completos');
  const placarPendentesEl = document.getElementById('placar-pendentes');

  // Limpa o conte√∫do anterior e mostra mensagem de carregamento
  placarCompletosEl.innerHTML = '<li>Carregando...</li>';
  placarPendentesEl.innerHTML = '<li>Carregando...</li>';

  openModal('placar-vantagem-modal');

  try {
    const docSnap = await getDoc(advantageRef);
    const completadoPor = docSnap.exists() ? docSnap.data().completadoPor || {} : {};

    const listaCompletos = [];
    const listaPendentes = [];

    // Separa os membros em duas listas: os que completaram e os que faltam
    todosMembros.forEach(membro => {
      if (completadoPor[membro.nome]) {
        listaCompletos.push({
          nome: membro.nome,
          equipe: membro.equipe,
          timestamp: completadoPor[membro.nome].toDate() // Converte para objeto Date
        });
      } else {
        // ===== ALTERA√á√ÉO AQUI =====
        // Adiciona a verifica√ß√£o !membro.deFerias para ignorar quem est√° de f√©rias.
        if (!membro.deFerias) {
          listaPendentes.push({
              nome: membro.nome,
              equipe: membro.equipe
          });
        }
      }
    });

    // Ordena a lista de completos pela data, do mais antigo para o mais novo
    listaCompletos.sort((a, b) => a.timestamp - b.timestamp);

    // Gera o HTML para a lista de quem completou
    if (listaCompletos.length > 0) {
      placarCompletosEl.innerHTML = listaCompletos.map((membro, index) => {
        const dataFormatada = membro.timestamp.toLocaleDateString('pt-BR');
        const horaFormatada = membro.timestamp.toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' });
        return `
          <div class="placar-item">
            <span class="posicao">${index + 1}¬∫</span>
            <span class="nome ${membro.equipe}">${membro.nome}</span>
            <span class="timestamp">${dataFormatada} √†s ${horaFormatada}</span>
          </div>
        `;
      }).join('');
    } else {
      placarCompletosEl.innerHTML = '<div class="placar-item">Ningu√©m finalizou o jogo ainda.</div>';
    }

    // Gera o HTML para a lista de quem falta
    if (listaPendentes.length > 0) {
      placarPendentesEl.innerHTML = listaPendentes.map(membro => {
        return `
          <div class="placar-item">
             <span class="nome ${membro.equipe}">${membro.nome}</span>
          </div>
        `;
      }).join('');
    } else {
      placarPendentesEl.innerHTML = '<div class="placar-item">Todos os membros finalizaram! Parab√©ns!</div>';
    }

  } catch (error) {
    console.error("Erro ao carregar placar da vantagem:", error);
    mostrarPopup("‚ùå Erro", "N√£o foi poss√≠vel carregar o placar.", 4000);
    closeModal('placar-vantagem-modal');
  }
}

// Fun√ß√£o para ADICIONAR um novo membro (ATUALIZADA COM G√äNERO)
async function handleAddMember() {
  let newName = document.getElementById('new-member-name').value.trim();
  const newTeam = document.getElementById('new-member-team').value;
  const newRole = document.getElementById('new-member-role').value;
  const newGender = document.getElementById('new-member-gender').value; // Captura o g√™nero

  if (!newName) {
    mostrarPopup("‚ùå Erro", "O nome do membro n√£o pode ser vazio.", 3000);
    return;
  }

  // Capitaliza a primeira letra
  newName = newName.charAt(0).toUpperCase() + newName.slice(1);

  // Verifica se o membro j√° existe
  const memberExists = todosMembros.some(m => m.nome.toLowerCase() === newName.toLowerCase());
  if (memberExists) {
    mostrarPopup("‚ùå Erro", `O membro "${newName}" j√° existe!`, 4000);
    return;
  }

  // Gera uma senha provis√≥ria de 5 d√≠gitos
  const provisionalPassword = Math.floor(10000 + Math.random() * 90000).toString();
  const anoAtual = new Date().getFullYear();

  try {
    const newMemberData = {
      equipe: newTeam,
      papel: newRole,
      genero: newGender, // Salva o g√™nero no banco
	  idioma: 'pt-BR',
      senhaProv: provisionalPassword,
      usedProv: 'off',
      folga: "s√°bado", 
      aniversario: "",
      apelido: "",
      filme: "",
      sonho: "",
      musica: "",
      curiosidade: "",
      inventarioAvatar: [
        "corpo_1", "corpo_2", "corpo_3", "corpo_4", "corpo_5",
        "rosto_1", "roupa_1_cor_1", "roupa_1_cor_2", "fundo_1"
      ],
      avatar: criarAvatarPadrao(),
      dataEntrada: new Date(),
      ultimoPopupAnoNovoVisto: anoAtual - 1
    };

    // Adiciona o novo membro ao Firestore
    await setDoc(doc(db, "membros", newName), newMemberData);
    
    // L√≥gica de texto adaptada para o FEED
    let tituloBemVindo = 'üëã Bem-vindo(a) ao Grupo!';
    let textoBemVindo = `Um novo √©pico se juntou a n√≥s! Seja muito bem-vindo(a), <strong>${newName}</strong>!`;

    if (newGender === 'masculino') {
        tituloBemVindo = 'üëã Bem-vindo ao Grupo!';
        textoBemVindo = `Um novo √©pico se juntou a n√≥s! Seja muito bem-vindo, <strong>${newName}</strong>!`;
    } else if (newGender === 'feminino') {
        tituloBemVindo = 'üëã Bem-vinda ao Grupo!';
        textoBemVindo = `Uma nova √©pica se juntou a n√≥s! Seja muito bem-vinda, <strong>${newName}</strong>!`;
    }

    await adicionarEventoAoFeed(
        'geral',
        tituloBemVindo,
        textoBemVindo,
        { nomeMembro: newName }
    );

    // Chama a nova fun√ß√£o para criar a imagem de login (passando o g√™nero)
    await gerarImagemLogin(newName, provisionalPassword, newGender);
    
    openModal('new-member-success-modal');

    // Limpa o campo de nome
    document.getElementById('new-member-name').value = '';
    document.getElementById('new-member-gender').value = 'indefinido'; // Reseta o select
    document.getElementById('new-member-result').textContent = '';

    await refreshAppUI();

  } catch (error) {
    console.error("Erro ao adicionar membro:", error);
    mostrarPopup("‚ùå Falha", "Ocorreu um erro ao salvar o novo membro.", 4000);
  }
}

// Fun√ß√£o para o l√≠der ATIVAR ou DESATIVAR o modo de manuten√ß√£o para todos
async function toggleMaintenanceMode() {
  const statusRef = doc(db, "appState", "status");
  try {
    const docSnap = await getDoc(statusRef);
    const currentState = docSnap.exists() ? docSnap.data().maintenanceActive : false;
    const newState = !currentState;

    await setDoc(statusRef, { maintenanceActive: newState }, { merge: true });

    if (newState) {
      mostrarPopup("‚úÖ Ativado", "O modo de manuten√ß√£o est√° ATIVO. Os usu√°rios ser√£o bloqueados.", 5000);
    } else {
      mostrarPopup("‚úÖ Desativado", "O modo de manuten√ß√£o foi DESATIVADO. Os usu√°rios podem acessar.", 5000);
    }
  } catch (error) {
    console.error("Erro ao alternar modo de manuten√ß√£o:", error);
    mostrarPopup("‚ùå Erro", "N√£o foi poss√≠vel alterar o estado de manuten√ß√£o.", 4000);
  }
}

// Fun√ß√£o para REMOVER um membro (ATUALIZADA)
async function handleRemoveMember() {
  const memberToRemove = document.getElementById('select-member-to-remove').value;

  if (!memberToRemove) {
    mostrarPopup("‚ùå Erro", "Selecione um membro para remover.", 3000);
    return;
  }

  // ===== L√ìGICA ATUALIZADA: Abre o modal de confirma√ß√£o =====
  memberIdToRemove = memberToRemove; // Armazena o ID do membro a ser removido
  document.getElementById('member-to-remove-name').innerText = memberToRemove;
  openModal('confirm-remove-modal');
}

// NOVA FUN√á√ÉO: Executa a remo√ß√£o ap√≥s confirma√ß√£o no modal
async function executeRemoveMember() {
  if (!memberIdToRemove) return;

  try {
    // Remove o documento do membro da cole√ß√£o 'membros'
    await deleteDoc(doc(db, "membros", memberIdToRemove));

    mostrarPopup("‚úÖ Sucesso", `O membro "${memberIdToRemove}" foi removido.`, 4000);

    // Atualiza a interface para remover o membro de todos os locais
    await refreshAppUI();

    // Fecha e reabre o painel para atualizar a lista de remo√ß√£o
    closeModal('control-panel-modal');
    openControlPanel();

  } catch (error) {
    console.error("Erro ao remover membro:", error);
    mostrarPopup("‚ùå Falha", "Ocorreu um erro ao remover o membro.", 4000);
  } finally {
    // Limpa a vari√°vel e fecha o modal de confirma√ß√£o
    memberIdToRemove = null;
    closeModal('confirm-remove-modal');
  }
}

// ===== IN√çCIO DA L√ìGICA DO JOGO DA VANTAGEM (v2.0 com Rod√≠zio) =====

// --- Configura√ß√µes Globais dos Jogos ---
const todosOsJogos = [
    {
        nome: "Jogo da Mem√≥ria",
        initFunction: initMemoryGame,
        htmlContent: '' // O HTML do jogo da mem√≥ria j√° est√° no CSS, ser√° gerado via JS
    },
    {
        nome: "Acerte o Alvo",
        initFunction: initClickerGame,
        htmlContent: `
            <div id="clicker-game-board">
                <div class="clicker-stats">
                    <div id="clicker-score">Pontos: 0</div>
                    <div id="clicker-timer">Tempo: 30</div>
                </div>
                <button id="clicker-start-button">Come√ßar!</button>
            </div>
        `
    },
    {
        nome: "Sequ√™ncia de Cores",
        initFunction: initSimonGame,
        htmlContent: `
            <div id="simon-game-board">
                <div id="simon-info-display">N√≠vel: 1</div>
                <div id="simon-pads-container">
                    <div class="simon-pad" id="simon-pad-0" data-index="0"></div>
                    <div class="simon-pad" id="simon-pad-1" data-index="1"></div>
                    <div class="simon-pad" id="simon-pad-2" data-index="2"></div>
                    <div class="simon-pad" id="simon-pad-3" data-index="3"></div>
                </div>
                <button id="simon-start-button">Iniciar</button>
            </div>
        `
    },
	{
    nome: "Jogo da Velha",
    initFunction: initTicTacToeGame,
    htmlContent: `
        <div id="tictactoe-board-wrapper">
            <div id="tictactoe-symbol-selection">
                <div class="status-display">Escolha seu lado:</div>
                <div class="symbol-buttons">
                    <button id="select-X" class="symbol-btn x">X</button>
                    <button id="select-O" class="symbol-btn o">O</button>
                </div>
            </div>

            <div id="tictactoe-status" class="status-display hidden">Sua vez de jogar (X)</div>
            <div id="tictactoe-board" class="hidden">
                <div class="tictactoe-cell" data-cell-index="0"></div>
                <div class="tictactoe-cell" data-cell-index="1"></div>
                <div class="tictactoe-cell" data-cell-index="2"></div>
                <div class="tictactoe-cell" data-cell-index="3"></div>
                <div class="tictactoe-cell" data-cell-index="4"></div>
                <div class="tictactoe-cell" data-cell-index="5"></div>
                <div class="tictactoe-cell" data-cell-index="6"></div>
                <div class="tictactoe-cell" data-cell-index="7"></div>
                <div class="tictactoe-cell" data-cell-index="8"></div>
                <div id="tictactoe-winning-line" class="winning-line"></div>
            </div>
            <button id="tictactoe-restart-button" class="hidden">Jogar Novamente</button>
        </div>
    `
},
{
        nome: "Quiz dos √âpicos",
        initFunction: initQuizGame, // Criaremos esta fun√ß√£o no pr√≥ximo passo
        htmlContent: `
            <div id="quiz-container" style="display: flex; flex-direction: column; align-items: center; width: 100%; max-width: 700px; padding: 10px;">
                <div id="quiz-progress-bar-container" style="width: 100%; background-color: #e0e0e0; border-radius: 5px; height: 10px; margin-bottom: 15px;">
                    <div id="quiz-progress-bar" style="width: 0%; height: 100%; background-color: #3498db; border-radius: 5px; transition: width 0.3s ease;"></div>
                </div>
                <div id="quiz-question-number" style="font-size: 1rem; color: #7f8c8d; margin-bottom: 10px;">Pergunta 1 de 4</div>
                <h3 id="quiz-question" style="font-size: 1.5rem; text-align: center; min-height: 80px; padding: 15px 0;">Qual o filme favorito de...?</h3>
                <div id="quiz-alternatives" style="display: flex; flex-direction: column; gap: 12px; width: 100%; margin-top: 20px;">
                    </div>
                <div id="quiz-feedback" style="margin-top: 20px; font-weight: bold; font-size: 1.2rem; min-height: 30px;"></div>
            </div>
        `
    },
{
        nome: "Jogo da Forca",
        initFunction: initForcaGame,
        htmlContent: `
            <div id="forca-game-container">
                <div id="forca-status"></div>
                <div class="forca-wrapper">
                    <div class="forca-desenho">
                        <div class="parte-forca forca-base"></div>
                        <div class="parte-forca forca-haste"></div>
                        <div class="parte-forca forca-topo"></div>
                        <div class="parte-forca forca-corda"></div>
                        <div class="enforcado">
                            <div class="parte-corpo cabeca"></div>
                            <div class="parte-corpo tronco"></div>
                            <div class="parte-corpo braco-esq"></div>
                            <div class="parte-corpo braco-dir"></div>
                            <div class="parte-corpo perna-esq"></div>
                            <div class="parte-corpo perna-dir"></div>
                        </div>
                    </div>
                    <div class="forca-info">
                        <div class="palavra-secreta" id="palavra-forca"></div>
                        <div class="dica-container" id="dica-forca"></div>
                    </div>
                </div>
                <div class="teclado-virtual" id="teclado-forca"></div>
                <button id="forca-restart-button">Tentar Novamente</button>
            </div>
        `
    }
];

// Fun√ß√£o para mostrar/esconder o painel de teste de jogos do l√≠der
window.toggleLeaderTestPanel = function() {
  const panel = document.getElementById('leader-test-panel');
  if (panel) {
    panel.classList.toggle('hidden');
  }
}

async function loadAdvantageState() {
    if (!currentUser) return;

    const hoje = getHoje();
    const diaSemana = hoje.getDay(); // 0 = Domingo
    
    // ===== IN√çCIO DA ALTERA√á√ÉO =====
    // Verifica√ß√£o de sessionStorage REMOVIDA.
    // Agora verifica sempre se n√£o for domingo, se tem equipe e se a equipe existe.

    if (diaSemana !== 0 && userTeam && equipes[userTeam]) {
        const semanaPopup = getSemanaAtual();
        const docIdPopup = `semana_${semanaPopup.numero}_${semanaPopup.inicio.getFullYear()}`;
        const advantageRefPopup = doc(db, "vantagemSemanal", docIdPopup);
        
        try {
            const advantageDocPopup = await getDoc(advantageRefPopup);
            const completadoPor = advantageDocPopup.exists() ? advantageDocPopup.data().completadoPor || {} : {};
            const membrosQueCompletaram = new Set(Object.keys(completadoPor));
            const minhaEquipeInfo = equipes[userTeam];
            
            // Filtra os membros de f√©rias
            const membrosFaltantes = minhaEquipeInfo.membros
                .filter(membro => !membrosQueCompletaram.has(membro.nome) && !membro.deFerias) 
                .map(membro => membro.nome);
            
            if (membrosFaltantes.length > 0) {
                const nomesFaltantes = `<strong>- ${membrosFaltantes.join('<br>- ')}</strong>`;
                
                const mensagem = `
                    Para que sua equipe ganhe um b√¥nus de <strong>+3 pontos na m√©dia final</strong> no domingo, todos precisam completar o Jogo da Vantagem.
                    <br><br>
                    Ainda falta(m):
                    <br>
                    ${nomesFaltantes}
                    <br><br>
                    Mande uma mensagem e incentive seus colegas a completarem o desafio!
                `;
                
                // ID √öNICO ADICIONADO: 'alerta_equipe_vantagem'
                mostrarCardPopup("‚ö†Ô∏è Aten√ß√£o, Equipe!", mensagem, null, "Grupo √âpicos", "alerta_equipe_vantagem");
            }
            
            // sessionStorage.setItem REMOVIDO aqui.

        } catch (error) {
            console.error("Erro ao verificar membros pendentes para o popup:", error);
        }
    }
    // ===== FIM DA ALTERA√á√ÉO =====
    
    const leaderControls = document.getElementById('leader-advantage-controls');
    if (userRole === 'lider') {
        leaderControls.classList.remove('hidden');
        document.getElementById('leader-test-button').onclick = window.toggleLeaderTestPanel;

        const gameList = document.getElementById('leader-game-list');
        gameList.innerHTML = ''; 

        todosOsJogos.forEach((jogo, index) => {
            const listItem = document.createElement('li');
            const button = document.createElement('button');
            button.textContent = jogo.nome;
            button.onclick = () => startLeaderTestGame(index); 
            listItem.appendChild(button);
            gameList.appendChild(listItem);
        });
    } else {
        leaderControls.classList.add('hidden');
    }

    const eFimDeSemana = (diaSemana === 0 || diaSemana === 6);

    const semana = getSemanaAtual();
    const docId = `semana_${semana.numero}_${semana.inicio.getFullYear()}`;
    const advantageRef = doc(db, "vantagemSemanal", docId);
    const docSnap = await getDoc(advantageRef);
    
    const dadosSemana = docSnap.exists() ? docSnap.data() : {};
    const usuarioCompletou = dadosSemana.completadoPor?.[currentUser];

    if (usuarioCompletou) {
        lockAdvantageSection("Desafio conclu√≠do! Volte na pr√≥xima semana para mais.");
        document.getElementById('advantage-game-board').innerHTML = '';
        return;
    }
    
    if (eFimDeSemana) {
        lockAdvantageSection("O tempo para este desafio acabou. Ele retorna na Segunda-feira!");
        document.getElementById('advantage-game-board').innerHTML = '';
        return;
    }

    unlockAdvantageSection();

    const gameBoard = document.getElementById('advantage-game-board');
    const nomeJogoEl = document.getElementById('vantagem-jogo-nome');
    let jogoDaSemana;

    try {
        const ordemJogosRef = doc(db, "configuracoes", "ordemJogosVantagem");
        const ordemJogosSnap = await getDoc(ordemJogosRef);
        
        if (ordemJogosSnap.exists() && ordemJogosSnap.data().ordem) {
            const dadosOrdem = ordemJogosSnap.data();
            const ordemSalva = dadosOrdem.ordem;
            const semanaDeInicio = dadosOrdem.semanaDeInicio || semana.numero;
            
            if (ordemSalva.length > 0) {
                console.log("Usando ordem de jogos personalizada do Firestore.");
                const indiceDoJogo = (semana.numero - semanaDeInicio) % ordemSalva.length;
                const indiceFinal = indiceDoJogo < 0 ? indiceDoJogo + ordemSalva.length : indiceDoJogo;
                const nomeDoJogo = ordemSalva[indiceFinal];
                jogoDaSemana = todosOsJogos.find(j => j.nome === nomeDoJogo);
            }
        }

        if (!jogoDaSemana) {
            console.log("Ordem personalizada n√£o encontrada ou inv√°lida. Usando ordem padr√£o.");
            const indiceDoJogo = semana.numero % todosOsJogos.length;
            jogoDaSemana = todosOsJogos[indiceDoJogo];
        }

    } catch (error) {
        console.error("Erro ao buscar ordem de jogos, usando padr√£o:", error);
        const indiceDoJogo = semana.numero % todosOsJogos.length;
        jogoDaSemana = todosOsJogos[indiceDoJogo];
    }

    if (nomeJogoEl) {
        nomeJogoEl.textContent = `Jogo da Semana: ${jogoDaSemana.nome}`;
    }

    gameBoard.innerHTML = jogoDaSemana.htmlContent;

    // =============================================
    // ===== MUDAN√áA PRINCIPAL ACONTECE AQUI! ======
    // =============================================
    if (jogoDaSemana.nome === "Jogo da Forca") {
        let palavraParaJogar = dadosSemana.palavraDaSemana;
        
        // Se ainda n√£o houver uma palavra definida para esta semana...
        if (!palavraParaJogar) {
            // ...chamamos a IA para gerar uma nova!
            palavraParaJogar = await gerarPalavraComIA();
            
            // Salvamos a palavra gerada no banco de dados para que todos
            // os outros membros joguem com a mesma palavra durante a semana.
            await setDoc(advantageRef, { palavraDaSemana: palavraParaJogar }, { merge: true });
            console.log("Nova palavra da semana, gerada pela IA, foi definida:", palavraParaJogar.palavra);
        }
        
        // Inicia o jogo com a palavra (seja a que j√° existia ou a rec√©m-gerada)
        initForcaGame(palavraParaJogar);

    } else if (jogoDaSemana.nome === "Quiz dos √âpicos") {
        const quizQuestions = await gerarQuizDaSemana();
        if (quizQuestions && quizQuestions.length > 0) {
            initQuizGame(quizQuestions);
        } else {
            gameBoard.innerHTML = "<h2>N√£o foi poss√≠vel gerar o quiz desta semana. Verifique se os membros preencheram suas informa√ß√µes. Tente novamente mais tarde.</h2>";
        }
    } else {
        jogoDaSemana.initFunction();
    }
}

// --- Fun√ß√µes de Conclus√£o e Bloqueio (Comuns a todos os jogos) ---
function lockAdvantageSection(message) {
    const overlay = document.getElementById('vantagem-locked-overlay');
    const lockMessage = document.getElementById('vantagem-lock-message');
    if (overlay && lockMessage) {
        lockMessage.textContent = message;
        overlay.classList.remove('hidden');
    }
}

function unlockAdvantageSection() {
    const overlay = document.getElementById('vantagem-locked-overlay');
    if (overlay) {
        overlay.classList.add('hidden');
    }
}

async function saveAdvantageCompletion() {
    if (!currentUser) return;
    const semana = getSemanaAtual();
    const docId = `semana_${semana.numero}_${semana.inicio.getFullYear()}`;
    const advantageRef = doc(db, "vantagemSemanal", docId);
    try {
        // A MUDAN√áA EST√Å AQUI: Salva a data atual em vez de 'true'
        await setDoc(advantageRef, { completadoPor: { [currentUser]: new Date() } }, { merge: true });
        console.log(`Conclus√£o salva para ${currentUser}`);
    } catch (error) {
        console.error("Erro ao salvar conclus√£o:", error);
        mostrarPopup("‚ùå Erro", "N√£o foi poss√≠vel salvar seu progresso.", 4000);
    }
}

async function handleGameWin(gameName) {
    const PONTOS_FIXOS_VANTAGEM = 3; 

    try {
        const membroRef = doc(db, "membros", currentUser);
        await updateDoc(membroRef, { moedas: increment(recompensasConfig.vitoriaJogoVantagem || 50) }); 
        mostrarPopupMoedas(recompensasConfig.vitoriaJogoVantagem || 50);
        console.log(`+50 moedas dadas a ${currentUser} por vencer o ${gameName}.`);
    } catch (error) {
        console.error("Erro ao dar moedas pela vit√≥ria no Jogo da Vantagem:", error);
    }

    const semana = getSemanaAtual();
    const docId = `semana_${semana.numero}_${semana.inicio.getFullYear()}`;
    const advantageRef = doc(db, "vantagemSemanal", docId);
    
    await saveAdvantageCompletion();

    try {
        const advantageDoc = await getDoc(advantageRef);
        const dadosSemana = advantageDoc.exists() ? advantageDoc.data() : {};
        const completadoPor = dadosSemana.completadoPor || {};
        const membrosQueCompletaram = new Set(Object.keys(completadoPor));
        
        const posicao = membrosQueCompletaram.size;
        const textoFeedIndividual = `<strong>${currentUser}</strong> finalizou o <strong>${gameName}</strong> e alcan√ßou a <strong>${posicao}¬™</strong> posi√ß√£o no placar!`;
        await adicionarEventoAoFeed('vantagem', 'üéØ Desafio Conclu√≠do!', textoFeedIndividual, { nomeMembro: currentUser, jogo: gameName, posicao: posicao });

        if (userTeam) {
            const minhaEquipe = equipes[userTeam].membros;
            const todosDaEquipeCompletaram = minhaEquipe.every(membro => membrosQueCompletaram.has(membro.nome));
            const equipesComBonusGarantido = dadosSemana.equipesComBonusGarantido || [];

            if (todosDaEquipeCompletaram && !equipesComBonusGarantido.includes(userTeam)) {
                console.log(`Equipe ${userTeam} completou o desafio! Postando no feed.`);
                // CORRE√á√ÉO: Formata√ß√£o correta para Vaga-lume
                const nomeEquipeCapitalizado = userTeam === 'vagalume' ? 'Vaga-lume' : userTeam.charAt(0).toUpperCase() + userTeam.slice(1);
                
                // ALTERA√á√ÉO AQUI: A mensagem foi atualizada para a nova l√≥gica.
                const textoFeedEquipe = `Miss√£o cumprida! Todos os membros da equipe <strong>${nomeEquipeCapitalizado}</strong> finalizaram o Jogo da Vantagem e garantiram o b√¥nus de <strong>+${PONTOS_FIXOS_VANTAGEM} pontos</strong> em sua m√©dia final no domingo!`;
                
                await adicionarEventoAoFeed('vantagem', 'üèÜ B√¥nus de Equipe Garantido!', textoFeedEquipe, { equipe: userTeam });

                await updateDoc(advantageRef, {
                    equipesComBonusGarantido: arrayUnion(userTeam)
                });
            }
        }
    } catch (error) {
        console.error("Erro ao processar feed de conclus√£o do Jogo da Vantagem:", error);
    }
    
    mostrarPopup(`üéâ Parab√©ns!`, `Voc√™ venceu o ${gameName}!`, 5000);
    dispararConfete();
    tocarSom('som-conquista');
    
    lockAdvantageSection("Desafio conclu√≠do! Volte na pr√≥xima semana.");
}

async function startLeaderTestGame(gameIndex) {
  isTestModeActive = true;
  currentTestGameIndex = gameIndex;
  const game = todosOsJogos[gameIndex];
  const gameBoard = document.getElementById('advantage-game-board');
  const nomeJogoEl = document.getElementById('vantagem-jogo-nome');

  if (!game || !gameBoard || !nomeJogoEl) return;
  
  // Garante que o ID do board esteja correto para os estilos CSS
  gameBoard.id = 'advantage-game-board';
  
  nomeJogoEl.textContent = `Modo de Teste: ${game.nome}`;
  gameBoard.innerHTML = game.htmlContent;

  // --- CORRE√á√ÉO DA FORCA AQUI ---
  if (game.nome === "Jogo da Forca") {
    // Mostra um carregando visual simples enquanto a IA gera
    gameBoard.innerHTML = "<div style='text-align:center; padding: 20px;'><h3>üßô‚Äç O Or√°culo est√° escolhendo uma palavra...</h3></div>";
    
    // Gera a palavra usando a IA (mesma l√≥gica do jogo real)
    const palavraDeTeste = await gerarPalavraComIA();
    
    // Restaura o HTML do jogo e inicia
    gameBoard.innerHTML = game.htmlContent;
    game.initFunction(palavraDeTeste);

  } else if (game.nome === "Quiz dos √âpicos") {
    // L√≥gica do Quiz mantida
    const quizQuestions = await gerarQuizDaSemana();
    if (quizQuestions && quizQuestions.length > 0) {
      game.initFunction(quizQuestions);
    } else {
      gameBoard.innerHTML = "<h2>N√£o foi poss√≠vel gerar um quiz para o teste.</h2>";
    }

  } else {
    // Para todos os outros jogos
    if (game.nome === "Jogo da Mem√≥ria") {
      gameBoard.id = 'memory-game-board';
    }
    game.initFunction();
  }

  document.getElementById('leader-test-panel').classList.add('hidden');
  unlockAdvantageSection();
}

// ==========================================================
// --- JOGO 1: JOGO DA MEM√ìRIA (C√ìDIGO EXISTENTE ADAPTADO) ---
// ==========================================================
// FUN√á√ÉO NOVA E CORRIGIDA
function initMemoryGame() {
    const EMOJIS = ['üß†', 'üî•', 'üöÄ', 'üíé', 'üèÜ', 'üåû', 'üß∏', 'üê∏'];
    let gameFlippedCards = [];
    let gameMatchedPairs = 0;
    let gameLockBoard = false;
    const gameBoard = document.getElementById('advantage-game-board');
    
    // Atribui a classe correta para o CSS, mas N√ÉO muda mais o ID.
    gameBoard.className = 'memory-game-board'; 
    gameBoard.innerHTML = ''; // Limpa o conte√∫do antes de adicionar as cartas.
    
    const gameCards = [...EMOJIS, ...EMOJIS];
    gameCards.sort(() => 0.5 - Math.random());
    
    gameCards.forEach(emoji => {
        const cardElement = document.createElement('div');
        cardElement.classList.add('memory-card');
        cardElement.dataset.emoji = emoji;
        cardElement.innerHTML = `<div class="card-face card-front"></div><div class="card-face card-back">${emoji}</div>`;
        cardElement.addEventListener('click', () => flipCard(cardElement));
        gameBoard.appendChild(cardElement);
    });

    // O resto da l√≥gica interna da fun√ß√£o (flipCard, checkForMatch, etc.)
    // permanece exatamente o mesmo que estava antes.
    function flipCard(card) {
        if (gameLockBoard || card.classList.contains('flipped') || !currentUser) return;
        card.classList.add('flipped');
        gameFlippedCards.push(card);
        if (gameFlippedCards.length === 2) checkForMatch();
    }

    function checkForMatch() {
        gameLockBoard = true;
        const [cardOne, cardTwo] = gameFlippedCards;
        const isMatch = cardOne.dataset.emoji === cardTwo.dataset.emoji;

        if (isMatch) {
            setTimeout(() => {
                cardOne.classList.add('matched');
                cardTwo.classList.add('matched');
                gameMatchedPairs++;
                if (gameMatchedPairs === EMOJIS.length) {
                    setTimeout(() => handleGameWin("Jogo da Mem√≥ria"), 500);
                }
                resetBoard();
            }, 600);
        } else {
            setTimeout(() => {
                cardOne.classList.remove('flipped');
                cardTwo.classList.remove('flipped');
                resetBoard();
            }, 1200);
        }
    }
    function resetBoard() {
        gameFlippedCards = [];
        gameLockBoard = false;
    }
}

// =======================================================
// --- JOGO 2: ACERTE O ALVO (CLICKER GAME) ---
// (VERS√ÉO v3 - BALANCEAMENTO AVAN√áADO PC/MOBILE)
// =======================================================
function initClickerGame() {
    const board = document.getElementById('clicker-game-board');
    const scoreDisplay = document.getElementById('clicker-score');
    const timerDisplay = document.getElementById('clicker-timer');
    const startButton = document.getElementById('clicker-start-button');
    
    // =============================================
    // ===== IN√çCIO DA MODIFICA√á√ÉO (PASSO 2.1) =====
    // =============================================
    
    // 1. Detecta se √© um dispositivo de toque (celular/tablet)
    const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
    
    // 2. Define os par√¢metros com base no dispositivo
    let TARGET_SCORE, TIME_LIMIT, ANIMATION_DURATION, TARGET_LIFESPAN;

    if (isTouchDevice) {
        // --- Configura√ß√£o para Celular (Mais Dif√≠cil) ---
        TARGET_SCORE = 40; // Meta original
        TIME_LIMIT = 25;   // Tempo original
        ANIMATION_DURATION = 4; // Velocidade original da anima√ß√£o (4s)
        TARGET_LIFESPAN = 1500; // Tempo na tela original (1.5s)
    } else {
        // --- Configura√ß√£o para Computador (Mais F√°cil) ---
        TARGET_SCORE = 20; // NOVO: Meta reduzida para 20 pontos
        TIME_LIMIT = 45;   // NOVO: Tempo aumentado para 45 segundos
        ANIMATION_DURATION = 8; // NOVO: Anima√ß√£o dura 8s (metade da velocidade)
        TARGET_LIFESPAN = 2500; // NOVO: Tempo na tela aumentado para 2.5s
    }
    
    let score = 0;
    let timeLeft = TIME_LIMIT;
    // =============================================
    // ===== FIM DA MODIFICA√á√ÉO (PASSO 2.1) =====
    // =============================================
    
    let gameInterval = null;
    let targetCreatorInterval = null;

    if (startButton) {
        startButton.onclick = startGame;
    }

    function startGame() {
        if (!startButton) return;
        startButton.style.display = 'none';
        score = 0;
        timeLeft = TIME_LIMIT; 
        
        if (scoreDisplay) scoreDisplay.textContent = `Pontos: 0 / ${TARGET_SCORE}`;
        if (timerDisplay) {
          timerDisplay.textContent = `Tempo: ${timeLeft}`;
          timerDisplay.classList.remove('ending');
        }

        gameInterval = setInterval(() => {
            timeLeft--;
            if (timerDisplay) timerDisplay.textContent = `Tempo: ${timeLeft}`;
            if (timeLeft <= 5 && timerDisplay) timerDisplay.classList.add('ending');
            if (timeLeft <= 0) endGame(false); 
        }, 1000);
        
        // Frequ√™ncia de cria√ß√£o de alvos (mantida)
        targetCreatorInterval = setInterval(createTarget, 450);
    }
    
    function createTarget() {
        if (!board) return;
        const target = document.createElement('div');
        target.classList.add('clicker-target');

        const teamEmojis = ['üêù', 'üêû', 'üí°'];
        const randomTeam = ['abelha', 'joaninha', 'vagalume'][Math.floor(Math.random() * 3)];
        target.classList.add(randomTeam);
        target.textContent = teamEmojis[Math.floor(Math.random() * 3)];
        
        target.style.top = `${10 + Math.random() * 70}%`;
        target.style.left = `${10 + Math.random() * 70}%`;
        
        // =============================================
        // ===== IN√çCIO DA MODIFICA√á√ÉO (PASSO 2.2) =====
        // =============================================
        // 3. Aplica a velocidade de anima√ß√£o correta
        target.style.animation = `pop-in 0.3s ease-out, moveTarget ${ANIMATION_DURATION}s ease-in-out infinite`;
        // =============================================
        // ===== FIM DA MODIFICA√á√ÉO (PASSO 2.2) =====
        // =============================================
        
        target.onclick = () => {
            score++;
            if (scoreDisplay) scoreDisplay.textContent = `Pontos: ${score} / ${TARGET_SCORE}`;
            target.classList.add('clicked');
            if (score >= TARGET_SCORE) {
                endGame(true); // Venceu!
            }
            setTimeout(() => target.remove(), 300);
        };
        
        board.appendChild(target);
        
        // =============================================
        // ===== IN√çCIO DA MODIFICA√á√ÉO (PASSO 2.3) =====
        // =============================================
        // 4. Aplica o tempo de vida correto
        setTimeout(() => {
            if (target && target.parentElement) target.remove();
        }, TARGET_LIFESPAN);
        // =============================================
        // ===== FIM DA MODIFICA√á√ÉO (PASSO 2.3) =====
        // =============================================
    }
    
    function endGame(isWinner) {
        clearInterval(gameInterval);
        clearInterval(targetCreatorInterval);
        
        if (!board) return;
        board.innerHTML = ''; // Limpa os alvos restantes

        if(isWinner) {
            handleGameWin("Acerte o Alvo");
        } else {
            const resultText = document.createElement('div');
            resultText.innerHTML = `Tempo esgotado! Voc√™ fez ${score} pontos.<br>Tente novamente!`;
            resultText.style.fontSize = '1.5rem';
            resultText.style.textAlign = 'center';
            board.appendChild(resultText);
            
            setTimeout(() => {
                const clickerGameData = todosOsJogos.find(jogo => jogo.nome === "Acerte o Alvo");
                if (clickerGameData) {
                    const gameContainer = document.getElementById('advantage-game-board');
                    gameContainer.innerHTML = clickerGameData.htmlContent;
                    initClickerGame(); 
                }
            }, 4000);
        }
    }
}

// ========================================================
// --- JOGO 3: SEQU√äNCIA DE CORES (SIMON GAME) ---
// ========================================================
function initSimonGame() {
    const infoDisplay = document.getElementById('simon-info-display');
    const startButton = document.getElementById('simon-start-button');
    const pads = document.querySelectorAll('.simon-pad');
    const WIN_LEVEL = 8;
    let sequence = [];
    let playerSequence = [];
    let level = 1;
    let isPlayerTurn = false;

    startButton.onclick = startGame;
    pads.forEach(pad => pad.addEventListener('click', handlePlayerClick));

    function startGame() {
        startButton.style.display = 'none';
        sequence = [];
        level = 1;
        nextTurn();
    }
    
    function nextTurn() {
        isPlayerTurn = false;
        playerSequence = [];
        infoDisplay.textContent = `N√≠vel: ${level}`;
        
        const nextInSequence = Math.floor(Math.random() * 4);
        sequence.push(nextInSequence);
        
        playSequence();
    }
    
    async function playSequence() {
        await new Promise(resolve => setTimeout(resolve, 700)); // Pausa antes de come√ßar
        for (let i = 0; i < sequence.length; i++) {
            await activatePad(sequence[i]);
            await new Promise(resolve => setTimeout(resolve, 200)); // Pausa entre as luzes
        }
        isPlayerTurn = true;
        infoDisplay.textContent = "Sua vez!";
    }

    function activatePad(index) {
        return new Promise(resolve => {
            const pad = document.getElementById(`simon-pad-${index}`);
            pad.classList.add('active');
            
            // --- IN√çCIO DA MODIFICA√á√ÉO: Tocar som ---
            try {
                const som = document.getElementById(`simon-sound-${index}`);
                if (som) {
                    som.currentTime = 0; // Reinicia o som
                    som.play();
                }
            } catch (error) {
                console.warn("N√£o foi poss√≠vel tocar o som do jogo.", error);
            }
            // --- FIM DA MODIFICA√á√ÉO ---

            setTimeout(() => {
                pad.classList.remove('active');
                resolve();
            }, 500); // Dura√ß√£o que a luz fica acesa
        });
    }

    function handlePlayerClick(event) {
        if (!isPlayerTurn) return;
        
        const clickedIndex = parseInt(event.target.dataset.index, 10);
        activatePad(clickedIndex);
        playerSequence.push(clickedIndex);
        
        const lastIndex = playerSequence.length - 1;
        
        // Se o jogador errou
        if (playerSequence[lastIndex] !== sequence[lastIndex]) {
            endGame(false);
            return;
        }
        
        // Se o jogador completou a sequ√™ncia do n√≠vel
        if (playerSequence.length === sequence.length) {
            if (level >= WIN_LEVEL) {
                endGame(true); // Venceu o jogo!
            } else {
                level++;
                isPlayerTurn = false;
                setTimeout(nextTurn, 1000);
            }
        }
    }
    
    function endGame(isWinner) {
        isPlayerTurn = false;
        if(isWinner) {
            handleGameWin("Sequ√™ncia de Cores");
        } else {
            infoDisplay.textContent = "Errado! Tente de novo.";
            setTimeout(() => {
                document.getElementById('simon-game-board').innerHTML = `
                    <div id="simon-info-display">N√≠vel: 1</div>
                    <div id="simon-pads-container">
                        <div class="simon-pad" id="simon-pad-0" data-index="0"></div>
                        <div class="simon-pad" id="simon-pad-1" data-index="1"></div>
                        <div class="simon-pad" id="simon-pad-2" data-index="2"></div>
                        <div class="simon-pad" id="simon-pad-3" data-index="3"></div>
                    </div>
                    <button id="simon-start-button">Iniciar</button>
                `;
                initSimonGame(); // Reinicia o jogo
            }, 3000);
        }
    }
}

// ==========================================================
// --- JOGO 4: JOGO DA VELHA (TIC-TAC-TOE) --- VERS√ÉO ATUALIZADA
// ==========================================================
function initTicTacToeGame() {
    // Refer√™ncias aos elementos do DOM
    const wrapper = document.getElementById('tictactoe-board-wrapper');
    const statusDisplay = document.getElementById('tictactoe-status');
    const restartButton = document.getElementById('tictactoe-restart-button');
    const symbolSelection = document.getElementById('tictactoe-symbol-selection');
    const boardElement = document.getElementById('tictactoe-board');
    const winningLine = document.getElementById('tictactoe-winning-line');

    // Constantes e Vari√°veis do Jogo
    let PLAYER_SYMBOL = 'X';
    let AI_SYMBOL = 'O';
    const WINNING_COMBINATIONS = [
        // Horizontais
        { combo: [0, 1, 2], class: 'line-h-0' }, { combo: [3, 4, 5], class: 'line-h-1' }, { combo: [6, 7, 8], class: 'line-h-2' },
        // Verticais
        { combo: [0, 3, 6], class: 'line-v-0' }, { combo: [1, 4, 7], class: 'line-v-1' }, { combo: [2, 5, 8], class: 'line-v-2' },
        // Diagonais
        { combo: [0, 4, 8], class: 'line-d-0' }, { combo: [2, 4, 6], class: 'line-d-1' }
    ];
    let boardState = Array(9).fill(null);
    let isPlayerTurn = true;
    let isGameOver = false;
	let chosenPlayerSymbol = null;

    // Fun√ß√£o para iniciar o jogo ap√≥s a sele√ß√£o do s√≠mbolo
     function startGame(selectedSymbol) {
        // Se um s√≠mbolo foi selecionado (primeira partida), armazena a escolha
        if (selectedSymbol) {
            chosenPlayerSymbol = selectedSymbol;
        }

        PLAYER_SYMBOL = chosenPlayerSymbol;
        AI_SYMBOL = PLAYER_SYMBOL === 'X' ? 'O' : 'X';

        // Esconde a sele√ß√£o e mostra o tabuleiro
        symbolSelection.classList.add('hidden');
        boardElement.classList.remove('hidden');
        statusDisplay.classList.remove('hidden');

        // ALTERA√á√ÉO: O jogador sempre come√ßa
        isPlayerTurn = true;
        statusDisplay.textContent = `Sua vez de jogar (${PLAYER_SYMBOL})`;
    }

    // Adiciona eventos aos bot√µes de sele√ß√£o
    document.getElementById('select-X').onclick = () => startGame('X');
    document.getElementById('select-O').onclick = () => startGame('O');

    // Manipulador de clique na c√©lula
    function handleCellClick(e) {
        if (isGameOver || !isPlayerTurn) return;
        const cellIndex = parseInt(e.target.dataset.cellIndex);
        if (boardState[cellIndex] !== null) return;

        updateBoard(cellIndex, PLAYER_SYMBOL);
        const gameStatus = checkGameStatus();
        if (gameStatus.isFinished) {
            endGame(gameStatus);
            return;
        }

        isPlayerTurn = false;
        statusDisplay.textContent = `Vez do rob√¥ (${AI_SYMBOL})...`; // ALTERA√á√ÉO: "computador" para "rob√¥"
        setTimeout(computerMove, 700);
    }

    // L√≥gica da jogada do rob√¥
    function computerMove() {
        if (isGameOver) return;
        const bestMoveIndex = findBestMove();
        updateBoard(bestMoveIndex, AI_SYMBOL);
        
        const gameStatus = checkGameStatus();
        if (gameStatus.isFinished) {
            endGame(gameStatus);
            return;
        }
        
        isPlayerTurn = true;
        statusDisplay.textContent = `Sua vez de jogar (${PLAYER_SYMBOL})`;
    }

    // ALTERA√á√ÉO: IA de dificuldade m√©dia
    function findBestMove() {
        // 1. Tenta vencer
        for (const combination of WINNING_COMBINATIONS) {
            const move = getWinningMove(combination.combo, AI_SYMBOL);
            if (move !== -1) return move;
        }
        // 2. Tenta bloquear o jogador
        for (const combination of WINNING_COMBINATIONS) {
            const move = getWinningMove(combination.combo, PLAYER_SYMBOL);
            if (move !== -1) return move;
        }
        // 3. Se n√£o puder vencer ou bloquear, joga em um espa√ßo aleat√≥rio
        const availableMoves = boardState.map((cell, index) => cell === null ? index : null).filter(index => index !== null);
        if (availableMoves.length > 0) {
            return availableMoves[Math.floor(Math.random() * availableMoves.length)];
        }
        
        return boardState.findIndex(cell => cell === null); // Fallback
    }

    function getWinningMove(combo, symbol) {
        const line = combo.map(i => boardState[i]);
        if (line.filter(s => s === symbol).length === 2 && line.includes(null)) {
            return combo[line.indexOf(null)];
        }
        return -1;
    }

    // Atualiza visualmente o tabuleiro
    function updateBoard(index, symbol) {
        boardState[index] = symbol;
        const cell = boardElement.querySelector(`[data-cell-index='${index}']`);
        cell.classList.add(symbol.toLowerCase());
    }

    // Verifica o estado do jogo (vit√≥ria, empate ou continua)
    function checkGameStatus() {
        for (const combination of WINNING_COMBINATIONS) {
            const [a, b, c] = combination.combo;
            if (boardState[a] && boardState[a] === boardState[b] && boardState[a] === boardState[c]) {
                return { isFinished: true, winner: boardState[a], lineClass: combination.class, winningCombo: combination.combo };
            }
        }
        if (boardState.every(cell => cell !== null)) {
            return { isFinished: true, winner: 'tie' };
        }
        return { isFinished: false };
    }

    // Finaliza o jogo
     function endGame(status) {
        isGameOver = true;
        if (status.winner === PLAYER_SYMBOL) {
            statusDisplay.textContent = "Voc√™ venceu! üéâ";
            winningLine.className = `winning-line ${status.lineClass}`;
            status.winningCombo.forEach(i => document.querySelector(`[data-cell-index='${i}']`).classList.add('highlight'));
            handleGameWin("Jogo da Velha");
        } else if (status.winner === AI_SYMBOL) {
			statusDisplay.textContent = "O rob√¥ venceu!"; // ALTERA√á√ÉO: "computador" para "rob√¥"
			winningLine.className = `winning-line ${status.lineClass}`;
			status.winningCombo.forEach(i => document.querySelector(`[data-cell-index='${i}']`).classList.add('highlight'));

			let countdown = 3;
			statusDisplay.textContent = `O rob√¥ venceu! Nova rodada em ${countdown}...`; // ALTERA√á√ÉO: "computador" para "rob√¥"

			const countdownInterval = setInterval(() => {
				countdown--;
				if (countdown > 0) {
					statusDisplay.textContent = `O rob√¥ venceu! Nova rodada em ${countdown}...`; // ALTERA√á√ÉO: "computador" para "rob√¥"
				} else {
					clearInterval(countdownInterval);
					autoRestartAfterLoss();
				}
			}, 1000);
		} else {
            statusDisplay.textContent = "Deu velha! Tente novamente.";
            restartButton.classList.remove('hidden');
        }
    }
	
    function autoRestartAfterLoss() {
        boardState.fill(null);
        isGameOver = false;
        
        document.querySelectorAll('.tictactoe-cell').forEach(cell => {
            cell.className = 'tictactoe-cell';
        });
        winningLine.className = 'winning-line';
        restartButton.classList.add('hidden');

        startGame(null);
    }

    // Reinicia o jogo
    function restartGame() {
	    chosenPlayerSymbol = null;
        boardState.fill(null);
        isGameOver = false;
        isPlayerTurn = true;
        
        document.querySelectorAll('.tictactoe-cell').forEach(cell => {
            cell.className = 'tictactoe-cell';
        });
        winningLine.className = 'winning-line';
        restartButton.classList.add('hidden');
        boardElement.classList.add('hidden');
        statusDisplay.classList.add('hidden');

        symbolSelection.classList.remove('hidden');
    }

    // Adiciona os eventos de clique √†s c√©lulas e ao bot√£o de reiniciar
    document.querySelectorAll('.tictactoe-cell').forEach(cell => cell.addEventListener('click', handleCellClick));
    restartButton.addEventListener('click', restartGame);
}

// ==========================================================
// --- JOGO 5: JOGO DA FORCA (NOVO) ---
// ==========================================================
async function initForcaGame(dadosPalavra) {
    const statusDisplay = document.getElementById('forca-status');
    const palavraContainer = document.getElementById('palavra-forca');
    const dicaContainer = document.getElementById('dica-forca');
    const tecladoContainer = document.getElementById('teclado-forca');
    const restartButton = document.getElementById('forca-restart-button');
    const partesCorpo = document.querySelectorAll('.enforcado .parte-corpo');

    let palavraSecreta = '';
    let dica = '';
    let letrasCorretas = [];
    let erros = 0;
    const maxErros = 6;
    let jogoTerminou = false;

    if (!dadosPalavra || !dadosPalavra.palavra) {
        statusDisplay.textContent = 'Erro ao carregar a palavra da semana!';
        tecladoContainer.innerHTML = '';
        return;
    }

    palavraSecreta = dadosPalavra.palavra.toUpperCase();
    dica = dadosPalavra.dica;
    
    // 2. Inicializa o jogo
    function setupGame() {
        jogoTerminou = false;
        letrasCorretas = [];
        erros = 0;
        statusDisplay.textContent = 'Adivinhe a palavra!';
        dicaContainer.textContent = `Dica: ${dica}`;
        partesCorpo.forEach(parte => parte.style.display = 'none');
        restartButton.style.display = 'none';
        renderizarPalavra();
        renderizarTeclado();
    }

    // 3. Renderiza os placeholders da palavra
    function renderizarPalavra() {
        palavraContainer.innerHTML = '';
        for (const letra of palavraSecreta) {
            const letraEl = document.createElement('div');
            letraEl.classList.add('letra-placeholder');
            if (letrasCorretas.includes(letra)) {
                letraEl.textContent = letra;
            }
            palavraContainer.appendChild(letraEl);
        }
    }

    // ATUALIZADA: Renderiza um teclado no layout QWERTY
// ATUALIZADA: Renderiza um teclado QWERTY com bot√µes de tamanho uniforme e espa√ßadores para alinhamento.
function renderizarTeclado() {
    tecladoContainer.innerHTML = '';
    const layout = [
        ['Q', 'W', 'E', 'R', 'T', 'Y', 'U', 'I', 'O', 'P'],
        // NOVO: Adicionamos um espa√ßador de "meia tecla" no in√≠cio e no fim da segunda fileira
        ['SPACER_HALF', 'A', 'S', 'D', 'F', 'G', 'H', 'J', 'K', 'L', 'SPACER_HALF'],
        // NOVO: Adicionamos um espa√ßador e meio no in√≠cio e no fim da terceira fileira
        ['SPACER_FULL', 'SPACER_HALF', 'Z', 'X', 'C', 'V', 'B', 'N', 'M', 'SPACER_HALF', 'SPACER_FULL']
    ];

    layout.forEach(linha => {
        const linhaDiv = document.createElement('div');
        linhaDiv.classList.add('teclado-row');

        linha.forEach(item => {
            // NOVO: L√≥gica para diferenciar letras de espa√ßadores
            if (item.startsWith('SPACER_')) {
                const spacer = document.createElement('div');
                if (item === 'SPACER_HALF') {
                    spacer.className = 'teclado-spacer-half';
                } else if (item === 'SPACER_FULL') {
                    spacer.className = 'teclado-spacer-full';
                }
                linhaDiv.appendChild(spacer);
            } else {
                // A l√≥gica de criar o bot√£o continua a mesma
                const btn = document.createElement('button');
                btn.classList.add('teclado-btn');
                btn.textContent = item;
                btn.onclick = () => handleLetraClick(item, btn);
                linhaDiv.appendChild(btn);
            }
        });
        tecladoContainer.appendChild(linhaDiv);
    });
}

    // 5. Lida com o clique em uma letra
    function handleLetraClick(letra, btn) {
        if (jogoTerminou) return;

        btn.disabled = true;

        if (palavraSecreta.includes(letra)) {
            letrasCorretas.push(letra);
            btn.classList.add('correta');
        } else {
            erros++;
            btn.classList.add('errada');
            atualizarForcaVisual();
        }

        renderizarPalavra();
        checarFimDeJogo();
    }
    
    // 6. Atualiza o desenho do enforcado
    function atualizarForcaVisual() {
        for (let i = 0; i < erros; i++) {
            if (partesCorpo[i]) {
                partesCorpo[i].style.display = 'block';
            }
        }
    }
    
    // 7. Verifica se o jogo acabou (vit√≥ria ou derrota)
    function checarFimDeJogo() {
        // Checa vit√≥ria
        const vitoria = palavraSecreta.split('').every(letra => letrasCorretas.includes(letra));
        if (vitoria) {
            jogoTerminou = true;
            statusDisplay.textContent = 'Voc√™ venceu! üéâ';
            setTimeout(() => handleGameWin("Jogo da Forca"), 1000);
            return;
        }

        // Checa derrota
if (erros >= maxErros) {
    jogoTerminou = true;
    // ALTERADO: N√£o revela mais a palavra ao jogador!
    statusDisplay.textContent = `Voc√™ perdeu! Tente novamente.`;
    restartButton.style.display = 'block';
}
    }
    
    restartButton.onclick = () => {
        initForcaGame(dadosPalavra); 
};

    setupGame();
}

// ONDE COLAR: Junto com as outras fun√ß√µes de jogo (ex: initMemoryGame)

// =============================================
// --- JOGO 6: QUIZ DOS √âPICOS (NOVO) ---
// =============================================

// Fun√ß√£o auxiliar para embaralhar arrays
function embaralharArray(array) {
  for (let i = array.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [array[i], array[j]] = [array[j], array[i]];
  }
  return array;
}

async function gerarQuizDaSemana() {
  const semana = getSemanaAtual();
  const docId = `semana_${semana.numero}_${semana.inicio.getFullYear()}`;
  const advantageRef = doc(db, "vantagemSemanal", docId);
  const queueRef = doc(db, "configuracoes", "quizMemberQueue");

  const advantageSnap = await getDoc(advantageRef);
  if (advantageSnap.exists() && advantageSnap.data().quizDaSemana) {
    console.log("Quiz da semana j√° existe. Carregando...");
    return advantageSnap.data().quizDaSemana;
  }

  console.log("Gerando novo quiz para a semana...");

  const queueSnap = await getDoc(queueRef);
  let memberQueue = queueSnap.exists() ? queueSnap.data().queue : [];

  if (memberQueue.length < 4) {
    memberQueue = todosMembros
      .filter(m => m.papel !== 'lider')
      .map(m => m.nome);
    embaralharArray(memberQueue);
  }

  const membrosParaPerguntas = memberQueue.splice(0, 4);
  await setDoc(queueRef, { queue: memberQueue });

  // === MUDAN√áA PRINCIPAL: Usa 'todosMembros' para criar o objeto 'todosOsDados' ===
  console.log("Otimiza√ß√£o: Usando dados de membros em cache para gerar o quiz...");
  const todosOsDados = {};
  todosMembros.forEach(membro => {
      // Separa o nome do resto dos dados para criar o objeto no formato esperado
      const { nome, ...data } = membro;
      if (data.filme || data.sonho || data.musica || data.curiosidade) {
          todosOsDados[nome] = data;
      }
  });
  
  // O resto da fun√ß√£o continua exatamente igual, pois j√° usa 'todosOsDados'
  const quizQuestions = [];
  const tiposDePergunta = [
    { key: 'filme', template: "Qual o filme favorito de {membro}?" },
    { key: 'sonho', template: "Atualmente, qual o maior sonho de {membro}?" },
    { key: 'musica', template: "Qual dessas √© a m√∫sica que {membro} gosta muito?" },
    { key: 'curiosidade', template: "Qual dessas curiosidades pertence a {membro}?" }
  ];

  for (let i = 0; i < membrosParaPerguntas.length; i++) {
    const nomeMembro = membrosParaPerguntas[i];
    const dadosMembro = todosOsDados[nomeMembro];
    const tipo = tiposDePergunta[i];

    if (!dadosMembro || !dadosMembro[tipo.key] || dadosMembro[tipo.key].trim() === "" || dadosMembro[tipo.key].length < 7) continue; 

    const respostaCorreta = dadosMembro[tipo.key];
    
    let alternativasIncorretas = [];
    const outrosMembros = Object.keys(todosOsDados).filter(m => m !== nomeMembro);
    embaralharArray(outrosMembros);

    for (const outroNome of outrosMembros) {
      const dadosOutro = todosOsDados[outroNome];
      if (dadosOutro && dadosOutro[tipo.key] && dadosOutro[tipo.key].trim() !== "" && dadosOutro[tipo.key] !== respostaCorreta && dadosOutro[tipo.key].length >= 7) {
        alternativasIncorretas.push(dadosOutro[tipo.key]);
      }
      if (alternativasIncorretas.length >= 3) break;
    }
    
    if (alternativasIncorretas.length < 3) {
        return [];
    }

    const todasAlternativas = embaralharArray([respostaCorreta, ...alternativasIncorretas]);

    quizQuestions.push({
      pergunta: tipo.template.replace('{membro}', `<strong>${nomeMembro}</strong>`),
      alternativas: todasAlternativas,
      resposta: respostaCorreta
    });
  }
  
  if (quizQuestions.length < 4) {
      console.warn("N√£o foi poss√≠vel gerar 4 perguntas v√°lidas. Tentando novamente na pr√≥xima vez.");
      return [];
  }

  await setDoc(advantageRef, { quizDaSemana: quizQuestions }, { merge: true });

  return quizQuestions;
}

function initQuizGame(questions) {
    // Agora apenas pegamos os elementos que j√° foram injetados no HTML
    const questionEl = document.getElementById('quiz-question');
    const alternativesEl = document.getElementById('quiz-alternatives');
    const feedbackEl = document.getElementById('quiz-feedback');
    const questionNumberEl = document.getElementById('quiz-question-number');
    const progressBar = document.getElementById('quiz-progress-bar');
    
    let currentQuestionIndex = 0;
    let correctAnswers = 0;

    function showQuestion() {
        if (currentQuestionIndex >= questions.length) {
            // Fim do jogo
            if (correctAnswers === questions.length) {
                handleGameWin("Quiz dos √âpicos");
            } else {
                feedbackEl.textContent = `Voc√™ acertou ${correctAnswers} de ${questions.length}. Tente de novo!`;
                feedbackEl.style.color = '#e74c3c';
                setTimeout(() => loadAdvantageState(), 3000); // Recarrega o jogo
            }
            return;
        }

        const currentQuestion = questions[currentQuestionIndex];
        questionNumberEl.textContent = `Pergunta ${currentQuestionIndex + 1} de ${questions.length}`;
        questionEl.innerHTML = currentQuestion.pergunta;
        alternativesEl.innerHTML = '';
        feedbackEl.textContent = '';
        progressBar.style.width = `${(currentQuestionIndex / questions.length) * 100}%`;

        currentQuestion.alternativas.forEach(alt => {
            const button = document.createElement('button');
            button.className = 'user-panel-btn'; // Reutilizando um estilo de bot√£o existente
            button.innerHTML = alt;
            button.onclick = () => handleAnswer(button, alt, currentQuestion.resposta);
            alternativesEl.appendChild(button);
        });
    }

    // C√ìDIGO NOVO E CORRIGIDO
    function handleAnswer(button, selectedAnswer, correctAnswer) {
    // Desabilita todos os bot√µes para evitar cliques m√∫ltiplos
    alternativesEl.querySelectorAll('button').forEach(btn => btn.disabled = true);

    if (selectedAnswer === correctAnswer) {
        button.classList.add('correta');
        feedbackEl.textContent = "Resposta Certa!";
        feedbackEl.style.color = '#2ecc71';
        correctAnswers++;
        currentQuestionIndex++;
        progressBar.style.width = `${(currentQuestionIndex / questions.length) * 100}%`;
        setTimeout(showQuestion, 2000);
    } else {
        // L√ìGICA DE ERRO COM CORRE√á√ÉO
        button.classList.add('errada');
        feedbackEl.textContent = "Incorreto! O jogo ser√° reiniciado...";
        feedbackEl.style.color = '#e74c3c';
        
        setTimeout(() => {
            mostrarPopup("üîÑ Tente de Novo", "O quiz foi reiniciado. Preste mais aten√ß√£o!", 4000);
            
            // ===== AQUI EST√Å A M√ÅGICA =====
            // Se estiver no modo de teste, reinicia o teste.
            // Se n√£o, reinicia o jogo da semana normal.
            if (isTestModeActive) {
                startLeaderTestGame(currentTestGameIndex);
            } else {
                loadAdvantageState();
            }
            // =============================

        }, 2500);
    }
}
    showQuestion();
}

// ===== FIM DA L√ìGICA DO JOGO DA VANTAGEM =====

// Fun√ß√£o para buscar e exibir as Instru√ß√µes
  async function carregarInstrucoes() {
    try {
      const docRef = doc(db, "regras", "manual");
      const docSnap = await getDoc(docRef);

      if (docSnap.exists()) {
        const data = docSnap.data();
        const conteudoDiv = document.querySelector("#secao-instrucoes .secao-conteudo");

        conteudoDiv.innerHTML = `
          <h1>üìú Manual de Funcionamento e Din√¢micas do Grupo </h1>
          <div class="info-bloco">
            <h2>Lista de Foco</h2>
            <p>${data.Foco.replace(/\n/g, "<br>")}</p>
          </div>
          <div class="info-bloco">
            <h2>Dia de Folga</h2>
            <p>${data.Folga.replace(/\n/g, "<br>")}</p>
          </div>
          <div class="info-bloco">
            <h2>Nomea√ß√£o de L√≠deres</h2>
            <p>${data.Lider.replace(/\n/g, "<br>")}</p>
          </div>
          <div class="info-bloco">
            <h2>Medalhas Individuais</h2>
            <p>${data.Medalhas.replace(/\n/g, "<br>")}</p>
          </div>
          <div class="info-bloco">
            <h2>Deserto do Focus Plant</h2>
            <p>${data['Deserto'].replace(/\n/g, "<br>")}</p>
          </div>
        `;
        document.getElementById("secao-instrucoes").classList.remove("hidden");
      } else {
        mostrarPopup("‚ùå Erro", "N√£o foi poss√≠vel encontrar o manual de instru√ß√µes.", 4000);
      }
    } catch (error) {
      console.error("Erro ao carregar instru√ß√µes:", error);
      mostrarPopup("‚ùå Erro", "Falha ao carregar as instru√ß√µes.", 4000);
    }
  }

  // Fun√ß√£o para buscar e exibir as Advert√™ncias
  async function carregarAdvertencias() {
    try {
      const docRef = doc(db, "regras", "conduta");
      const docSnap = await getDoc(docRef);

      if (docSnap.exists()) {
        const data = docSnap.data();
        const conteudoDiv = document.querySelector("#secao-advertencias .secao-conteudo");

        const formatarLista = (texto) => `<ul>${texto.split('‚Ä¢').filter(item => item.trim() !== '').map(item => `<li>${item.trim()}</li>`).join('')}</ul>`;

        conteudoDiv.innerHTML = `
          <h1>‚ö†Ô∏è C√≥digo de Conduta e Advert√™ncias</h1>
          <div class="advertencia-card leve">
            <h2><span class="emoji">üü¢</span>Advert√™ncia Leve</h2>
            ${formatarLista(data.leve)}
          </div>
          <div class="advertencia-card media">
            <h2><span class="emoji">üü°</span>Advert√™ncia M√©dia</h2>
            ${formatarLista(data.media)}
          </div>
          <div class="advertencia-card grave">
            <h2><span class="emoji">üî¥</span>Advert√™ncia Grave</h2>
            ${formatarLista(data.grave)}
          </div>
          <div class="advertencia-card gravissima">
            <h2><span class="emoji">üü£</span>Advert√™ncia Grav√≠ssima</h2>
            ${formatarLista(data.gravissima)}
          </div>
          <div class="advertencia-card expulsao">
            <h2><span class="emoji">‚ö´</span>Expuls√£o</h2>
            ${formatarLista(data.expulsao)}
          </div>
        `;
        document.getElementById("secao-advertencias").classList.remove("hidden");
      } else {
        mostrarPopup("‚ùå Erro", "N√£o foi poss√≠vel encontrar o c√≥digo de conduta.", 4000);
      }
    } catch (error) {
      console.error("Erro ao carregar advert√™ncias:", error);
      mostrarPopup("‚ùå Erro", "Falha ao carregar as advert√™ncias.", 4000);
    }
  }

  // Fun√ß√£o para fechar as se√ß√µes de tela cheia
  function fecharSecoes() {
    document.getElementById("secao-instrucoes").classList.add("hidden");
    document.getElementById("secao-advertencias").classList.add("hidden");
  }

  // Adicionar os ouvintes de evento aos bot√µes
  document.getElementById("btn-instrucoes").addEventListener("click", carregarInstrucoes);
  document.getElementById("btn-advertencias").addEventListener("click", carregarAdvertencias);

  document.querySelectorAll(".botao-fechar-secao").forEach(btn => {
    btn.addEventListener("click", fecharSecoes);
  });
  
  // NOVA FUN√á√ÉO: Calcula quem ficou ocioso e salva no Firestore
async function calcularMembrosOciosos() {
    console.log("Calculando membros ociosos da semana...");
    const semanaPassada = getSemanaAtual(new Date(new Date().setDate(new Date().getDate() - 2))); // Pega a semana que acabou no s√°bado
    const inicioSemana = semanaPassada.inicio;
    const fimSemana = semanaPassada.fim;

    const inicioISO = inicioSemana.toISOString().slice(0, 10);
    const fimISO = fimSemana.toISOString().slice(0, 10);
    
    const semanaId = `semana_${semanaPassada.numero}_${semanaPassada.inicio.getFullYear()}`;
    const contagemMembros = {};

    // Inicializa a contagem para todos
    todosMembros.forEach(m => {
        // Exclui o l√≠der geral E membros de f√©rias/sa√∫de da contagem de ociosidade
        if (m.papel !== 'lider' && !m.deFerias) {
            contagemMembros[m.nome] = 0;
        }
    });

    try {
        const q = query(
            collection(db, "presencas"),
            where('__name__', '>=', inicioISO),
            where('__name__', '<=', fimISO)
        );
        const querySnapshot = await getDocs(q);

        querySnapshot.forEach(doc => {
            const presencas = doc.data();
            for (const [nome, presente] of Object.entries(presencas)) {
                if (presente && contagemMembros[nome] !== undefined) {
                    contagemMembros[nome]++;
                }
            }
        });

        const membrosOciosos = Object.entries(contagemMembros)
            .filter(([nome, contagem]) => contagem < 4)
            .map(([nome, contagem]) => ({ nome, contagem }));

        const ociososRef = doc(db, "gerenciamentoSemanal", semanaId);
        await setDoc(ociososRef, {
            ociosos: membrosOciosos,
            processado: false // Flag para indicar que esta lista ainda n√£o foi finalizada
        });

        console.log(`Encontrados ${membrosOciosos.length} membros ociosos. Dados salvos em ${semanaId}.`);

    } catch (error) {
        console.error("Erro ao calcular membros ociosos:", error);
    }
}

// NOVA FUN√á√ÉO: Carrega e exibe a lista para o l√≠der
async function carregarEExibirMembrosOciosos() {
    const secao = document.getElementById('secao-ociosos');
    // Apenas o l√≠der pode ver esta se√ß√£o.
    if (userRole !== 'lider') {
        secao.classList.add('hidden');
        return;
    }
    secao.classList.remove('hidden');

    const hoje = getHoje();
    const diaDaSemana = hoje.getDay(); // 0=Dom, 1=Seg, ..., 6=S√°b
    const eDomingo = diaDaSemana === 0;

    const listaEl = document.getElementById('lista-ociosos');
    const descricaoEl = document.getElementById('ociosos-descricao');
    listaEl.innerHTML = '<div class="ociosos-placeholder">Calculando...</div>'; // Feedback inicial

    // =================================================================================
    // L√ìGICA DE DOMINGO: Dia de Gerenciamento (L√≥gica Original Mantida)
    // No domingo, olhamos para a lista final da semana que acabou de terminar.
    // =================================================================================
    if (eDomingo) {
        // Pega a semana que acabou no s√°bado.
        const semanaPassadaQuery = getSemanaAtual(new Date(new Date().setDate(hoje.getDate() - 1)));
        const semanaId = `semana_${semanaPassadaQuery.numero}_${semanaPassadaQuery.inicio.getFullYear()}`;
        const ociososRef = doc(db, "gerenciamentoSemanal", semanaId);

        try {
            const docSnap = await getDoc(ociososRef);
            if (!docSnap.exists() || docSnap.data().ociosos.length === 0) {
                listaEl.innerHTML = '<div class="ociosos-placeholder">Nenhum membro ficou abaixo da meta na semana passada.</div>';
                descricaoEl.textContent = "A√ß√µes de final de semana: Nenhuma a√ß√£o necess√°ria.";
                return;
            }

            const ociosos = docSnap.data().ociosos;
            listaEl.innerHTML = ''; // Limpa a lista para adicionar os itens.
            descricaoEl.textContent = "A√ß√µes de final de semana: Justifique os membros que apresentaram um motivo v√°lido ou expulse os que n√£o cumpriram a meta semanal.";
            
            ociosos.forEach(membro => {
                const itemEl = document.createElement('div');
                itemEl.className = 'ocioso-item';
                itemEl.innerHTML = `
                    <div class="ocioso-nome">${membro.nome} (${membro.contagem}/4 dias)</div>
                    <div class="ocioso-botoes">
                        <button class="ocioso-btn justificar" onclick="justificarMembro('${membro.nome}', '${semanaId}')">Justificar</button>
                        <button class="ocioso-btn expulsar" onclick="confirmarExpulsao('${membro.nome}')">Expulsar</button>
                    </div>
                `;
                listaEl.appendChild(itemEl);
            });

        } catch (error) {
            console.error("Erro ao carregar lista de ociosos de domingo:", error);
            listaEl.innerHTML = '<div class="ociosos-placeholder">Erro ao carregar a lista.</div>';
        }

    // =================================================================================
    // L√ìGICA DE SEGUNDA A S√ÅBADO: An√°lise Preditiva (Nova L√≥gica Inteligente)
    // Durante a semana, calculamos em tempo real quem n√£o pode mais atingir a meta.
    // =================================================================================
    } else {
        const semanaAtual = getSemanaAtual();
        const inicioSemanaISO = formatarDataISO(semanaAtual.inicio);
        const hojeISO = getHojeISO();
        
        // Quantos dias ainda restam na competi√ß√£o (Seg=6, Ter=5, ..., S√°b=1)
        const diasRestantes = 7 - diaDaSemana;
        
        descricaoEl.textContent = `An√°lise em tempo real: A lista abaixo mostra os membros que matematicamente n√£o podem mais atingir a meta de 4 dias de foco nesta semana.`;
        
        try {
            // 1. Busca todas as presen√ßas da semana atual.
            const q = query(
                collection(db, "presencas"),
                where('__name__', '>=', inicioSemanaISO),
                where('__name__', '<=', hojeISO)
            );
            const querySnapshot = await getDocs(q);

            // 2. Conta os focos de cada membro.
            const contagem = {};
            todosMembros.forEach(m => {
                if (m.papel !== 'lider') { // L√≠der geral n√£o entra na contagem.
                    contagem[m.nome] = 0;
                }
            });

            querySnapshot.forEach(doc => {
                const presencasDoDia = doc.data();
                for (const nome in presencasDoDia) {
                    if (presencasDoDia[nome] && contagem[nome] !== undefined) {
                        contagem[nome]++;
                    }
                }
            });

            // 3. Filtra usando a nova l√≥gica inteligente.
            const membrosMatematicamenteOciosos = Object.keys(contagem)
                .filter(nome => {
                    // Verifica se o membro est√° de f√©rias ou sa√∫de
                    const membroObj = todosMembros.find(m => m.nome === nome);
                    if (membroObj && membroObj.deFerias) return false; // Ignora se estiver de f√©rias

                    const focosAtuais = contagem[nome] || 0;
                    const focosNecessarios = 4 - focosAtuais;
                    // A condi√ß√£o principal: se os focos que ele precisa √© MAIOR que os dias que ainda restam.
                    return focosNecessarios > diasRestantes;
                })
                .map(nome => ({ nome: nome, contagem: contagem[nome] }));

            // 4. Exibe o resultado.
            if (membrosMatematicamenteOciosos.length === 0) {
                listaEl.innerHTML = '<div class="ociosos-placeholder">At√© o momento, todos os membros ainda podem atingir a meta.</div>';
            } else {
                listaEl.innerHTML = ''; // Limpa a lista.
                membrosMatematicamenteOciosos.forEach(membro => {
                    const itemEl = document.createElement('div');
                    itemEl.className = 'ocioso-item';
                    // Mostra apenas a informa√ß√£o, sem bot√µes de a√ß√£o.
                    itemEl.innerHTML = `<div class="ocioso-nome">${membro.nome} (${membro.contagem}/4 dias)</div>`;
                    listaEl.appendChild(itemEl);
                });
            }

        } catch (error) {
            console.error("Erro ao calcular ociosos em tempo real:", error);
            listaEl.innerHTML = '<div class="ociosos-placeholder">Erro ao calcular a lista.</div>';
        }
    }
}

// NOVA FUN√á√ÉO: Remove um membro da lista de ociosos (a√ß√£o de justificar)
async function justificarMembro(nome, semanaId) {
    if (!confirm(`Tem certeza que deseja justificar e remover '${nome}' da lista de ociosos desta semana?`)) return;

    const ociososRef = doc(db, "gerenciamentoSemanal", semanaId);
    try {
        await runTransaction(db, async (transaction) => {
            const docSnap = await transaction.get(ociososRef);
            if (!docSnap.exists()) return;

            const dadosAtuais = docSnap.data().ociosos;
            const novosDados = dadosAtuais.filter(m => m.nome !== nome);
            transaction.update(ociososRef, { ociosos: novosDados });
        });
        mostrarPopup("‚úÖ Sucesso", `${nome} foi justificado e removido da lista.`, 4000);
        await carregarEExibirMembrosOciosos(); // Atualiza a lista na tela
    } catch (error) {
        console.error("Erro ao justificar membro:", error);
        mostrarPopup("‚ùå Erro", "N√£o foi poss√≠vel processar a justiticativa.", 4000);
    }
}

// NOVA FUN√á√ÉO: Abre o modal de confirma√ß√£o para expuls√£o
function confirmarExpulsao(nome) {
    membroParaExpulsar = nome;
    document.getElementById('member-to-expel-name').innerText = nome;
    document.getElementById('confirm-expel-button').onclick = executarExpulsao;
    openModal('confirm-expel-modal');
}

// NOVA FUN√á√ÉO: Executa a expuls√£o do membro
async function executarExpulsao() {
    if (!membroParaExpulsar) return;

    const nome = membroParaExpulsar;
    console.log(`Iniciando processo de expuls√£o para: ${nome}`);

    try {
        // Deletar o membro da cole√ß√£o principal 'membros'
        await deleteDoc(doc(db, "membros", nome));
		
		// NOVA LINHA: Registra o evento de expuls√£o de membro
await adicionarEventoAoFeed(
    'geral',
    'üö∂‚Äç‚ôÇÔ∏è Despedida no Grupo',
    `O membro <strong>${nome}</strong> n√£o faz mais parte do nosso grupo. Desejamos sucesso em sua jornada!`,
    { nomeMembro: nome }
);

        // B√îNUS: Limpar dados de outras cole√ß√µes (opcional, mas recomendado)
        // Voc√™ pode adicionar aqui a l√≥gica para remover o membro de `presencas`, `streak`, etc. se desejar uma limpeza completa.
        // Por simplicidade, focaremos na remo√ß√£o principal.

        mostrarPopup("üóëÔ∏è Membro Expulso", `${nome} foi removido permanentemente do sistema.`, 5000);
        
        // Limpa a vari√°vel global e fecha o modal
        membroParaExpulsar = null;
        closeModal('confirm-expel-modal');

        // Atualiza toda a interface para refletir a remo√ß√£o
        await refreshAppUI();

    } catch (error) {
        console.error(`Erro ao expulsar ${nome}:`, error);
        mostrarPopup("‚ùå Falha Grave", `Ocorreu um erro ao tentar expulsar ${nome}.`, 5000);
    }
}

// COLE ESTA NOVA FUN√á√ÉO NO SEU SCRIPT

function atualizarPodioEquipes() {
  // 1. Coleta os dados das equipes em um array
  const equipesArray = [
    { id: 'abelha', vitorias: rankingGeral.abelha, elemento: document.getElementById('podio-abelha') },
    { id: 'joaninha', vitorias: rankingGeral.joaninha, elemento: document.getElementById('podio-joaninha') },
    { id: 'vagalume', vitorias: rankingGeral.vagalume, elemento: document.getElementById('podio-vagalume') }
  ];

  // 2. Ordena as equipes por vit√≥rias, da maior para a menor
  equipesArray.sort((a, b) => b.vitorias - a.vitorias);

  // 3. Limpa classes de p√≥dio anteriores para garantir uma atualiza√ß√£o limpa
  equipesArray.forEach(equipe => {
    if (equipe.elemento) {
      equipe.elemento.classList.remove('podium-1', 'podium-2', 'podium-3');
    }
  });

  // 4. Determina e aplica as classes do p√≥dio, tratando empates
  let rank = 1;
  for (let i = 0; i < equipesArray.length; i++) {
    // Se n√£o for a primeira equipe, verifica se a pontua√ß√£o √© menor que a anterior para definir o pr√≥ximo rank
    if (i > 0 && equipesArray[i].vitorias < equipesArray[i - 1].vitorias) {
      rank = i + 1;
    }
    
    // Aplica a classe correspondente ao rank
    if (equipesArray[i].elemento) {
      equipesArray[i].elemento.classList.add(`podium-${rank}`);
    }
  }
}

// NOVA FUN√á√ÉO: Destaca a equipe vencedora no placar (Apenas no Domingo)
async function destacarVencedoraDomingo() {
  const hoje = getHoje();
  const equipesIds = ['abelha', 'joaninha', 'vagalume'];

  // 1. Limpa destaques anteriores (importante para quando virar segunda-feira)
  equipesIds.forEach(id => {
    const el = document.getElementById(`podio-${id}`);
    if (el) el.classList.remove('vencedora-destaque-domingo');
  });

  // 2. Se N√ÉO for domingo, para por aqui.
  if (hoje.getDay() !== 0) return;

  console.log("Domingo detectado: Buscando vencedora da semana para destaque...");

  try {
    // 3. Identifica a semana que acabou ontem (S√°bado)
    const ontem = new Date(hoje);
    ontem.setDate(ontem.getDate() - 1);
    const semanaPassada = getSemanaAtual(ontem);
    const semanaId = `semana_${semanaPassada.numero}_${semanaPassada.inicio.getFullYear()}`;
    
    // 4. Busca o resultado no Firestore
    const resultadoRef = doc(db, "resultadosCompeticao", semanaId);
    const docSnap = await getDoc(resultadoRef);

    if (docSnap.exists()) {
      const dados = docSnap.data();
      const ranking = dados.rankingEquipes || {};

      // 5. Encontra quem ficou em 1¬∫ lugar (pode ser mais de uma em caso de empate)
      const vencedoras = Object.keys(ranking).filter(equipe => ranking[equipe] === 1);

      // 6. Aplica a classe de destaque
      vencedoras.forEach(equipe => {
        // Normaliza o nome (ex: 'Abelha' -> 'abelha')
        const idNormalizado = equipe.toLowerCase(); 
        const elementoPodio = document.getElementById(`podio-${idNormalizado}`);
        
        if (elementoPodio) {
          elementoPodio.classList.add('vencedora-destaque-domingo');
        }
      });
    }
  } catch (error) {
    console.error("Erro ao destacar vencedora de domingo:", error);
  }
}

// NOVA FUN√á√ÉO: Verifica se a premia√ß√£o di√°ria j√° foi concedida e a executa se necess√°rio.
async function verificarEConcederPremiacaoDiaria() {
  console.log("Verificando se a premia√ß√£o di√°ria precisa ser concedida...");

  const ontem = new Date();
  ontem.setDate(ontem.getDate() - 1);
  const ontemISO = formatarDataISO(ontem); // Formato "AAAA-MM-DD" de ontem

  // Refer√™ncia para um documento que controlar√° o estado da premia√ß√£o
  const prizeStateRef = doc(db, "appState", "dailyPrizeState");

  try {
    const docSnap = await getDoc(prizeStateRef);
    const lastAwardedDate = docSnap.exists() ? docSnap.data().lastAwardedDate : null;

    // A CONDI√á√ÉO PRINCIPAL:
    // Se a √∫ltima data premiada for DIFERENTE da data de ontem,
    // significa que a premia√ß√£o de ontem ainda n√£o foi paga.
    if (lastAwardedDate !== ontemISO) {
      console.log(`Premia√ß√£o para o dia ${ontemISO} ainda n√£o foi concedida. Iniciando processo...`);
      
      // 1. Chama a nossa fun√ß√£o RENOMEADA E CORRIGIDA para dar as moedas
      await premiarTop5ConsistenciaDiaria();
      
      // 2. ATUALIZA o registro no banco de dados com a data de ontem.
      // Isso funciona como uma "trava", impedindo que a premia√ß√£o de ontem seja paga novamente.
      await setDoc(prizeStateRef, { lastAwardedDate: ontemISO });
      
      console.log(`Premia√ß√£o para ${ontemISO} conclu√≠da e registrada.`);
    } else {
      console.log(`Premia√ß√£o para o dia ${ontemISO} j√° foi concedida anteriormente. Nenhuma a√ß√£o necess√°ria.`);
    }
  } catch (error) {
    console.error("Erro ao verificar ou conceder a premia√ß√£o di√°ria:", error);
  }
}

// ATUALIZADA: Premia os membros com base na sua posi√ß√£o no ranking de consist√™ncia do dia anterior
async function premiarTop5ConsistenciaDiaria() {
  console.log("üèÜ Iniciando premia√ß√£o di√°ria do Top 5 por consist√™ncia...");

  // Corre√ß√£o: Fallbacks atualizados para os valores corretos
  const premiacaoMoedas = {
    1: recompensasConfig.top5Diario_1 || 100,
    2: recompensasConfig.top5Diario_2 || 75,
    3: recompensasConfig.top5Diario_3 || 50,
    4: recompensasConfig.top5Diario_4 || 40,
    5: recompensasConfig.top5Diario_5 || 20
  };

  // Pega a data de ontem para calcular o ranking como ele estava no final do dia anterior
  const ontem = new Date();
  ontem.setDate(ontem.getDate() - 1);

  try {
    // Usa a fun√ß√£o que j√° conhecemos para obter o ranking de consist√™ncia de ontem
    const rankingDiario = await obterRankingSemanal(ontem);

    // Pega os 5 primeiros (ou menos, se n√£o houver 5 com pontos)
    const top5 = rankingDiario.filter(m => m.pontos > 0).slice(0, 5);

    if (top5.length === 0) {
      console.log("N√£o houve membros com foco registrado ontem para formar um Top 5. Premia√ß√£o pulada.");
      return;
    }

    const batch = writeBatch(db);
    const vencedoresFeed = [];

    // Prepara as atualiza√ß√µes de moedas e a lista para o feed
    top5.forEach((vencedor, index) => {
      const posicao = index + 1;
      const moedasGanhas = premiacaoMoedas[posicao];
      
      const membroRef = doc(db, "membros", vencedor.nome);
      batch.update(membroRef, { moedas: increment(moedasGanhas) });
      
      // Se o usu√°rio logado for um dos vencedores, mostra o popup de moedas
      if (vencedor.nome === currentUser) {
        mostrarPopupMoedas(moedasGanhas);
      }
      
      // Cria a linha para o post do feed
      vencedoresFeed.push(`<strong>${posicao}¬∫ ${vencedor.nome}</strong> (${vencedor.pontos} dias | +${moedasGanhas}üí∞)`);
    });

    // Executa todas as atualiza√ß√µes de moedas de uma vez
    await batch.commit();

    // ALTERADO: A mensagem agora reflete a consist√™ncia
    const textoFeed = `Os mais focados da semana! Estes foram os √âpicos no topo do ranking semanal ao final de ontem:<br>${vencedoresFeed.join('<br>')}`;
    
    await adicionarEventoAoFeed(
      'geral',
      'üèÜ Top 5 Consistentes do Dia!', // T√≠tulo alterado
      textoFeed,
      {}
    );

    console.log(`‚úÖ Premia√ß√£o di√°ria do Top 5 por consist√™ncia conclu√≠da para ${top5.length} membros.`);

  } catch (error) {
    console.error("Erro ao premiar o Top 5 di√°rio por consist√™ncia:", error);
  }
}

// =============================================
// ===== SISTEMA DE AVATAR =====
// =============================================

// FUN√á√ÉO ATUALIZADA: Define 'acessorio' como um array vazio por padr√£o
function criarAvatarPadrao() {
  const tonsDePele = ["corpo_1", "corpo_2", "corpo_3", "corpo_4", "corpo_5"];
  const tomAleatorio = tonsDePele[Math.floor(Math.random() * tonsDePele.length)];
  return {
    fundo: "fundo_1",
    corpo: tomAleatorio,
    roupa: "roupa_1_cor_1",
    cabelo: null,
    rosto: "rosto_1",
    acessorio: [], // ALTERADO DE null PARA []
	  enfeite_de_parede: [],
  };
}

// C√ìDIGO CORRIGIDO E FINAL
async function carregarDadosAvatar() {
¬† // Carrega os itens da loja APENAS UMA VEZ
¬† if (todosOsItensAvatar.length === 0) {
¬† ¬† try {
¬† ¬† ¬† const querySnapshot = await getDocs(collection(db, "loja_avatar_itens"));
¬† ¬† ¬† querySnapshot.forEach(doc => {
¬† ¬† ¬† ¬† todosOsItensAvatar.push({ docId: doc.id, ...doc.data() });
¬† ¬† ¬† });
¬† ¬† } catch (error) {
¬† ¬† ¬† console.error("Erro ao carregar itens da loja de avatar:", error);
¬† ¬† }
¬† }

¬† // Para o listener antigo para evitar duplica√ß√£o ao fazer login novamente
¬† if (unsubscribeAvatarListener) unsubscribeAvatarListener();

¬† // Listener em tempo real que atualiza APENAS O CACHE do invent√°rio
¬† const membroRef = doc(db, "membros", currentUser);
¬† unsubscribeAvatarListener = onSnapshot(membroRef, (docSnap) => {
¬† ¬† if (docSnap.exists()) {
¬† ¬† ¬† const dados = docSnap.data();
¬† ¬† ¬† inventarioAvatarCache = dados.inventarioAvatar || [];
¬† ¬† ¬† console.log("Cache de invent√°rio do avatar atualizado em tempo real.");
¬† ¬† }
¬† });
}

// =============================================
// ===== NOVO: SISTEMA DE VERIFICA√á√ÉO DE PERMISS√ïES DE AVATAR =====
// =============================================

/**
 * Verifica se um membro tem permiss√£o para possuir um item espec√≠fico.
 * @param {object} dadosMembro - O objeto completo com os dados do membro (papel, equipe, etc.).
 * @param {string} itemId - O ID do item de avatar a ser verificado.
 * @returns {boolean} - Retorna true se o membro tiver permiss√£o, false caso contr√°rio.
 */
function verificarPermissaoParaItem(dadosMembro, itemId) {
  if (!itemId) {
    return true; // Itens nulos (vazios) s√£o sempre permitidos.
  }

  // =======================================================
  // IN√çCIO DA CORRE√á√ÉO: A verifica√ß√£o de itens com regras especiais (coroas, placas)
  // agora vem PRIMEIRO, garantindo que elas tenham prioridade.
  // =======================================================
  switch (itemId) {
    // REGRAS DAS COROAS DE L√çDER (PRIORIDADE M√ÅXIMA)
    case 'coroa_lider_geral':
      return dadosMembro.papel === 'lider';
    case 'coroa_abelha':
      return dadosMembro.papel === 'lider-equipe' && dadosMembro.equipe === 'abelha';
    case 'coroa_joaninha':
      return dadosMembro.papel === 'lider-equipe' && dadosMembro.equipe === 'joaninha';
    case 'coroa_vagalume':
      return dadosMembro.papel === 'lider-equipe' && dadosMembro.equipe === 'vagalume';

    // REGRAS DAS PLACAS DE EQUIPE (PRIORIDADE M√ÅXIMA)
    case 'placa_abelha':
      return dadosMembro.equipe === 'abelha';
    case 'placa_joaninha':
      return dadosMembro.equipe === 'joaninha';
    case 'placa_vagalume':
      return dadosMembro.equipe === 'vagalume';
  }

  // Se n√£o for um item especial, a l√≥gica continua para verificar se √© um item raro.
  const itemPai = todosOsItensAvatar.find(item => item.variacoes.some(v => v.id === itemId));

  // Se o item for RARO, a permiss√£o depende do array 'permissoesItensRaros'
  if (itemPai && itemPai.raro) {
    // Caso especial da bandeira (compatibilidade)
    if (itemId === 'bandeira_rara_1') {
      return dadosMembro.podeComprarBandeiraRara === true;
    }
    // L√≥gica para todos os outros itens raros
    const permissoes = dadosMembro.permissoesItensRaros || [];
    return permissoes.includes(itemId);
  }

  // Se o item n√£o for especial e n√£o for raro, todos podem t√™-lo.
  return true;
}

/**
 * Verifica o avatar e o invent√°rio de um usu√°rio, removendo itens para os quais
 * ele n√£o tem mais permiss√£o. Executa uma √∫nica atualiza√ß√£o no Firestore se necess√°rio.
 * @param {object} dadosMembro - Os dados completos do membro, j√° carregados do Firestore.
 */
async function verificarEAtualizarAvatar(dadosMembro) {
  console.log(`Verificando permiss√µes de avatar para: ${dadosMembro.nome}...`);

  const avatarAtual = dadosMembro.avatar || criarAvatarPadrao();
  const inventarioAtual = dadosMembro.inventarioAvatar || [];

  // ========================================================================
  // IN√çCIO DA CORRE√á√ÉO PRINCIPAL
  // Em vez de criar um avatar novo, come√ßamos com uma C√ìPIA EXATA do atual.
  // ========================================================================
  const avatarLimpo = JSON.parse(JSON.stringify(avatarAtual));

  // Agora, em vez de copiar itens, n√≥s REMOVEMOS os inv√°lidos da c√≥pia.
  if (avatarLimpo.roupa && !verificarPermissaoParaItem(dadosMembro, avatarLimpo.roupa)) {
    avatarLimpo.roupa = null;
  }
  if (avatarLimpo.cabelo && !verificarPermissaoParaItem(dadosMembro, avatarLimpo.cabelo)) {
    avatarLimpo.cabelo = null;
  }
  if (Array.isArray(avatarLimpo.acessorio)) {
    avatarLimpo.acessorio = avatarLimpo.acessorio.filter(id => verificarPermissaoParaItem(dadosMembro, id));
  }
  if (Array.isArray(avatarLimpo.enfeite_de_parede)) {
    avatarLimpo.enfeite_de_parede = avatarLimpo.enfeite_de_parede.filter(id => verificarPermissaoParaItem(dadosMembro, id));
  }

  // A verifica√ß√£o do invent√°rio continua a mesma, pois j√° era robusta.
  const inventarioLimpo = inventarioAtual.filter(itemId => verificarPermissaoParaItem(dadosMembro, itemId));

  // Agora, a compara√ß√£o √© confi√°vel, pois a ordem das propriedades ser√° a mesma.
  const avatarMudou = JSON.stringify(avatarAtual) !== JSON.stringify(avatarLimpo);
  const inventarioMudou = inventarioAtual.length !== inventarioLimpo.length;
  const avatarFoiModificado = avatarMudou || inventarioMudou;
  // ========================================================================
  // FIM DA CORRE√á√ÉO PRINCIPAL
  // ========================================================================

  if (avatarFoiModificado) {
    console.warn(`Permiss√µes de avatar inv√°lidas detectadas para ${dadosMembro.nome}. Atualizando...`);

    const membroRef = doc(db, "membros", dadosMembro.nome);
    const dadosParaAtualizar = {
      avatar: avatarLimpo,
      inventarioAvatar: inventarioLimpo
    };

    try {
      await updateDoc(membroRef, dadosParaAtualizar);

      mostrarPopup(
        "‚ÑπÔ∏è Avatar Atualizado",
        "Detectamos que voc√™ possu√≠a itens que n√£o s√£o mais permitidos para sua conta. Seu avatar foi ajustado automaticamente.",
        8000
      );

      console.log("Avatar e invent√°rio corrigidos com sucesso no Firestore.");

    } catch (error) {
      console.error("Erro cr√≠tico ao tentar corrigir o avatar do usu√°rio:", error);
    }
  } else {
    console.log(`Permiss√µes de avatar para ${dadosMembro.nome} est√£o corretas. Nenhuma a√ß√£o necess√°ria.`);
  }
}

async function renderizarAvatar(membroId, container) {
  try {
    // Tenta encontrar o membro na mem√≥ria global primeiro
    const membroCache = todosMembros.find(m => m.nome === membroId);
    let configAvatar = criarAvatarPadrao(); // Define um padr√£o

    if (membroCache && membroCache.avatar) {
      // Se encontrou no cache, usa os dados locais (0 leituras!)
      configAvatar = membroCache.avatar;
    } else {
      // Fallback: S√≥ l√™ do banco se n√£o estiver no cache (raro acontecer)
      const membroDoc = await getDoc(doc(db, "membros", membroId));
      if (membroDoc.exists() && membroDoc.data().avatar) {
        configAvatar = membroDoc.data().avatar;
      }
    }
    
    renderizarAvatarConfig(container, configAvatar);

  } catch (error) {
    console.error(`Erro ao renderizar avatar de ${membroId}:`, error);
    container.innerHTML = '';
  }
}

// FUN√á√ÉO ATUALIZADA: Agora usa a fun√ß√£o 'mestra' para renderizar a pr√©-visualiza√ß√£o
function renderizarAvatarTemporario(container) {
  renderizarAvatarConfig(container, avatarTemporario); // Chama a fun√ß√£o mestra
}

function encontrarUrlItemPorId(itemId) {
  for (const item of todosOsItensAvatar) {
    for (const variacao of item.variacoes) {
      if (variacao.id === itemId) {
        return variacao;
      }
    }
  }
  return null;
}

// NOVA FUN√á√ÉO AUXILIAR: Encontra a subcategoria de um item de acess√≥rio
function encontrarSubcategoria(itemId) {
  const itemPai = todosOsItensAvatar.find(item => 
    item.variacoes.some(v => v.id === itemId)
  );
  return itemPai ? itemPai.subcategoria : null;
}

// C√ìDIGO CORRIGIDO
async function abrirEditorAvatar() {
  try {
    const membroDoc = await getDoc(doc(db, "membros", currentUser));
    if (membroDoc.exists() && membroDoc.data().avatar) {
      avatarOriginal = JSON.parse(JSON.stringify(membroDoc.data().avatar));
      avatarTemporario = JSON.parse(JSON.stringify(membroDoc.data().avatar));
    } else {
      avatarOriginal = criarAvatarPadrao();
      avatarTemporario = criarAvatarPadrao();
    }
    // GARANTE QUE enfeite_de_parede SEJA UM ARRAY
    if (!Array.isArray(avatarTemporario.enfeite_de_parede)) {
        avatarTemporario.enfeite_de_parede = [];
    }
    if (!Array.isArray(avatarOriginal.enfeite_de_parede)) {
        avatarOriginal.enfeite_de_parede = [];
    }

  } catch (error) {
    console.error("Erro ao buscar avatar para edi√ß√£o:", error);
    avatarTemporario = criarAvatarPadrao();
  }

  const previewContainer = document.getElementById('avatar-preview-editor');
  renderizarAvatarTemporario(previewContainer);
  previewContainer.onclick = abrirVisualizadorDoEditor;
  document.querySelector('.avatar-tab-btn[data-tab="inventario"]').click();
  openModal('avatar-editor-modal');
}

// Eventos das abas de estat√≠sticas
    document.querySelectorAll('#estatisticas-banco-modal .avatar-tab-btn[data-tab-stats]').forEach(btn => {
      btn.addEventListener('click', () => {
        const tabId = btn.dataset.tabStats;
        
        // Desativa todas as abas e pain√©is
        document.querySelectorAll('#estatisticas-banco-modal .avatar-tab-btn[data-tab-stats]').forEach(t => t.classList.remove('ativo'));
        document.querySelectorAll('#estatisticas-banco-modal .avatar-tab-content').forEach(c => c.classList.remove('ativo'));

        // Ativa a aba e o painel clicados
        btn.classList.add('ativo');
        document.getElementById(`stats-tab-${tabId}`).classList.add('ativo');
      });
    });

// C√ìDIGO CORRIGIDO - COM NOMES DE SUBCATEGORIAS CORRETOS
function popularInventario() {
  const tabsContainer = document.getElementById('inventario-category-tabs');
  const contentContainer = document.getElementById('inventario-category-content');
  tabsContainer.innerHTML = '';
  contentContainer.innerHTML = '';

  const categorias = ['corpo', 'rosto', 'cabelo', 'roupa', 'acessorio', 'enfeite_de_parede', 'fundo'];

  const todasAsVariacoes = todosOsItensAvatar.flatMap(item => 
    item.variacoes.map(v => ({
      ...v,
      categoria: item.categoria,
      subcategoria: item.subcategoria || null,
      docId: item.docId,
      raro: item.raro || false
    }))
  );

  const inventarioCompleto = todasAsVariacoes.filter(v => inventarioAvatarCache.includes(v.id));

  categorias.forEach(cat => {
    let itensDaCategoria;
    if (cat === 'acessorio') {
      itensDaCategoria = inventarioCompleto.filter(item => item.categoria === cat && !item.raro);
    } else if (cat === 'enfeite_de_parede') {
      itensDaCategoria = inventarioCompleto.filter(item => item.categoria === cat || item.raro);
    } else {
      itensDaCategoria = inventarioCompleto.filter(item => item.categoria === cat);
    }

    if (itensDaCategoria.length > 0) {
      const tabButton = document.createElement('button');
      tabButton.className = 'avatar-category-tab';
      tabButton.dataset.category = cat;
      tabButton.textContent = nomesCategorias[cat];
      if (cat === 'enfeite_de_parede') tabButton.classList.add('tab-raro');
      tabsContainer.appendChild(tabButton);

      const contentPanel = document.createElement('div');
      contentPanel.id = `panel-inventario-${cat}`;
      contentPanel.className = 'avatar-category-content-panel';

      if (cat === 'acessorio') {
        const acessoriosAgrupados = itensDaCategoria.reduce((acc, item) => {
          const subcat = item.subcategoria || 'outros';
          if (!acc[subcat]) acc[subcat] = [];
          acc[subcat].push(item);
          return acc;
        }, {});

        for (const subcatNome in acessoriosAgrupados) {
          const header = document.createElement('h4');
          header.className = 'avatar-subcategory-header';
          header.textContent = nomesSubcategorias[subcatNome] || (subcatNome.charAt(0).toUpperCase() + subcatNome.slice(1));
          contentPanel.appendChild(header);
          
          const grid = document.createElement('div');
          grid.className = 'avatar-item-grid';
          acessoriosAgrupados[subcatNome].forEach(item => {
            const card = document.createElement('div');
            card.className = 'avatar-item-card';
            if (avatarTemporario.acessorio?.includes(item.id)) card.classList.add('selecionado');
            
            // =======================================================
            // BLOCO DE VISUALIZA√á√ÉO ATUALIZADO (INVENT√ÅRIO)
            // =======================================================
            if (item.categoria !== 'corpo' && item.categoria !== 'fundo') {
                // Adiciona o tom de pele para todos (exceto corpo e fundo)
                const peleAtualId = avatarTemporario.corpo;
                if (peleAtualId) {
                    const peleData = encontrarUrlItemPorId(peleAtualId);
                    if (peleData) card.innerHTML += `<img src="${peleData.url}" alt="Tom de Pele" class="avatar-layer-preview">`;
                }
                // Adiciona o cabelo APENAS se o acess√≥rio for um chap√©u
                if (item.categoria === 'acessorio' && item.subcategoria === 'chapeu') {
                    const cabeloAtualId = avatarTemporario.cabelo;
                    if (cabeloAtualId) {
                        const cabeloData = encontrarUrlItemPorId(cabeloAtualId);
                        if (cabeloData) card.innerHTML += `<img src="${cabeloData.url}" alt="Cabelo" class="avatar-layer-preview">`;
                    }
                }
            }
            // =======================================================
            // FIM DO BLOCO
            // =======================================================
            
            card.innerHTML += `<img src="${item.url}" alt="${item.nomeCor}" class="avatar-layer-preview">`;
            card.onclick = () => selecionarItemInventario('acessorio', item.id, card);
            grid.appendChild(card);
          });
          contentPanel.appendChild(grid);
        }
      } else {
        const grid = document.createElement('div');
        grid.className = 'avatar-item-grid';

        if (cat === 'cabelo' || cat === 'roupa') {
          const cardNenhum = document.createElement('div');
          cardNenhum.className = 'avatar-item-card';
          cardNenhum.innerHTML = `<div style="display:flex; justify-content:center; align-items:center; height:100%; font-size: 2rem; opacity: 0.5;">üö´</div>`;
          cardNenhum.title = "Remover item";
          if (!avatarTemporario[cat]) cardNenhum.classList.add('selecionado');
          cardNenhum.onclick = () => selecionarItemInventario(cat, null, cardNenhum);
          grid.appendChild(cardNenhum);
        }

        itensDaCategoria.forEach(item => {
          const card = document.createElement('div');
          card.className = 'avatar-item-card';
          const isSelected = Array.isArray(avatarTemporario[cat]) 
            ? avatarTemporario[cat].includes(item.id) 
            : avatarTemporario[cat] === item.id;
          if (isSelected) card.classList.add('selecionado');
          if (item.raro) card.classList.add('raro-exclusivo');
          
          // =======================================================
          // BLOCO DE VISUALIZA√á√ÉO ATUALIZADO (INVENT√ÅRIO)
          // =======================================================
          if (item.categoria !== 'corpo' && item.categoria !== 'fundo') {
              // Adiciona o tom de pele para todos (exceto corpo e fundo)
              const peleAtualId = avatarTemporario.corpo;
              if (peleAtualId) {
                  const peleData = encontrarUrlItemPorId(peleAtualId);
                  if (peleData) card.innerHTML += `<img src="${peleData.url}" alt="Tom de Pele" class="avatar-layer-preview">`;
              }
              // Adiciona o cabelo APENAS se o acess√≥rio for um chap√©u
              if (item.categoria === 'acessorio' && item.subcategoria === 'chapeu') {
                  const cabeloAtualId = avatarTemporario.cabelo;
                  if (cabeloAtualId) {
                      const cabeloData = encontrarUrlItemPorId(cabeloAtualId);
                      if (cabeloData) card.innerHTML += `<img src="${cabeloData.url}" alt="Cabelo" class="avatar-layer-preview">`;
                  }
              }
          }
          // =======================================================
          // FIM DO BLOCO
          // =======================================================

          card.innerHTML += `<img src="${item.url}" alt="${item.nomeCor}" class="avatar-layer-preview">`;
          card.onclick = () => selecionarItemInventario(cat, item.id, card);
          grid.appendChild(card);
        });
        contentPanel.appendChild(grid);
      }

      contentContainer.appendChild(contentPanel);
    }
  });

  setupCategoryTabs('inventario');
}

// NOVA FUN√á√ÉO PARA GERENCIAR AS ABAS DE CATEGORIA
function setupCategoryTabs(viewType) { // viewType pode ser 'inventario' ou 'loja'
  const tabsContainer = document.getElementById(`${viewType}-category-tabs`);
  const contentContainer = document.getElementById(`${viewType}-category-content`);
  
  const tabs = tabsContainer.querySelectorAll('.avatar-category-tab');
  const panels = contentContainer.querySelectorAll('.avatar-category-content-panel');

  if (tabs.length === 0) return;

  tabs.forEach(tab => {
    tab.addEventListener('click', () => {
      // Remove a classe 'ativo' de todas as abas e pain√©is
      tabs.forEach(t => t.classList.remove('ativo'));
      panels.forEach(p => p.classList.remove('ativo'));

      // Adiciona a classe 'ativo' √† aba clicada e ao seu painel correspondente
      tab.classList.add('ativo');
      const category = tab.dataset.category;
      document.getElementById(`panel-${viewType}-${category}`).classList.add('ativo');
    });
  });

  // Ativa a primeira aba por padr√£o
  tabs[0].click();
}

// FUN√á√ÉO ATUALIZADA: Permite experimentar acess√≥rios aplicando a l√≥gica de subcategoria
async function abrirModalExperimentar(categoria, itemId) {
  const avatarParaExperimentar = JSON.parse(JSON.stringify(avatarTemporario));

  // NOVO BLOCO: L√≥gica especial para experimentar acess√≥rios
  if (categoria === 'acessorio') {
    if (!Array.isArray(avatarParaExperimentar.acessorio)) {
      avatarParaExperimentar.acessorio = [];
    }
    
    const subcategoriaClicada = encontrarSubcategoria(itemId);
    
    // Remove qualquer item da mesma subcategoria que j√° esteja equipado na pr√©-visualiza√ß√£o
    avatarParaExperimentar.acessorio = avatarParaExperimentar.acessorio.filter(idEquipado => {
      return encontrarSubcategoria(idEquipado) !== subcategoriaClicada;
    });

    // Adiciona o novo item
    avatarParaExperimentar.acessorio.push(itemId);
  }
  // L√≥gica para sele√ß√£o m√∫ltipla de enfeites
  else if (categoria === 'enfeite_de_parede') {
      if (!Array.isArray(avatarParaExperimentar.enfeite_de_parede)) {
          avatarParaExperimentar.enfeite_de_parede = [];
      }
      if (!avatarParaExperimentar.enfeite_de_parede.includes(itemId)) {
         avatarParaExperimentar.enfeite_de_parede.push(itemId);
      }
  }
  // L√≥gica antiga para itens de sele√ß√£o √∫nica
  else {
      avatarParaExperimentar[categoria] = itemId;
  }
  
  const previewContainer = document.getElementById('avatar-try-on-container');
  openModal('avatar-try-on-modal');
  
  // Renderiza a c√≥pia do avatar com o novo item
  renderizarAvatarConfig(previewContainer, avatarParaExperimentar);
}

// C√ìDIGO CORRIGIDO - COM NOMES DE SUBCATEGORIAS CORRETOS NA LOJA
function popularLojaAvatar() {
  const tabsContainer = document.getElementById('loja-category-tabs');
  const contentContainer = document.getElementById('loja-category-content');
  tabsContainer.innerHTML = '';
  contentContainer.innerHTML = '';

  const categorias = ['corpo', 'rosto', 'cabelo', 'roupa', 'acessorio', 'enfeite_de_parede', 'fundo'];

  categorias.forEach(cat => {
    let itensDaCategoria;
    if (cat === 'acessorio') {
      itensDaCategoria = todosOsItensAvatar.filter(item => item.categoria === cat && !item.raro);
    } else if (cat === 'enfeite_de_parede') {
      itensDaCategoria = todosOsItensAvatar.filter(item => item.categoria === cat || item.raro);
    } else {
      itensDaCategoria = todosOsItensAvatar.filter(item => item.categoria === cat);
    }

    if (itensDaCategoria.length > 0) {
      const tabButton = document.createElement('button');
      tabButton.className = 'avatar-category-tab';
      tabButton.dataset.category = cat;
      tabButton.textContent = nomesCategorias[cat];
      if (cat === 'enfeite_de_parede') tabButton.classList.add('tab-raro');
      tabsContainer.appendChild(tabButton);

      const contentPanel = document.createElement('div');
      contentPanel.id = `panel-loja-${cat}`;
      contentPanel.className = 'avatar-category-content-panel';

      if (cat === 'acessorio') {
        const acessoriosAgrupados = itensDaCategoria.reduce((acc, item) => {
          const subcat = item.subcategoria || 'outros';
          if (!acc[subcat]) acc[subcat] = [];
          acc[subcat].push(item);
          return acc;
        }, {});

        for (const subcatNome in acessoriosAgrupados) {
          const header = document.createElement('h4');
          header.className = 'avatar-subcategory-header';
          header.textContent = nomesSubcategorias[subcatNome] || (subcatNome.charAt(0).toUpperCase() + subcatNome.slice(1));
          contentPanel.appendChild(header);

          const grid = document.createElement('div');
          grid.className = 'avatar-item-grid';
          acessoriosAgrupados[subcatNome].forEach(item => {
            const variacaoAleatoria = item.variacoes[Math.floor(Math.random() * item.variacoes.length)];
            const card = document.createElement('div');
            card.className = 'avatar-item-card';

            // =======================================================
            // BLOCO DE VISUALIZA√á√ÉO ATUALIZADO (LOJA)
            // =======================================================
            if (item.categoria !== 'corpo' && item.categoria !== 'fundo') {
                // Adiciona o tom de pele para todos (exceto corpo e fundo)
                const peleAtualId = avatarTemporario.corpo;
                if (peleAtualId) {
                    const peleData = encontrarUrlItemPorId(peleAtualId);
                    if (peleData) card.innerHTML += `<img src="${peleData.url}" alt="Tom de Pele" class="avatar-layer-preview">`;
                }
                // Adiciona o cabelo APENAS se o acess√≥rio for um chap√©u
                if (item.categoria === 'acessorio' && item.subcategoria === 'chapeu') {
                    const cabeloAtualId = avatarTemporario.cabelo;
                    if (cabeloAtualId) {
                        const cabeloData = encontrarUrlItemPorId(cabeloAtualId);
                        if (cabeloData) card.innerHTML += `<img src="${cabeloData.url}" alt="Cabelo" class="avatar-layer-preview">`;
                    }
                }
            }
            // =======================================================
            // FIM DO BLOCO
            // =======================================================

            card.innerHTML += `<img src="${variacaoAleatoria.url}" alt="${item.nome}" class="avatar-layer-preview">`;
            card.onclick = () => abrirModalVariacoes(item);
            grid.appendChild(card);
          });
          contentPanel.appendChild(grid);
        }
      } else {
        const grid = document.createElement('div');
        grid.className = 'avatar-item-grid';
        itensDaCategoria.forEach(item => {
          const variacaoAleatoria = item.variacoes[Math.floor(Math.random() * item.variacoes.length)];
          const card = document.createElement('div');
          card.className = 'avatar-item-card';
          if (item.raro) card.classList.add('raro-exclusivo');
          
          // =======================================================
          // BLOCO DE VISUALIZA√á√ÉO ATUALIZADO (LOJA)
          // =======================================================
          if (item.categoria !== 'corpo' && item.categoria !== 'fundo') {
              // Adiciona o tom de pele para todos (exceto corpo e fundo)
              const peleAtualId = avatarTemporario.corpo;
              if (peleAtualId) {
                  const peleData = encontrarUrlItemPorId(peleAtualId);
                  if (peleData) card.innerHTML += `<img src="${peleData.url}" alt="Tom de Pele" class="avatar-layer-preview">`;
              }
              // Adiciona o cabelo APENAS se o acess√≥rio for um chap√©u
              if (item.categoria === 'acessorio' && item.subcategoria === 'chapeu') {
                  const cabeloAtualId = avatarTemporario.cabelo;
                  if (cabeloAtualId) {
                      const cabeloData = encontrarUrlItemPorId(cabeloAtualId);
                      if (cabeloData) card.innerHTML += `<img src="${cabeloData.url}" alt="Cabelo" class="avatar-layer-preview">`;
                  }
              }
          }
          // =======================================================
          // FIM DO BLOCO
          // =======================================================

          card.innerHTML += `<img src="${variacaoAleatoria.url}" alt="${item.nome}" class="avatar-layer-preview">`;
          card.onclick = () => abrirModalVariacoes(item);
          grid.appendChild(card);
        });
        contentPanel.appendChild(grid);
      }

      contentContainer.appendChild(contentPanel);
    }
  });

  setupCategoryTabs('loja');
}

// NOVA FUN√á√ÉO: Aplica um item da loja ao avatar tempor√°rio para pr√©-visualiza√ß√£o
function experimentarItemLoja(categoria, itemId, cardElement) {
  // Atualiza o avatar tempor√°rio com o item selecionado
  avatarTemporario[categoria] = itemId;

  // Atualiza a pr√©-visualiza√ß√£o principal no editor
  const previewContainer = document.getElementById('avatar-preview-editor');
  renderizarAvatarTemporario(previewContainer);

  // Remove a classe 'selecionado' de outros cards de varia√ß√£o
  const grid = cardElement.parentElement;
  grid.querySelectorAll('.variation-card').forEach(c => c.classList.remove('selecionado'));
  
  // Adiciona a classe 'selecionado' ao card clicado para feedback visual
  cardElement.classList.add('selecionado');
}

// FUN√á√ÉO ATUALIZADA: Agora gerencia a sele√ß√£o m√∫ltipla de acess√≥rios por subcategoria
async function selecionarItemInventario(categoria, itemId, cardElement) {
  // L√≥gica para sele√ß√£o m√∫ltipla de acess√≥rios
  if (categoria === 'acessorio') {
    // Garante que o campo de acess√≥rios seja sempre um array
    if (!Array.isArray(avatarTemporario.acessorio)) {
      avatarTemporario.acessorio = [];
    }

    // Caso especial para o bot√£o de remover (üö´)
    if (itemId === null) {
      avatarTemporario.acessorio = []; // Limpa todos os acess√≥rios
      // Desmarca todos os cards de acess√≥rio
      const todosCardsAcessorios = document.querySelectorAll('#avatar-tab-inventario .avatar-item-card');
      todosCardsAcessorios.forEach(card => card.classList.remove('selecionado'));
      cardElement.classList.add('selecionado'); // Marca apenas o bot√£o "nenhum"
    } else {
      const subcategoriaClicada = encontrarSubcategoria(itemId);
      let itemDaMesmaSubcategoriaJaEquipado = null;

      // Verifica se j√° existe um item da mesma subcategoria no avatar
      for (const idEquipado of avatarTemporario.acessorio) {
        if (encontrarSubcategoria(idEquipado) === subcategoriaClicada) {
          itemDaMesmaSubcategoriaJaEquipado = idEquipado;
          break;
        }
      }
      
      // Se o item clicado j√° estiver equipado, desequipa ele
      if (avatarTemporario.acessorio.includes(itemId)) {
        avatarTemporario.acessorio = avatarTemporario.acessorio.filter(id => id !== itemId);
        cardElement.classList.remove('selecionado');
      } 
      // Se j√° existe um item da mesma subcategoria, substitui pelo novo
      else if (itemDaMesmaSubcategoriaJaEquipado) {
        avatarTemporario.acessorio = avatarTemporario.acessorio.filter(id => id !== itemDaMesmaSubcategoriaJaEquipado);
        avatarTemporario.acessorio.push(itemId);
        // Atualiza a interface: desmarca o antigo e marca o novo
        const grid = cardElement.parentElement;
        grid.querySelectorAll('.avatar-item-card').forEach(c => {
            if (c.onclick.toString().includes(itemDaMesmaSubcategoriaJaEquipado)) {
                c.classList.remove('selecionado');
            }
        });
        cardElement.classList.add('selecionado');
      } 
      // Se for um novo item de uma nova subcategoria, apenas adiciona
      else {
        avatarTemporario.acessorio.push(itemId);
        cardElement.classList.add('selecionado');
      }
      
      // Garante que o bot√£o "nenhum" seja desmarcado se algum acess√≥rio for selecionado
      const grid = cardElement.parentElement;
      const cardNenhum = Array.from(grid.querySelectorAll('.avatar-item-card')).find(c => c.onclick.toString().includes('null'));
      if (cardNenhum) {
          cardNenhum.classList.remove('selecionado');
      }
    }
  } 
  // L√≥gica para sele√ß√£o m√∫ltipla de enfeites (comportamento mantido)
  else if (categoria === 'enfeite_de_parede') {
    if (!Array.isArray(avatarTemporario.enfeite_de_parede)) {
      avatarTemporario.enfeite_de_parede = [];
    }
    const itemIndex = avatarTemporario.enfeite_de_parede.indexOf(itemId);
    
    if (itemIndex > -1) {
      avatarTemporario.enfeite_de_parede.splice(itemIndex, 1);
      cardElement.classList.remove('selecionado');
    } else {
      avatarTemporario.enfeite_de_parede.push(itemId);
      cardElement.classList.add('selecionado');
    }
  } 
  // L√≥gica para sele√ß√£o √∫nica (comportamento antigo mantido)
  else {
    avatarTemporario[categoria] = itemId;
    const grid = cardElement.parentElement;
    grid.querySelectorAll('.avatar-item-card').forEach(c => c.classList.remove('selecionado'));
    cardElement.classList.add('selecionado');
  }

  // Renderiza a pr√©-visualiza√ß√£o com as altera√ß√µes
  const previewContainer = document.getElementById('avatar-preview-editor');
  renderizarAvatarTemporario(previewContainer);
}

document.getElementById('avatar-save-btn').onclick = async function() {
  try {
    await updateDoc(doc(db, "membros", currentUser), {
      avatar: avatarTemporario
    });
    mostrarPopup("‚úÖ Sucesso!", "Seu avatar foi salvo com sucesso.", 4000);
    closeModal('avatar-editor-modal');
    // Atualiza o avatar principal no painel do usu√°rio
    const avatarContainer = document.getElementById('avatar-display-pessoal');
    await renderizarAvatar(currentUser, avatarContainer);
  } catch (error) {
    console.error("Erro ao salvar avatar:", error);
    mostrarPopup("‚ùå Erro", "N√£o foi poss√≠vel salvar seu avatar.", 4000);
  }
};

// ATUALIZADA (v3.1): Adiciona uma classe ao container dos bot√µes para estiliza√ß√£o
async function abrirModalVariacoes(item) {
  const grid = document.getElementById('variations-grid');
  document.getElementById('variations-item-name').textContent = item.nome;
  grid.innerHTML = '<p>Carregando...</p>';
  
  const descriptionEl = document.getElementById('variations-item-description');
  if (item.raro && item.variacoes[0] && item.variacoes[0].descricao) {
      descriptionEl.innerHTML = `<strong>Como obter:</strong> ${item.variacoes[0].descricao}`;
      descriptionEl.classList.remove('hidden');
  } else {
      descriptionEl.classList.add('hidden');
  }
  
  openModal('item-variations-modal');

  try {
    const membroDoc = await getDoc(doc(db, "membros", currentUser));
    if (!membroDoc.exists()) throw "Membro n√£o encontrado.";
    
    const membroData = membroDoc.data();
    const moedasAtuais = membroData.moedas || 0;
    const inventarioAtual = membroData.inventarioAvatar || [];

    grid.innerHTML = '';

    for (const variacao of item.variacoes) {
      const possui = inventarioAtual.includes(variacao.id);
      const podeComprar = moedasAtuais >= variacao.preco;
      const permissaoParaComprar = await verificarPermissaoCompra(variacao.id);

      const card = document.createElement('div');
      card.className = 'variation-card';
      if (item.raro) {
        card.classList.add('raro-exclusivo');
      }

      const imageContainer = document.createElement('div');
      imageContainer.className = 'variation-image-container';
      
      // =======================================================
      // BLOCO DE VISUALIZA√á√ÉO ATUALIZADO (VARIA√á√ïES)
      // =======================================================
      if (item.categoria !== 'corpo' && item.categoria !== 'fundo') {
          // Adiciona o tom de pele para todos (exceto corpo e fundo)
          const peleAtualId = avatarTemporario.corpo;
          if (peleAtualId) {
              const peleData = encontrarUrlItemPorId(peleAtualId);
              if (peleData) imageContainer.innerHTML += `<img src="${peleData.url}" alt="Tom de Pele" class="avatar-layer-preview">`;
          }
          // Adiciona o cabelo APENAS se o acess√≥rio for um chap√©u
          if (item.categoria === 'acessorio' && item.subcategoria === 'chapeu') {
              const cabeloAtualId = avatarTemporario.cabelo;
              if (cabeloAtualId) {
                  const cabeloData = encontrarUrlItemPorId(cabeloAtualId);
                  if (cabeloData) imageContainer.innerHTML += `<img src="${cabeloData.url}" alt="Cabelo" class="avatar-layer-preview">`;
              }
          }
      }
      // =======================================================
      // FIM DO BLOCO
      // =======================================================

      const img = document.createElement('img');
      img.src = variacao.url;
      img.alt = variacao.nomeCor;
      img.className = 'avatar-layer-preview'; // Adiciona a classe para o CSS
      imageContainer.appendChild(img);
      card.appendChild(imageContainer);

      const infoContainer = document.createElement('div');
      infoContainer.className = 'variation-info';
      
      const textDiv = document.createElement('div');
      textDiv.innerHTML = `<div>${variacao.nomeCor}</div><div class="item-preco">${possui ? 'Adquirido' : `üí∞ ${variacao.preco}`}</div>`;
      infoContainer.appendChild(textDiv);

      const botoesContainer = document.createElement('div');
      botoesContainer.style.marginTop = '10px';

      if (possui) {
        const estaEquipado = Array.isArray(avatarTemporario[item.categoria])
          ? avatarTemporario[item.categoria].includes(variacao.id)
          : avatarTemporario[item.categoria] === variacao.id;
        
        const equiparBtn = document.createElement('button');
        equiparBtn.className = 'painel-btn btn-adicionar';
        equiparBtn.textContent = estaEquipado ? 'Equipado' : 'Equipar';
        equiparBtn.disabled = estaEquipado;
        if (!estaEquipado) {
          equiparBtn.onclick = () => {
            selecionarItemInventario(item.categoria, variacao.id, card);
            closeModal('item-variations-modal');
          };
        }
        botoesContainer.appendChild(equiparBtn);

      } else if (!permissaoParaComprar) {
        const exclusivoBtn = document.createElement('button');
        exclusivoBtn.className = 'painel-btn btn-adicionar';
        exclusivoBtn.textContent = 'üîí';
        exclusivoBtn.title = 'Item exclusivo';
        exclusivoBtn.disabled = true;
        botoesContainer.appendChild(exclusivoBtn);

      } else {
        const containerFlex = document.createElement('div');
        containerFlex.className = 'variation-button-container'; 
        containerFlex.style.display = 'flex';
        containerFlex.style.gap = '8px';
        containerFlex.style.justifyContent = 'center';

        const experimentarBtn = document.createElement('button');
        experimentarBtn.className = 'painel-btn';
        experimentarBtn.style.backgroundColor = '#3498db';
        experimentarBtn.textContent = 'Experimentar';
        experimentarBtn.onclick = () => abrirModalExperimentar(item.categoria, variacao.id);
        containerFlex.appendChild(experimentarBtn);

        const comprarBtn = document.createElement('button');
        comprarBtn.textContent = podeComprar ? 'Comprar' : 'Insuficiente';
        if (podeComprar) {
          comprarBtn.className = 'painel-btn btn-adicionar';
          comprarBtn.onclick = () => confirmarCompraAvatar(variacao.id, variacao.preco);
        } else {
          comprarBtn.className = 'painel-btn btn-remover';
          comprarBtn.disabled = true;
          comprarBtn.title = 'Moedas insuficientes';
        }
        containerFlex.appendChild(comprarBtn);
        botoesContainer.appendChild(containerFlex);
      }
      
      infoContainer.appendChild(botoesContainer);
      card.appendChild(infoContainer);
      grid.appendChild(card);
    }

  } catch (error) {
    console.error("Erro ao abrir modal de varia√ß√µes:", error);
    grid.innerHTML = '<p>Ocorreu um erro ao carregar os itens.</p>';
  }
}

window.confirmarCompraAvatar = function(itemId, preco) {
  const itemData = encontrarUrlItemPorId(itemId);
  document.getElementById('confirm-purchase-text').innerHTML = `Voc√™ deseja comprar <strong>${itemData.nomeCor}</strong> por <strong>üí∞ ${preco} moedas</strong>?`;
  
  document.getElementById('confirm-purchase-btn').onclick = () => executarCompraAvatar(itemId, preco);
  
  openModal('confirm-avatar-purchase-modal');
}

async function executarCompraAvatar(itemId, preco) {
  closeModal('confirm-avatar-purchase-modal');
  const membroRef = doc(db, "membros", currentUser);

  try {
    await runTransaction(db, async (transaction) => {
      const membroDoc = await transaction.get(membroRef);
      if (!membroDoc.exists()) throw "Membro n√£o encontrado.";

      const moedasAtuais = membroDoc.data().moedas || 0;
      if (moedasAtuais < preco) throw "Moedas insuficientes.";
      
      transaction.update(membroRef, {
        moedas: increment(-preco),
        inventarioAvatar: arrayUnion(itemId)
      });
    });

    inventarioAvatarCache.push(itemId); // Atualiza o cache local
    mostrarPopup("üéâ Compra Realizada!", "O item foi adicionado ao seu invent√°rio.", 4000);
    closeModal('item-variations-modal'); // Fecha o modal de varia√ß√µes
    popularLojaAvatar(); // Atualiza a loja para remover o item comprado

  } catch (error) {
    console.error("Erro na compra do avatar:", error);
    mostrarPopup("‚ùå Falha na Compra", error.toString(), 4000);
  }
}

document.getElementById('avatar-gallery-btn').onclick = async function() {
  const grid = document.getElementById('gallery-grid-container');
  grid.innerHTML = '<p>Carregando avatares...</p>';
  openModal('avatar-gallery-modal');

  try {
    const membrosSnapshot = await getDocs(collection(db, "membros"));
    grid.innerHTML = '';
    
    await Promise.all(membrosSnapshot.docs.map(async (doc) => {
      const nomeMembro = doc.id;
      const itemContainer = document.createElement('div');
      itemContainer.className = 'gallery-avatar-item';
      
      // --- LINHA ADICIONADA AQUI ---
      // Adiciona o evento de clique para abrir o visualizador em tela cheia.
      itemContainer.onclick = () => abrirVisualizadorDeAvatar(nomeMembro);
      
      const avatarContainer = document.createElement('div');
      avatarContainer.className = 'gallery-avatar-container';
      
      const nomeEl = document.createElement('div');
      nomeEl.className = 'gallery-avatar-nome';
      nomeEl.textContent = nomeMembro;
      
      itemContainer.appendChild(avatarContainer);
      itemContainer.appendChild(nomeEl);
      grid.appendChild(itemContainer);

      await renderizarAvatar(nomeMembro, avatarContainer);
    }));

  } catch (error) {
    console.error("Erro ao carregar galeria:", error);
    grid.innerHTML = '<p>Erro ao carregar a galeria.</p>';
  }
};

// ADICIONE ESTAS DUAS NOVAS FUN√á√ïES

// Compara o avatar original com o modificado
function avatarTemAlteracoesNaoSalvas() {
    if (!avatarOriginal || !avatarTemporario) return false;
    // Compara as vers√µes do avatar para ver se h√° diferen√ßas
    return JSON.stringify(avatarOriginal) !== JSON.stringify(avatarTemporario);
}

window.tentarFecharEditorAvatar = function() {
    if (avatarTemAlteracoesNaoSalvas()) {
        showConfirmationPopup(
          '‚ö†Ô∏è Altera√ß√µes n√£o Salvas',
          'Voc√™ tem altera√ß√µes n√£o salvas. Deseja sair mesmo assim?',
          () => { closeModal('avatar-editor-modal'); }
        );
    } else {
        closeModal('avatar-editor-modal');
    }
}

// --- Fun√ß√£o para abrir o visualizador de avatar em tela cheia ---
async function abrirVisualizadorDeAvatar(membroId) {
  const viewerContainer = document.getElementById('avatar-viewer-container');
  const viewerNome = document.getElementById('avatar-viewer-nome');
  
  // Mostra um feedback de "carregando" e o nome do membro
  viewerContainer.innerHTML = '<p style="text-align: center; margin-top: 50%;">Carregando...</p>';
  viewerNome.textContent = membroId;
  
  // Abre o modal
  openModal('avatar-viewer-modal');
  
  // Chama a nossa fun√ß√£o (agora corrigida) para renderizar o avatar no container do modal
  await renderizarAvatar(membroId, viewerContainer);
}

function abrirVisualizadorDoEditor() {
  const viewerContainer = document.getElementById('editor-avatar-viewer-container');
  // Usa a fun√ß√£o que j√° existe para renderizar o avatar com as edi√ß√µes tempor√°rias
  renderizarAvatarTemporario(viewerContainer); 
  openModal('editor-avatar-viewer-modal');
}

// COLE ESTE C√ìDIGO SUBSTITUINDO A FUN√á√ÉO ANTIGA E COM ERRO

async function verificarPermissaoCompra(itemId) {
    if (!currentUser) return false;

    // Busca os dados mais recentes do membro para a verifica√ß√£o
    const membroDoc = await getDoc(doc(db, "membros", currentUser));
    if (!membroDoc.exists()) return false;
    const dadosMembro = membroDoc.data();
    
    // =======================================================
    // <-- IN√çCIO DA CORRE√á√ÉO (L√ìGICA REORDENADA)
    // A verifica√ß√£o de itens com regras especiais (coroas) agora vem PRIMEIRO.
    // Isso garante que elas tenham prioridade sobre a verifica√ß√£o gen√©rica de "raro".
    // =======================================================

    switch (itemId) {
        // REGRAS DAS COROAS DE L√çDER (PRIORIDADE M√ÅXIMA)
        case 'coroa_lider_geral':
            return dadosMembro.papel === 'lider';
        case 'coroa_abelha':
            return dadosMembro.papel === 'lider-equipe' && dadosMembro.equipe === 'abelha';
        case 'coroa_joaninha':
            return dadosMembro.papel === 'lider-equipe' && dadosMembro.equipe === 'joaninha';
        case 'coroa_vagalume':
            return dadosMembro.papel === 'lider-equipe' && dadosMembro.equipe === 'vagalume';

        // REGRAS DAS PLACAS DE EQUIPE (PRIORIDADE M√ÅXIMA)
        case 'placa_abelha':
            return dadosMembro.equipe === 'abelha';
        case 'placa_joaninha':
            return dadosMembro.equipe === 'joaninha';
        case 'placa_vagalume':
            return dadosMembro.equipe === 'vagalume';

        // SE N√ÉO FOR UM ITEM ESPECIAL, VERIFICA AS OUTRAS REGRAS
        default:
            // Encontra o item na nossa lista local para ver se ele √© raro
            const itemPai = todosOsItensAvatar.find(item => item.variacoes.some(v => v.id === itemId));

            // Se o item for RARO, a permiss√£o depende do array 'permissoesItensRaros'
            if (itemPai && itemPai.raro) {
                // Caso especial da bandeira (compatibilidade)
                if (itemId === 'bandeira_rara_1') {
                    return dadosMembro.podeComprarBandeiraRara === true;
                }
                // L√≥gica para todos os outros itens raros
                const permissoes = dadosMembro.permissoesItensRaros || [];
                return permissoes.includes(itemId);
            }
            
            // Se o item n√£o for raro e n√£o tiver regras especiais, todos podem compr√°-lo.
            return true;
    }
	}

// =============================================
// ===== SISTEMA DE AVATAR (FIM) =====
// =============================================

// =============================================
// ===== NOVO SISTEMA DE ADI√á√ÉO DE ITENS DE AVATAR =====
// =============================================

// NOVA FUN√á√ÉO MESTRA: Renderiza qualquer configura√ß√£o de avatar em um container
function renderizarAvatarConfig(container, configAvatar) {
  container.innerHTML = '';
  if (!configAvatar) return;

  const categorias = ['fundo', 'corpo', 'roupa', 'cabelo', 'rosto', 'acessorio', 'enfeite_de_parede'];

  for (const categoria of categorias) {
    const itemIds = configAvatar[categoria];

    if (Array.isArray(itemIds)) {
      for (const itemId of itemIds) {
        if (itemId) {
          const itemData = encontrarUrlItemPorId(itemId);
          if (itemData) {
            const img = document.createElement('img');
            img.src = itemData.url;
            
            // L√≥gica essencial para adicionar a classe da subcategoria
            const subcategoria = (categoria === 'acessorio') ? encontrarSubcategoria(itemId) : '';
            img.className = `avatar-layer ${categoria} ${subcategoria || ''}`;
            
            container.appendChild(img);
          }
        }
      }
    } else {
      // L√≥gica para itens √∫nicos (strings)
      if (itemIds) {
        const itemData = encontrarUrlItemPorId(itemIds);
        if (itemData) {
          const img = document.createElement('img');
          img.src = itemData.url;
          img.className = `avatar-layer ${categoria}`;
          container.appendChild(img);
        }
      }
    }
  }
}

// Abre o modal e reseta o formul√°rio para um novo item
function abrirModalAdicionarItemAvatar() {
  resetarFormularioItemAvatar();
  openModal('add-avatar-item-modal');
}

async function popularListaMembrosPermissao() {
  const listaContainer = document.getElementById('add-item-membros-lista');
  if (!listaContainer) return;

  listaContainer.innerHTML = '<p>Carregando membros...</p>';
  
  // Usamos a vari√°vel global 'todosMembros' que j√° est√° carregada
  const membrosOrdenados = [...todosMembros].sort((a, b) => a.nome.localeCompare(b.nome));

  listaContainer.innerHTML = '';
  membrosOrdenados.forEach(membro => {
    const itemEl = document.createElement('div');
    itemEl.style.marginBottom = '8px';
    itemEl.innerHTML = `
      <input type="checkbox" id="perm_${membro.nome}" value="${membro.nome}" class="membro-permissao-check">
      <label for="perm_${membro.nome}" style="margin-left: 8px;">${membro.nome}</label>
    `;
    listaContainer.appendChild(itemEl);
  });
}

// --- NOVAS FUN√á√ïES: GERENCIADOR DE IDIOMAS ---

async function toggleIdiomaMembro(nome, novoIdioma) {
  try {
    const membroRef = doc(db, "membros", nome);
    
    await updateDoc(membroRef, { 
        idioma: novoIdioma 
    });
    
    // Atualiza o cache local imediatamente
    const index = todosMembros.findIndex(m => m.nome === nome);
    if (index !== -1) {
        todosMembros[index].idioma = novoIdioma;
    }

    mostrarPopup("‚úÖ Atualizado", `Idioma de ${nome} definido como: ${novoIdioma}`, 2000);
  } catch (error) {
    console.error(`Erro ao atualizar idioma para ${nome}:`, error);
    mostrarPopup("‚ùå Erro", "N√£o foi poss√≠vel salvar a altera√ß√£o.", 4000);
  }
}

function popularPainelIdiomas() {
  const listaContainer = document.getElementById('idiomas-lista-membros');
  if (!listaContainer) return;
  
  listaContainer.innerHTML = ''; 

  const membrosOrdenados = [...todosMembros].sort((a, b) => a.nome.localeCompare(b.nome));

  membrosOrdenados.forEach(membro => {
    const itemEl = document.createElement('div');
    itemEl.className = 'ferias-item';
    itemEl.style.justifyContent = "space-between"; 

    let valorAtual = membro.idioma || 'pt-BR';

    itemEl.innerHTML = `
      <label for="idioma_${membro.nome}" style="font-weight: 500;">${membro.nome}</label>
      <select id="idioma_${membro.nome}" class="painel-input" style="width: 140px; padding: 5px;">
        <option value="pt-BR" ${valorAtual === 'pt-BR' ? 'selected' : ''}>üáßüá∑ Portugu√™s</option>
        <option value="es" ${valorAtual === 'es' ? 'selected' : ''}>üá™üá∏ Espa√±ol</option>
        <option value="en" ${valorAtual === 'en' ? 'selected' : ''}>üá∫üá∏ English</option>
      </select>
    `;

    itemEl.querySelector('select').addEventListener('change', (e) => {
      toggleIdiomaMembro(membro.nome, e.target.value);
    });

    listaContainer.appendChild(itemEl);
  });
}

// Limpa todos os campos do formul√°rio
function resetarFormularioItemAvatar() {
  document.getElementById('add-item-nome').value = '';
  document.getElementById('add-item-categoria').value = '';
  document.getElementById('add-item-raro').checked = false;
  document.getElementById('add-item-raro-descricao').value = '';
  document.getElementById('add-item-raro-descricao-container').classList.add('hidden');
  document.getElementById('add-item-variations-container').innerHTML = '';
  // Adiciona o primeiro campo de varia√ß√£o automaticamente
  adicionarCampoVariacao();
}

// Adiciona dinamicamente um novo conjunto de campos para uma varia√ß√£o de cor
function adicionarCampoVariacao() {
  const container = document.getElementById('add-item-variations-container');
  const variationDiv = document.createElement('div');
  variationDiv.style.display = 'grid';
  variationDiv.style.gridTemplateColumns = '2fr 3fr 1fr auto';
  variationDiv.style.gap = '10px';
  variationDiv.style.alignItems = 'center';

  variationDiv.innerHTML = `
    <input type="text" class="painel-input variation-nomeCor" placeholder="Nome da Cor (Ex: Azul)">
    <input type="text" class="painel-input variation-url" placeholder="Link da Imagem (URL)">
    <input type="number" class="painel-input variation-preco" placeholder="Pre√ßo üí∞">
    <button class="painel-btn btn-remover" onclick="this.parentElement.remove()">X</button>
  `;
  container.appendChild(variationDiv);
}

window.adicionarCampoVariacao = adicionarCampoVariacao;

async function salvarItemAvatar() {
  // 1. Coletar dados gerais (sem altera√ß√µes)
  const nome = document.getElementById('add-item-nome').value.trim();
  const categoria = document.getElementById('add-item-categoria').value;
  const raro = document.getElementById('add-item-raro').checked;
  const descricaoRaro = document.getElementById('add-item-raro-descricao').value.trim();

  // 2. Validar dados gerais (sem altera√ß√µes)
  if (!nome || !categoria) {
    mostrarPopup("‚ùå Erro de Valida√ß√£o", "O Nome e a Categoria do item s√£o obrigat√≥rios.", 4000);
    return;
  }
  if (raro && !descricaoRaro) {
    mostrarPopup("‚ùå Erro de Valida√ß√£o", "Se o item √© raro, voc√™ deve fornecer uma descri√ß√£o de como obt√™-lo.", 5000);
    return;
  }

  // 3. Coletar subcategoria (sem altera√ß√µes)
  let subcategoria = null;
  if (categoria === 'acessorio') {
    subcategoria = document.getElementById('add-item-subcategoria').value;
    if (!subcategoria) {
      mostrarPopup("‚ùå Erro de Valida√ß√£o", "Voc√™ deve selecionar uma subcategoria para um acess√≥rio.", 4000);
      return;
    }
  }

  // 4. Coletar e validar as varia√ß√µes (sem altera√ß√µes)
  const variationsContainer = document.getElementById('add-item-variations-container');
  const variationElements = variationsContainer.children;
  if (variationElements.length === 0) {
    mostrarPopup("‚ùå Erro de Valida√ß√£o", "Voc√™ deve adicionar pelo menos uma varia√ß√£o de cor para o item.", 4000);
    return;
  }

  const variacoes = [];
  for (const element of variationElements) {
    const nomeCor = element.querySelector('.variation-nomeCor').value.trim();
    const url = element.querySelector('.variation-url').value.trim();
    const preco = parseInt(element.querySelector('.variation-preco').value, 10);

    if (!nomeCor || !url || isNaN(preco)) {
      mostrarPopup("‚ùå Erro de Valida√ß√£o", "Todos os campos de todas as varia√ß√µes (Nome da Cor, URL e Pre√ßo) devem ser preenchidos corretamente.", 5000);
      return;
    }

    const idSeguro = nome.toLowerCase().replace(/[^a-z0-9]/g, '_') + '_' + nomeCor.toLowerCase().replace(/[^a-z0-9]/g, '_');
    const variationId = `${categoria}_${idSeguro}`;
    
    variacoes.push({
      id: variationId,
      nomeCor: nomeCor,
      url: url,
      preco: preco,
      descricao: raro ? descricaoRaro : ""
    });
  }

  // 5. Montar o objeto final do item (sem altera√ß√µes)
  const novoItem = {
    nome: nome,
    categoria: categoria,
    subcategoria: subcategoria,
    raro: raro,
    variacoes: variacoes
  };

  // ===== 6. L√ìGICA DE SALVAMENTO ATUALIZADA (AQUI EST√Å A MUDAN√áA!) =====
  try {
    const docId = nome.toLowerCase().replace(/\s+/g, '_').replace(/[^a-z0-9_]/g, '');
    const itemRef = doc(db, "loja_avatar_itens", docId);
    
    // Usaremos um batch para garantir que todas as opera√ß√µes (salvar item e dar permiss√µes)
    // aconte√ßam juntas ou nenhuma aconte√ßa.
    const batch = writeBatch(db);

    // Adiciona a opera√ß√£o de salvar o novo item ao batch
    batch.set(itemRef, novoItem);

    // Se o item for raro, adiciona as permiss√µes aos membros selecionados
    if (raro) {
      const membrosPermitidos = document.querySelectorAll('.membro-permissao-check:checked');
      if (membrosPermitidos.length > 0) {
        // Pega o ID da primeira varia√ß√£o para usar como ID da permiss√£o
        const idDaPermissao = variacoes[0].id; 
        
        membrosPermitidos.forEach(checkbox => {
          const nomeMembro = checkbox.value;
          const membroRef = doc(db, "membros", nomeMembro);
          // Adiciona a opera√ß√£o de dar permiss√£o ao batch
          batch.update(membroRef, {
            permissoesItensRaros: arrayUnion(idDaPermissao)
          });
        });
      }
    }

    // Executa todas as opera√ß√µes do batch
    await batch.commit();

    // Atualiza o cache local e finaliza
    todosOsItensAvatar.push({ docId: docId, ...novoItem });
    mostrarPopup("‚úÖ Sucesso!", `O item "${nome}" foi adicionado √† loja com sucesso!`, 5000);
    closeModal('add-avatar-item-modal');

  } catch (error) {
    console.error("Erro ao salvar novo item de avatar:", error);
    mostrarPopup("üî• Erro Cr√≠tico", "N√£o foi poss√≠vel salvar o item no banco de dados. Verifique o console.", 5000);
  }
}

// Fun√ß√£o para carregar um arquivo CSS dinamicamente e esperar por ele
function loadCSS(href) {
  return new Promise((resolve, reject) => {
    const link = document.createElement('link');
    link.rel = 'stylesheet';
    link.href = href;
    link.onload = () => resolve();
    link.onerror = () => reject(new Error(`Falha ao carregar o CSS: ${href}`));
    document.head.appendChild(link);
  });
}

// =============================================
// ===== NOVO SISTEMA DE ENVIO DE MOEDAS =====
// =============================================

// Fun√ß√£o para abrir o modal de envio de moedas
async function abrirModalEnvioMoedas() {
  if (!currentUser || !userTeam) {
    mostrarPopup("‚ö†Ô∏è Aten√ß√£o", "Voc√™ precisa pertencer a uma equipe para enviar moedas.", 4000);
    return;
  }

  const hojeISO = getHojeISO();
  const listaContainer = document.getElementById('envio-moedas-lista');
  
  // Verifica√ß√£o de seguran√ßa: Se o container n√£o existir, para a execu√ß√£o.
  if (!listaContainer) {
      console.error("Erro Cr√≠tico: O container #envio-moedas-lista n√£o foi encontrado no HTML.");
      mostrarPopup("‚ùå Erro de Interface", "N√£o foi poss√≠vel abrir o painel de envio.", 4000);
      return;
  }

  listaContainer.innerHTML = '<div class="ociosos-placeholder">Carregando...</div>';
  openModal('envio-moedas-modal');

  try {
    const enviosRef = doc(db, "enviosDiarios", `${currentUser}_${hojeISO}`);
    const docSnap = await getDoc(enviosRef);
    const jaEnviados = docSnap.exists() ? docSnap.data().enviadoPara : [];

    const colegasDeEquipe = todosMembros.filter(m => m.equipe === userTeam && m.nome !== currentUser);

    if (colegasDeEquipe.length === 0) {
      listaContainer.innerHTML = '<div class="ociosos-placeholder">Voc√™ n√£o tem colegas de equipe para enviar moedas.</div>';
      return;
    }

    listaContainer.innerHTML = '';
    colegasDeEquipe.forEach(colega => {
      const nomeColega = colega.nome;
      const jaRecebeuHoje = jaEnviados.includes(nomeColega);
      
      const itemEl = document.createElement('div');
      itemEl.className = 'envio-membro-item';
      
      itemEl.innerHTML = `
        <input type="checkbox" id="enviar-para-${nomeColega}" value="${nomeColega}" ${jaRecebeuHoje ? 'checked disabled' : ''}>
        <label for="enviar-para-${nomeColega}">${nomeColega}</label>
        ${jaRecebeuHoje ? '<span class="status-enviado">‚úî Enviado</span>' : ''}
      `;
      listaContainer.appendChild(itemEl);
    });

  } catch (error) {
    console.error("Erro ao abrir modal de envio de moedas:", error);
    mostrarPopup("‚ùå Erro", "N√£o foi poss√≠vel carregar a lista de membros.", 4000);
    closeModal('envio-moedas-modal');
  }
}

// SUBSTITUA A SUA FUN√á√ÉO ANTIGA POR ESTA VERS√ÉO CORRIGIDA
async function executarEnvioMoedas(modalId) {
  // NOVO BLOCO DE SEGURAN√áA (A TRAVA)
  if (enviandoMoedas) {
    console.warn("Uma opera√ß√£o de envio de moedas j√° est√° em andamento. Aguarde.");
    return; // Impede a execu√ß√£o dupla
  }
  enviandoMoedas = true; // Ativa a trava
  // FIM DO NOVO BLOCO

  const containerId = modalId === 'envio-moedas-modal' ? 'envio-moedas-lista' : 'envio-moedas-lista-popup';
  const checkboxes = document.querySelectorAll(`#${containerId} input[type="checkbox"]:checked:not(:disabled)`);
  
  // O 'finally' garante que a trava ser√° desativada, mesmo se ocorrer um erro.
  try {
    if (checkboxes.length === 0) {
      mostrarPopup("ü§î Selecione", "Voc√™ precisa selecionar pelo menos um colega para enviar moedas.", 4000);
      return; // Retorna para que o 'finally' seja executado
    }

    const destinatarios = Array.from(checkboxes).map(cb => cb.value);
    const hojeISO = getHojeISO();
    const enviosRef = doc(db, "enviosDiarios", `${currentUser}_${hojeISO}`);

    const batch = writeBatch(db);

    // Bloco de c√≥digo para COPIAR E COLAR
destinatarios.forEach(nomeDestinatario => {
  const membroRef = doc(db, "membros", nomeDestinatario);
  batch.update(membroRef, { moedas: increment(100) }); // <-- ALTERADO AQUI

  const notificacaoRef = doc(collection(db, "notificacoes"));
  batch.set(notificacaoRef, {
    destinatarioId: nomeDestinatario,
    remetenteNome: currentUser,
    tipo: 'moedas',
    conteudo: 'üéÅ',
    acao: `enviou 100 üí∞ moedas para voc√™ como presente di√°rio!`, // <-- ALTERADO AQUI
    lida: false,
    timestamp: new Date()
  });
});

batch.set(enviosRef, { enviadoPara: destinatarios }, { merge: true });

await batch.commit();

closeModal(modalId);
mostrarPopup("‚úÖ Sucesso!", `${destinatarios.length * 100} moedas foram enviadas com sucesso!`, 5000); // <-- ALTERADO AQUI

  } catch (error) {
    console.error("Erro ao enviar moedas:", error);
    mostrarPopup("‚ùå Erro", "Ocorreu uma falha ao enviar as moedas.", 5000);
  } finally {
    // NOVO: Desativa a trava, permitindo um novo envio no futuro.
    enviandoMoedas = false;
  }
}

async function verificarPopupEnvioDiario() {
  // REMOVIDO: A verifica√ß√£o de sessionStorage. 
  // Agora ele vai tentar abrir sempre que voc√™ entrar, a menos que j√° tenha enviado as moedas.
  
  if (!currentUser || !userTeam) {
    return;
  }

  const hojeISO = getHojeISO();
  const enviosRef = doc(db, "enviosDiarios", `${currentUser}_${hojeISO}`);

  try {
    const docSnap = await getDoc(enviosRef);
    
    // A L√ìGICA PRINCIPAL:
    // Se o documento existe, voc√™ J√Å ENVIOU as moedas hoje. Ent√£o N√ÉO mostra o popup.
    if (docSnap.exists()) {
      console.log("‚úÖ [Envio Moedas] Tarefa j√° conclu√≠da hoje. Popup n√£o ser√° exibido.");
      return;
    }

    const colegasDeEquipe = todosMembros.filter(m => m.equipe === userTeam && m.nome !== currentUser);
    if (colegasDeEquipe.length === 0) {
      return; // Sem colegas, sem popup
    }
    
    const listaContainer = document.getElementById('envio-moedas-lista-popup');
    if (listaContainer) {
        listaContainer.innerHTML = '';
        
        colegasDeEquipe.forEach(colega => {
          const itemEl = document.createElement('div');
          itemEl.className = 'envio-membro-item';
          itemEl.innerHTML = `
            <input type="checkbox" id="popup-enviar-para-${colega.nome}" value="${colega.nome}" checked>
            <label for="popup-enviar-para-${colega.nome}">${colega.nome}</label>
          `;
          listaContainer.appendChild(itemEl);
        });

        /// --- L√ìGICA DE FILA SEGURA v2 (Integrada e Otimizada) ---
        const tentarAbrirPopupSeguro = () => {
            // Verifica se o Or√°culo (ou qualquer card) est√° vis√≠vel
            const overlayOraculo = document.getElementById('custom-card-popup');
            const estaVisivel = overlayOraculo && overlayOraculo.classList.contains('show');
            
            // ALTERA√á√ÉO 1: Removemos a verifica√ß√£o 'temFila'. 
            // Agora ele s√≥ espera se tiver um popup visualmente ABERTO na tela.
            // Se houver fila escondida, ele vai passar na frente assim que o atual fechar.

            if (estaVisivel) {
                // ALTERA√á√ÉO 2: Reduzido de 1000ms para 100ms para checagem instant√¢nea
                setTimeout(tentarAbrirPopupSeguro, 5000); 
                return;
            }

            console.log("‚úÖ [Envio Moedas] Abrindo popup priorit√°rio...");
            
            // A LINHA "isCardPopupShowing = true;" FOI REMOVIDA DAQUI.
            // Isso permite que o processador da fila detecte o popup aberto 
            // e entre em modo de espera (retry) em vez de travar completamente.
            
            openModal('popup-envio-diario-moedas');
        };

        // Inicia a tentativa de abrir
        tentarAbrirPopupSeguro();
        // --------------------------------
    }

  } catch (error) {
    console.error("Erro ao verificar popup de envio di√°rio:", error);
  }
}

/**
 * (Helper) Exibe um popup no login se houver poderes ativos afetando o usu√°rio.
 */
function exibirPopupPoderesAtivos() {
    if (statusPoderesAtivos.length === 0) return;

    let buffsHTML = '';    // Coisas boas (minha equipe)
    let debuffsHTML = '';  // Coisas ruins (contra minha equipe)
    let falhasHTML = '';   // Meus ataques que falharam

    statusPoderesAtivos.forEach(p => {
        const dataFim = p.expiraEm.toDate().toLocaleString('pt-BR', { day: '2-digit', month: '2-digit', hour: '2-digit', minute: '2-digit' });

        // 1. Efeitos QUE ME PROTEGEM (Minha equipe √© o alvo do amuleto)
        if (p.poderId === 'amuleto_protecao' && p.equipeAlvo === userTeam) {
            buffsHTML += `<li>üõ°Ô∏è <strong>Imunidade:</strong> Sua equipe est√° protegida contra maldi√ß√µes at√© ${dataFim}.</li>`;
        }
        
        // 2. Efeitos QUE ME ATACAM (Minha equipe √© o alvo de um debuff que FUNCIONOU)
        else if (p.equipeAlvo === userTeam && (p.poderId === 'praga_kriptonita' || p.poderId === 'runa_soft_block')) {
            // Formata o nome da equipe atacante (Vaga-lume ou Capitalizado)
            const nomeAtacante = p.usadoPor === 'vagalume' ? 'Vaga-lume' : p.usadoPor.charAt(0).toUpperCase() + p.usadoPor.slice(1);
            
            debuffsHTML += `<li>ü§¢ <strong>${p.nomePoder}:</strong> Sua equipe est√° sofrendo este efeito (usado pela Equipe ${nomeAtacante}) at√© ${dataFim}.</li>`;
        }

        // 2b. (NOVO) Efeitos QUE TENTARAM ME ATACAR MAS FALHARAM (Bloqueio)
        else if (p.equipeAlvo === userTeam && p.poderId === 'amuleto_falha') {
             // Formata o nome da equipe atacante
             const nomeAtacante = p.usadoPor === 'vagalume' ? 'Vaga-lume' : p.usadoPor.charAt(0).toUpperCase() + p.usadoPor.slice(1);
             
             // Adiciona na lista de 'buffs' (verde) pois foi uma defesa bem sucedida
             buffsHTML += `<li>üõ°Ô∏è <strong>Defesa Bem-Sucedida!</strong> Seu Amuleto bloqueou a maldi√ß√£o <strong>${p.nomePoder}</strong> vinda da Equipe ${nomeAtacante}.</li>`;
        }

        // 3. Efeitos QUE EU USEI (Minha equipe √© a usu√°ria)
        else if (p.usadoPor === userTeam) {
            
            // 3a. Minha equipe USOU um debuff (e deu certo)
        if (p.equipeAlvo !== userTeam && (p.poderId === 'praga_kriptonita' || p.poderId === 'runa_soft_block')) {
             // Formata o nome da equipe alvo
             const nomeAlvo = p.equipeAlvo === 'vagalume' ? 'Vaga-lume' : p.equipeAlvo.charAt(0).toUpperCase() + p.equipeAlvo.slice(1);

             buffsHTML += `<li>‚öîÔ∏è <strong>${p.nomePoder}:</strong> Sua equipe est√° afetando a Equipe ${nomeAlvo} at√© ${dataFim}.</li>`;
        }
            // 3b. Minha equipe USOU um poder que falhou (NOVO)
            else if (p.poderId === 'amuleto_falha') {
                // Formata o nome da equipe (Vaga-lume ou Capitalizado)
                const nomeAlvoFormatado = p.equipeAlvo === 'vagalume' ? 'Vaga-lume' : p.equipeAlvo.charAt(0).toUpperCase() + p.equipeAlvo.slice(1);
                
                falhasHTML += `<li>‚ùå <strong>Falha na Magia:</strong> A maldi√ß√£o <strong>${p.nomePoder}</strong> utilizada contra a <strong>Equipe ${nomeAlvoFormatado}</strong> falhou... A equipe estava protegida. <br></li>`;
            }
        }
    });

    if (buffsHTML === '' && debuffsHTML === '' && falhasHTML === '') return; // Nada relevante para este usu√°rio

    let mensagem = '';
    if (buffsHTML) {
        mensagem += '<h4 style="color: #2ecc71; margin-top: 0;">Efeitos Ativos (pela sua equipe):</h4><ul>' + buffsHTML + '</ul>';
    }
    if (debuffsHTML) {
        mensagem += '<h4 style="color: #e74c3c; margin-top: 15px;">Efeitos Ativos (contra a sua equipe):</h4><ul>' + debuffsHTML + '</ul>';
    }
    if (falhasHTML) {
        mensagem += '<h4 style="color: #f39c12; margin-top: 15px;">Registros de Falha:</h4><ul>' + falhasHTML + '</ul>';
    }
    
    // Mostra o card popup com um pequeno atraso
    // Passamos 'null' no terceiro argumento para N√ÉO ter confete
    // ID √öNICO ADICIONADO: 'status_poderes_ativos'
    setTimeout(() => {
        mostrarCardPopup("‚ú® Status das Magias Ativas", mensagem, null, "Grupo √âpicos", "status_poderes_ativos");
    }, 4000); // Aumentado para 4s para dar tempo de ler o Or√°culo
}

// =======================================================
// ===== NOVA FUN√á√ÉO: ABRE O MODAL DE NOTIFICA√á√ïES SE NECESS√ÅRIO (PASSO 2) =====
// =======================================================
/**
 * (NOVA) Abre o modal de notifica√ß√µes se houver
 * notifica√ß√µes "comuns" (men√ß√µes, rea√ß√µes) n√£o lidas,
 * ap√≥s os popups de recompensa terem tido a chance de aparecer.
 */
async function abrirModalNotificacoesSeNecessario() {
  // 1. Aguarda um curto per√≠odo para dar tempo aos popups especiais (Pix, Medalhas)
  // de aparecerem primeiro.
  await new Promise(resolve => setTimeout(resolve, 3500)); // 3.5 segundos de atraso

  // 2. Verifica se algum modal de alta prioridade (Pix, Medalha, etc.) est√° aberto.
  // Se estiver, a fun√ß√£o n√£o far√° nada para n√£o sobrepor.
  
  // ATUALIZADO: Lista completa de todos os popups autom√°ticos que podem aparecer no login
  const modalAberto = document.querySelector(
      '#pix-recebido-popup.show, ' +
      '#medalha-ganha-popup.show, ' +
      '#recompensa-recebida-popup.show, ' +
      '#custom-card-popup.show, ' + // Cobre a Mensagem do Dia, avisos de folga, etc.
      '#popup-envio-diario-moedas.show, ' +
      '#popup-resultado-loteria.show, ' + // Cobre a quarta-feira
      '#recompensa-lideres-modal.show, ' +
      '#recompensa-equipe-modal.show, ' +
      '#fim-temporada-popup.show'
  );
  
  if (modalAberto) {
    console.log("Modal de recompensa/pix/aviso est√° aberto. O modal de notifica√ß√µes n√£o ser√° aberto agora.");
    return;
  }
  
  // 3. Busca por notifica√ß√µes n√£o lidas que N√ÉO S√ÉO de popups especiais.
  if (!currentUser) return;

  try {
    const q = query(
      collection(db, "notificacoes"),
      where("destinatarioId", "==", currentUser),
      where("lida", "==", false),
      // 4. A L√ìGICA PRINCIPAL: Filtra os tipos que t√™m seus pr√≥prios popups.
      // N√≥s S√ì queremos abrir o modal para rea√ß√µes, men√ß√µes, etc.
      where("tipo", "not-in", [
        "moedas", 
        "recompensa_lider", 
        "recompensa_membro", 
        "medalha-presente"
      ])
    );

    const querySnapshot = await getDocs(q);

    // 5. Se encontrar qualquer notifica√ß√£o comum n√£o lida, abre o modal.
    if (!querySnapshot.empty) {
      console.log(`Encontradas ${querySnapshot.size} notifica√ß√µes comuns. Abrindo o modal principal.`);
      
      // Chama as duas fun√ß√µes que o bot√£o de "Notifica√ß√µes" chama
      marcarNotificacoesComoLidas(); // Marca como lidas (para apagar o brilho do √≠cone)
      openModal('notificacoes-modal'); // Abre o modal
    } else {
      console.log("Nenhuma notifica√ß√£o comum n√£o lida para exibir no modal.");
    }

  } catch (error) {
    console.error("Erro ao verificar notifica√ß√µes para abertura autom√°tica do modal:", error);
  }
}

// ATUALIZADA: Verifica e abre o modal, deixando o listener preencher os dados
async function verificarNotificacoesRestantes() {
  // 1. Verifica se algum modal de alta prioridade est√° aberto.
  const modalAberto = document.querySelector('#pix-recebido-popup.show, #medalha-ganha-popup.show, #recompensa-recebida-popup.show, #custom-card-popup.show, #popup-envio-diario-moedas.show, #recompensa-lideres-modal.show, #recompensa-equipe-modal.show, #fim-temporada-popup.show');
  if (modalAberto) {
    return; // Aguarda o fechamento do modal especial.
  }
  
  if (!currentUser) {
    return;
  }

  try {
    // Lista de tipos de notifica√ß√£o que t√™m seus pr√≥prios popups (n√£o queremos abrir o modal geral para eles)
    const tiposExcluidos = [
        "moedas", 
        "recompensa_lider", 
        "recompensa_membro", 
        "medalha-presente"
    ];
      
    const q = query(
      collection(db, "notificacoes"),
      where("destinatarioId", "==", currentUser),
      where("lida", "==", false),
      where("tipo", "not-in", tiposExcluidos) // O filtro principal
    );

    const querySnapshot = await getDocs(q);
    
    // 2. Se encontrar notifica√ß√µes "comuns", abre o modal principal.
    if (!querySnapshot.empty) {
      // CORRE√á√ÉO: Removemos a inje√ß√£o manual de HTML "Carregando..."
      // O listener 'configurarNotificacoesTempoReal' j√° vai preencher a lista automaticamente.
      openModal('notificacoes-modal');
    }

  } catch (error) {
    console.error("Erro CR√çTICO ao verificar notifica√ß√µes restantes:", error);
  }
}

// COLE ESTA NOVA FUN√á√ÉO
async function acaoNormalFecharNotificacoes() {
    const btn = document.getElementById('notificacoes-fechar-btn');
    const textoOriginal = btn ? btn.textContent : 'Fechar';
    
    // 1. Feedback Visual e Trava
    if (btn) {
        btn.textContent = "Limpando...";
        btn.disabled = true;
        btn.style.opacity = "0.7";
    }

    console.log("A√ß√£o normal: Iniciando limpeza de notifica√ß√µes...");

    try {
        // 2. Apaga (para a lista ficar limpa na pr√≥xima vez e no banco)
        // Chamamos apagar PRIMEIRO para garantir a limpeza dos dados
        await apagarTodasAsNotificacoes();
        
        // 3. Marca como lido visualmente (para o contador sumir caso sobre algo em cache)
        await marcarNotificacoesComoLidas();

        console.log("Limpeza conclu√≠da. Fechando modal.");
        
        // 4. Fecha o modal
        closeModal('notificacoes-modal');

    } catch (error) {
        console.error("Erro na a√ß√£o normal de fechar notifica√ß√µes:", error);
        // Mesmo se falhar, fecha o modal para n√£o prender o usu√°rio
        closeModal('notificacoes-modal');
    } finally {
        // Restaura o bot√£o (caso o modal seja reaberto sem recarregar a p√°gina)
        if (btn) {
            btn.textContent = textoOriginal;
            btn.disabled = false;
            btn.style.opacity = "1";
        }
    }
}

// COLE ESTAS TR√äS NOVAS FUN√á√ïES

// Fun√ß√£o para salvar o status de aus√™ncia
async function toggleAusenciaMembro(nome, novoStatus) {
  try {
    const membroRef = doc(db, "membros", nome);
    
    let updates = {};
    
    if (novoStatus === 'ativo') {
        updates = { 
            deFerias: false,
            motivoAusencia: deleteField() // Remove o campo se estiver ativo
        };
    } else {
        updates = { 
            deFerias: true, // Mant√©m true para travar a checkbox e c√°lculos
            motivoAusencia: novoStatus // 'ferias' ou 'saude'
        };
    }

    await updateDoc(membroRef, updates);
    
    await refreshAppUI(); // Atualiza a tela

    let msg = novoStatus === 'ativo' ? "est√° ativo novamente." : 
              novoStatus === 'saude' ? "est√° em recupera√ß√£o de sa√∫de." : "entrou de f√©rias.";
              
    mostrarPopup("‚úÖ Atualizado", `${nome} ${msg}`, 3000);
  } catch (error) {
    console.error(`Erro ao atualizar status para ${nome}:`, error);
    mostrarPopup("‚ùå Erro", "N√£o foi poss√≠vel salvar a altera√ß√£o.", 4000);
  }
}

// Fun√ß√£o para popular o painel de aus√™ncias com op√ß√µes
function popularPainelAusencia() {
  const listaContainer = document.getElementById('ferias-lista-membros');
  listaContainer.innerHTML = ''; 

  const membrosOrdenados = [...todosMembros].sort((a, b) => a.nome.localeCompare(b.nome));

  membrosOrdenados.forEach(membro => {
    if (membro.papel === 'lider') return;

    const itemEl = document.createElement('div');
    itemEl.className = 'ferias-item';
    // Ajusta o estilo para acomodar o Select
    itemEl.style.justifyContent = "space-between"; 

    // Determina o valor atual do select
    let valorAtual = 'ativo';
    if (membro.deFerias) {
        valorAtual = membro.motivoAusencia === 'saude' ? 'saude' : 'ferias';
    }

    itemEl.innerHTML = `
      <label for="status_${membro.nome}" style="font-weight: 500;">${membro.nome}</label>
      <select id="status_${membro.nome}" class="painel-input" style="width: 140px; padding: 5px;">
        <option value="ativo" ${valorAtual === 'ativo' ? 'selected' : ''}>‚úÖ Ativo</option>
        <option value="ferias" ${valorAtual === 'ferias' ? 'selected' : ''}>üå¥ F√©rias</option>
        <option value="saude" ${valorAtual === 'saude' ? 'selected' : ''}>üò∑ Sa√∫de</option>
      </select>
    `;

    // Evento de mudan√ßa
    itemEl.querySelector('select').addEventListener('change', (e) => {
      toggleAusenciaMembro(membro.nome, e.target.value);
    });

    listaContainer.appendChild(itemEl);
  });
}

// FIM DO BLOCO

// =============================================
// ===== NOVO SISTEMA DE RECOMPENSAS SEMANAIS ====
// =============================================

// SUBSTITUA A FUN√á√ÉO verificarPopupRecompensas PELA VERS√ÉO ABAIXO
async function verificarPopupRecompensas() {
  const hoje = getHoje();
  const diaSemana = hoje.getDay();

  const semana = getSemanaAtual();
  const popupStateRef = doc(db, "appState", `popupState_${semana.numero}_${semana.inicio.getFullYear()}`);

  try {
    const popupStateSnap = await getDoc(popupStateRef);
    const popupData = popupStateSnap.exists() ? popupStateSnap.data() : {};

    // L√≥gica para o L√çDER GERAL no Domingo (sem altera√ß√£o)
    if (userRole === 'lider' && diaSemana === 0) {
      const avaliacaoJaVista = popupData.liderGeralAvaliacaoVista || [];
      if (avaliacaoJaVista.includes(currentUser)) return; 

      setTimeout(abrirPopupAvaliacaoLideres, 2000);
    }

    // =======================================================
    // ===== IN√çCIO DA ALTERA√á√ÉO (DOMINGO OU SEGUNDA) =====
    // =======================================================
    // L√≥gica para L√çDERES DE EQUIPE no Domingo ou Segunda
    if (userRole === 'lider-equipe' && (diaSemana === 0 || diaSemana === 1)) {
      const recompensaJaVista = popupData.liderEquipeRecompensaVista || [];
      if (recompensaJaVista.includes(currentUser)) return; // Se j√° fez, n√£o mostra o popup

      // Busca a avalia√ß√£o que o L√≠der Geral fez (no S√°bado ou Domingo)
      const semanaPassada = getSemanaAtual(new Date(hoje.getTime() - 24 * 60 * 60 * 1000));
      const recompensaRef = doc(db, "recompensasLideres", `semana_${semanaPassada.numero}_${semanaPassada.inicio.getFullYear()}`);
      
      const docSnap = await getDoc(recompensaRef);
      // Se a avalia√ß√£o existe E o l√≠der atual foi aprovado
      if (docSnap.exists() && docSnap.data().aprovados.includes(currentUser)) {
        setTimeout(abrirPopupRecompensaEquipe, 2000);
      }
    }
    // =======================================================
    // ===== FIM DA ALTERA√á√ÉO =====
    // =======================================================

  } catch (e) {
    console.error("Erro ao verificar popups de recompensa:", e);
  }
}

// COLE ESTAS DUAS NOVAS FUN√á√ïES NO SEU SCRIPT

function abrirPopupAvaliacaoLideres() {
  const lideresEquipe = todosMembros.filter(m => m.papel === 'lider-equipe');
  if (lideresEquipe.length === 0) {
    mostrarPopup("‚ÑπÔ∏è Informa√ß√£o", "N√£o h√° l√≠deres de equipe para avaliar.", 4000);
    return;
  }

  const listaContainer = document.getElementById('recompensa-lideres-lista');
  listaContainer.innerHTML = '';

  lideresEquipe.forEach(lider => {
    const itemEl = document.createElement('div');
    itemEl.className = 'envio-membro-item';
    itemEl.innerHTML = `
      <input type="checkbox" id="recompensa-lider-${lider.nome}" value="${lider.nome}" checked>
      <label for="recompensa-lider-${lider.nome}">${lider.nome} (${lider.equipe})</label>
    `;
    listaContainer.appendChild(itemEl);
  });
  
  openModal('recompensa-lideres-modal');
}

function abrirPopupRecompensaEquipe() {
  const membrosDaEquipe = todosMembros.filter(m => m.equipe === userTeam && m.papel === 'membro');
  if (membrosDaEquipe.length === 0) {
    mostrarPopup("‚ÑπÔ∏è Informa√ß√£o", "Sua equipe n√£o possui membros para recompensar.", 4000);
    return;
  }

  const listaContainer = document.getElementById('recompensa-equipe-lista');
  listaContainer.innerHTML = '';
  
  membrosDaEquipe.forEach(membro => {
    const itemEl = document.createElement('div');
    itemEl.className = 'envio-membro-item';
    itemEl.innerHTML = `
      <input type="checkbox" id="recompensa-membro-${membro.nome}" value="${membro.nome}">
      <label for="recompensa-membro-${membro.nome}">${membro.nome}</label>
    `;
    listaContainer.appendChild(itemEl);
  });

  openModal('recompensa-equipe-modal');
}

async function executarEnvioRecompensaLideres() {
  const checkboxes = document.querySelectorAll('#recompensa-lideres-lista input[type="checkbox"]');
  const lideresAprovados = Array.from(checkboxes).filter(cb => cb.checked).map(cb => cb.value);

  // --- L√ìGICA DE PAGAMENTO IMEDIATO INSERIDA AQUI ---
  const todosLideresEquipe = todosMembros.filter(m => m.papel === 'lider-equipe').map(m => m.nome);
  const lideresReprovados = todosLideresEquipe.filter(l => !lideresAprovados.includes(l));
  
  const semana = getSemanaAtual();
  const docId = `semana_${semana.numero}_${semana.inicio.getFullYear()}`;
  const recompensaRef = doc(db, "recompensasLideres", docId);
  const popupStateRef = doc(db, "appState", `popupState_${semana.numero}_${semana.inicio.getFullYear()}`);
  const timestampAcao = new Date();

  const batch = writeBatch(db);
  
  const valorRecompensaLiderAprovado = 100000; // Valor para aprovados
  const valorRecompensaLiderReprovado = 10000; // Valor para reprovados

  // 1. Premia os aprovados
  lideresAprovados.forEach(nomeLider => {
    const membroRef = doc(db, "membros", nomeLider);
    batch.update(membroRef, { moedas: increment(valorRecompensaLiderAprovado) });

    const notificacaoRef = doc(collection(db, "notificacoes"));
    
    // ===== IN√çCIO DA ALTERA√á√ÉO =====
    batch.set(notificacaoRef, {
      destinatarioId: nomeLider,
      remetenteNome: "Sistema", // O L√≠der Geral envia como "Sistema"
      tipo: 'recompensa_lider', // NOVO TIPO
      conteudo: 'üëë',
      acao: `voc√™ recebeu <strong>${valorRecompensaLiderAprovado.toLocaleString('pt-BR')} üí∞ moedas</strong> em raz√£o da sua √≥tima lideran√ßa nesta semana. Muito obrigado pelo apoio!`,
      lida: false,
      timestamp: timestampAcao,
      valor: valorRecompensaLiderAprovado, // NOVO CAMPO
      popupVisto: false,                // NOVO CAMPO
      agradecimentoEnviado: false     // NOVO CAMPO
    });
    // ===== FIM DA ALTERA√á√ÉO =====
  });

  // 2. "Premia" os reprovados
  lideresReprovados.forEach(nomeLider => {
    const membroRef = doc(db, "membros", nomeLider);
    batch.update(membroRef, { moedas: increment(valorRecompensaLiderReprovado) });

    const notificacaoRef = doc(collection(db, "notificacoes"));
    // (A notifica√ß√£o de reprovado n√£o precisa de agradecimento, ent√£o permanece igual)
    batch.set(notificacaoRef, {
      destinatarioId: nomeLider,
      remetenteNome: "Sistema",
      tipo: 'aviso',
      conteudo: '‚ö†Ô∏è',
      acao: `sua lideran√ßa deixou a desejar nesta semana. Por isso, voc√™ recebeu <strong>${valorRecompensaLiderReprovado.toLocaleString('pt-BR')} üí∞ moedas</strong> e n√£o ter√° acesso ao painel de recompensas da equipe.`,
      lida: false,
      timestamp: timestampAcao
    });
  });

  // 3. Salva a avalia√ß√£o e marca como PROCESSADO (para a rotina de meia-noite ignorar)
  batch.set(recompensaRef, {
    aprovados: lideresAprovados,
    avaliadoEm: timestampAcao,
    processado: true // <<< MARCA COMO PROCESSADO IMEDIATAMENTE
  });
  
  // 4. Cria a trava no Firestore para o L√≠der Geral
  batch.set(popupStateRef, {
    liderGeralAvaliacaoVista: arrayUnion(currentUser)
  }, { merge: true });

  try {
    // 5. Executa todas as a√ß√µes
    await batch.commit();

    closeModal('recompensa-lideres-modal');
    mostrarPopup("‚úÖ Pagamento Realizado!", "A avalia√ß√£o foi salva e os pagamentos aos l√≠deres foram processados.", 5000);
  
  } catch (error) {
    console.error("Erro ao salvar avalia√ß√£o e pagar l√≠deres:", error);
    mostrarPopup("‚ùå Erro", "N√£o foi poss√≠vel processar os pagamentos.", 4000);
  }
}

async function executarEnvioRecompensaEquipe() {
  const checkboxes = document.querySelectorAll('#recompensa-equipe-lista input[type="checkbox"]:checked');
  if (checkboxes.length === 0) {
    mostrarPopup("ü§î Aten√ß√£o", "Voc√™ precisa selecionar pelo menos um membro para recompensar.", 4000);
    return;
  }

  // Trava para evitar clique duplo
  const btn = document.getElementById('enviar-recompensa-equipe-btn');
  btn.disabled = true;
  btn.textContent = 'Enviando...';

  const membrosSelecionados = Array.from(checkboxes).map(cb => cb.value);
  const batch = writeBatch(db);
  const timestamp = new Date();
  const valorRecompensa = 5000; // Valor de 5.000 moedas

  membrosSelecionados.forEach(nomeMembro => {
    const membroRef = doc(db, "membros", nomeMembro);
    batch.update(membroRef, { moedas: increment(valorRecompensa) });

    const notificacaoRef = doc(collection(db, "notificacoes"));
    
    // ===== IN√çCIO DA ALTERA√á√ÉO =====
    batch.set(notificacaoRef, {
      destinatarioId: nomeMembro,
      remetenteNome: currentUser, // O l√≠der da equipe
      tipo: 'recompensa_membro', // NOVO TIPO
      conteudo: 'üèÜ',
      acao: `reconheceu seu esfor√ßo e dedica√ß√£o nesta semana e te enviou <strong>${valorRecompensa.toLocaleString('pt-BR')} üí∞ moedas</strong> como forma de agradecimento e incentivo, parab√©ns!`,
      lida: false,
      timestamp: timestamp,
      valor: valorRecompensa, // NOVO CAMPO
      popupVisto: false,      // NOVO CAMPO
      agradecimentoEnviado: false // NOVO CAMPO
    });
    // ===== FIM DA ALTERA√á√ÉO =====
  });

  // Adiciona a trava para n√£o mostrar o popup novamente nesta semana
  const semana = getSemanaAtual();
  const popupStateRef = doc(db, "appState", `popupState_${semana.numero}_${semana.inicio.getFullYear()}`);
  batch.set(popupStateRef, {
    liderEquipeRecompensaVista: arrayUnion(currentUser) // Trava para o l√≠der atual
  }, { merge: true });

  try {
    await batch.commit();
    closeModal('recompensa-equipe-modal');
    mostrarPopup("‚úÖ Sucesso!", `${membrosSelecionados.length} membro(s) foram recompensados com 5.000 moedas!`, 5000);
  } catch (error) {
    console.error("Erro ao enviar recompensa da equipe:", error);
    mostrarPopup("‚ùå Erro", "N√£o foi poss√≠vel enviar as moedas.", 4000);
  } finally {
    btn.disabled = false;
    btn.textContent = 'Enviar Recompensas';
  }
}

// Fun√ß√£o que roda no domingo para pagar os l√≠deres
async function processarRecompensasLideres() {
  console.log("Processando recompensas de lideran√ßa...");
  const hoje = getHoje();
  // Pega a avalia√ß√£o feita no s√°bado (ontem)
  const semana = getSemanaAtual(new Date(hoje.getTime() - 24 * 60 * 60 * 1000));
  const docId = `semana_${semana.numero}_${semana.inicio.getFullYear()}`;
  const recompensaRef = doc(db, "recompensasLideres", docId);
  
  try {
    const docSnap = await getDoc(recompensaRef);
    if (!docSnap.exists() || docSnap.data().processado) {
      console.log("Recompensas de l√≠deres n√£o encontradas ou j√° processadas para esta semana.");
      return;
    }

    const aprovados = docSnap.data().aprovados || [];
    const todosLideresEquipe = todosMembros.filter(m => m.papel === 'lider-equipe').map(m => m.nome);
    const reprovados = todosLideresEquipe.filter(l => !aprovados.includes(l));
    
    const batch = writeBatch(db);

    // Premia os aprovados
    aprovados.forEach(nomeLider => {
      const membroRef = doc(db, "membros", nomeLider);
      batch.update(membroRef, { moedas: increment(100000) });

      const notificacaoRef = doc(collection(db, "notificacoes"));
      batch.set(notificacaoRef, {
        destinatarioId: nomeLider,
        remetenteNome: "Sistema",
        tipo: 'moedas',
        conteudo: 'üëë',
        // --- VALOR ALTERADO NA MENSAGEM ABAIXO ---
        acao: `voc√™ recebeu <strong>100.000 üí∞ moedas</strong> em raz√£o da sua √≥tima lideran√ßa nesta semana. Muito obrigado pelo apoio!`,
        lida: false,
        timestamp: new Date()
      });
    });

    // "Premia" os reprovados
    reprovados.forEach(nomeLider => {
      const membroRef = doc(db, "membros", nomeLider);
      batch.update(membroRef, { moedas: increment(10000) });

      const notificacaoRef = doc(collection(db, "notificacoes"));
      batch.set(notificacaoRef, {
        destinatarioId: nomeLider,
        remetenteNome: "Sistema",
        tipo: 'aviso',
        conteudo: '‚ö†Ô∏è',
        acao: `sua lideran√ßa deixou a desejar nesta semana. Por isso, voc√™ recebeu <strong>10.000 üí∞ moedas</strong> (metade da remunera√ß√£o) e n√£o ter√° acesso ao painel de recompensas da equipe.`,
        lida: false,
        timestamp: new Date()
      });
    });
    
    // Marca como processado para n√£o rodar de novo
    batch.update(recompensaRef, { processado: true });
    
    await batch.commit();
    console.log("Recompensas de lideran√ßa processadas com sucesso.");

  } catch (error) {
    console.error("Erro cr√≠tico ao processar recompensas de l√≠deres:", error);
  }
}

// =============================================
// ===== NOVAS FUN√á√ïES PARA INTERA√á√ÉO DE DESENHO =====
// =============================================

// FEATURE 1: Abre o modal com a lista de autores do desenho
window.abrirModalAutores = async function(equipeId) {
  const modalTitulo = document.getElementById('autores-modal-titulo');
  const listaContainer = document.getElementById('autores-lista-container');
  
  modalTitulo.textContent = `Autores do Desenho`;
  listaContainer.innerHTML = '<div class="ociosos-placeholder">Carregando artistas...</div>';
  openModal('autores-desenho-modal');

  try {
    const desenhosRef = collection(db, `desenhos_${equipeId}`);
    const q = query(desenhosRef);
    const snapshot = await getDocs(q);

    if (snapshot.empty) {
      listaContainer.innerHTML = '<div class="ociosos-placeholder">Ningu√©m desenhou aqui ainda.</div>';
      return;
    }

    const autores = new Set();
    snapshot.forEach(doc => {
      if (doc.data().desenhadoPor) {
        autores.add(doc.data().desenhadoPor);
      }
    });

    if (autores.size === 0) {
      listaContainer.innerHTML = '<div class="ociosos-placeholder">Nenhum autor identificado.</div>';
      return;
    }

    listaContainer.innerHTML = '';
    autores.forEach(nome => {
      const itemEl = document.createElement('div');
      itemEl.className = 'autores-item';
      itemEl.textContent = nome;
      listaContainer.appendChild(itemEl);
    });

  } catch (error) {
    console.error("Erro ao buscar autores do desenho:", error);
    listaContainer.innerHTML = '<div class="ociosos-placeholder">Erro ao carregar a lista.</div>';
  }
}

// ATUALIZADA (v2): Corrige o seletor do contador e usa os novos IDs do HTML
function carregarEExibirAvaliacoesDesenho() {
  const semana = getSemanaAtual();
  const docId = `semana_${semana.numero}_${semana.inicio.getFullYear()}`;
  const advantageRef = doc(db, "vantagemSemanal", docId);

  onSnapshot(advantageRef, (docSnap) => {
    const dados = docSnap.exists() ? docSnap.data().avaliacoesDesenho || {} : {};
    
    ['abelha', 'joaninha', 'vagalume'].forEach(equipe => {
      const avaliacoesEquipe = dados[equipe] || { likes: [], dislikes: [] };
      const likes = avaliacoesEquipe.likes || [];
      const dislikes = avaliacoesEquipe.dislikes || [];

      // --- IN√çCIO DA CORRE√á√ÉO ---
      // Seleciona o container pelo novo ID e encontra o contador DENTRO dele
      const likeContainer = document.getElementById(`like-container-${equipe}`);
      if (likeContainer) {
          const likeCountEl = likeContainer.querySelector('.like-count');
          likeCountEl.textContent = likes.length;

          const userLiked = likes.includes(currentUser);
          likeContainer.classList.toggle('ativo', userLiked);
          likeContainer.classList.toggle('like-ativo', userLiked);
      }

      const dislikeContainer = document.getElementById(`dislike-container-${equipe}`);
      if (dislikeContainer) {
          const dislikeCountEl = dislikeContainer.querySelector('.dislike-count');
          dislikeCountEl.textContent = dislikes.length;
          
          const userDisliked = dislikes.includes(currentUser);
          dislikeContainer.classList.toggle('ativo', userDisliked);
          dislikeContainer.classList.toggle('dislike-ativo', userDisliked);
      }
      // --- FIM DA CORRE√á√ÉO ---
    });
  });
}

// ATUALIZADA (v2): Usa os novos IDs para ser mais robusta e consistente
async function atualizarAvaliacaoOtimista(equipeId, tipoAvaliacao) {
    if (!currentUser || equipeId === userTeam) return;

    // --- IN√çCIO DA CORRE√á√ÉO ---
    const likeContainer = document.getElementById(`like-container-${equipeId}`);
    const dislikeContainer = document.getElementById(`dislike-container-${equipeId}`);

    if (!likeContainer || !dislikeContainer) return; // Sai se os elementos n√£o forem encontrados

    const likeCountEl = likeContainer.querySelector('.like-count');
    const dislikeCountEl = dislikeContainer.querySelector('.dislike-count');
    // --- FIM DA CORRE√á√ÉO ---

    const eraLike = likeContainer.classList.contains('ativo');
    const eraDislike = dislikeContainer.classList.contains('ativo');

    likeContainer.classList.remove('ativo', 'like-ativo');
    dislikeContainer.classList.remove('ativo', 'dislike-ativo');

    if (eraLike) likeCountEl.textContent = Math.max(0, parseInt(likeCountEl.textContent) - 1);
    if (eraDislike) dislikeCountEl.textContent = Math.max(0, parseInt(dislikeCountEl.textContent) - 1);

    if (tipoAvaliacao === 'like' && !eraLike) {
        likeContainer.classList.add('ativo', 'like-ativo');
        likeCountEl.textContent = parseInt(likeCountEl.textContent) + 1;
    } else if (tipoAvaliacao === 'dislike' && !eraDislike) {
        dislikeContainer.classList.add('ativo', 'dislike-ativo');
        dislikeCountEl.textContent = parseInt(dislikeCountEl.textContent) + 1;
    }
}

// NOVA FUN√á√ÉO: Abre o modal com a lista de membros que avaliaram
window.abrirModalAvaliadores = async function(equipeId, tipoAvaliacao) {
  const modalTitulo = document.getElementById('avaliadores-modal-titulo');
  const listaContainer = document.getElementById('avaliadores-lista-container');
  const nomeEquipeCapitalizado = equipeId.charAt(0).toUpperCase() + equipeId.slice(1);

  if (tipoAvaliacao === 'likes') {
    modalTitulo.textContent = `Curtiram o Desenho`;
  } else {
    modalTitulo.textContent = `N√£o Curtiram o Desenho`;
  }
  
  listaContainer.innerHTML = '<div class="ociosos-placeholder">Carregando...</div>';
  openModal('avaliadores-desenho-modal');

  try {
    const semana = getSemanaAtual();
    const docId = `semana_${semana.numero}_${semana.inicio.getFullYear()}`;
    const advantageRef = doc(db, "vantagemSemanal", docId);
    const docSnap = await getDoc(advantageRef);

    const avaliacoes = docSnap.exists() ? docSnap.data().avaliacoesDesenho || {} : {};
    const avaliacoesEquipe = avaliacoes[equipeId] || {};
    const listaNomes = avaliacoesEquipe[tipoAvaliacao] || [];

    if (listaNomes.length === 0) {
      listaContainer.innerHTML = `<div class="ociosos-placeholder">Ningu√©m avaliou desta forma ainda.</div>`;
      return;
    }

    listaContainer.innerHTML = '';
    listaNomes.forEach(nome => {
      const itemEl = document.createElement('div');
      itemEl.className = 'autores-item';
      itemEl.textContent = nome;
      listaContainer.appendChild(itemEl);
    });

  } catch (error) {
    console.error("Erro ao buscar avaliadores do desenho:", error);
    listaContainer.innerHTML = '<div class="ociosos-placeholder">Erro ao carregar a lista.</div>';
  }
}

// Substitua a fun√ß√£o antiga por esta vers√£o completa
window.avaliarDesenho = async function(equipeId, tipoAvaliacao) {
  if (equipeId === userTeam) {
    mostrarPopup("üö´ A√ß√£o Inv√°lida", "Voc√™ n√£o pode avaliar o desenho da sua pr√≥pria equipe.", 4000);
    return;
  }

  atualizarAvaliacaoOtimista(equipeId, tipoAvaliacao);
  
  const semana = getSemanaAtual();
  const docId = `semana_${semana.numero}_${semana.inicio.getFullYear()}`;
  const advantageRef = doc(db, "vantagemSemanal", docId);

  try {
    const resultado = await runTransaction(db, async (transaction) => {
      const docSnap = await transaction.get(advantageRef);
      const dados = docSnap.exists() ? docSnap.data() : {};
      
      const avaliacoes = dados.avaliacoesDesenho || {};
      if (!avaliacoes[equipeId]) {
        avaliacoes[equipeId] = { likes: [], dislikes: [] };
      }
      
      const feedEvents = dados.avaliacaoFeedEvents || {};
      if (!feedEvents[equipeId]) {
        feedEvents[equipeId] = {};
      }
      const eventKey = `${currentUser}_${tipoAvaliacao}`;

      const likes = avaliacoes[equipeId].likes || [];
      const dislikes = avaliacoes[equipeId].dislikes || [];
      
      const userIndexLike = likes.indexOf(currentUser);
      const userIndexDislike = dislikes.indexOf(currentUser);
      
      let acao = 'removeu a avalia√ß√£o';

      if (userIndexLike > -1) {
        const oldEventKey = `${currentUser}_like`;
        if (feedEvents[equipeId][oldEventKey]) {
          transaction.delete(doc(db, "resumoSemanalFeed", feedEvents[equipeId][oldEventKey]));
          delete feedEvents[equipeId][oldEventKey];
        }
        likes.splice(userIndexLike, 1);
      }
      if (userIndexDislike > -1) {
        const oldEventKey = `${currentUser}_dislike`;
        if (feedEvents[equipeId][oldEventKey]) {
          transaction.delete(doc(db, "resumoSemanalFeed", feedEvents[equipeId][oldEventKey]));
          delete feedEvents[equipeId][oldEventKey];
        }
        dislikes.splice(userIndexDislike, 1);
      }
      
      if (tipoAvaliacao === 'like' && userIndexLike === -1) {
        likes.push(currentUser);
        acao = 'avaliou com üëç';
      } else if (tipoAvaliacao === 'dislike' && userIndexDislike === -1) {
        dislikes.push(currentUser);
        acao = 'avaliou com üëé';
      }
      
      transaction.set(advantageRef, { 
        avaliacoesDesenho: avaliacoes,
        avaliacaoFeedEvents: feedEvents 
      }, { merge: true });
      
      return acao;
    });
    
    // Cria√ß√£o do evento no feed (l√≥gica original mantida)
    if (resultado !== 'removeu a avalia√ß√£o') {
      // CORRE√á√ÉO: Formata√ß√£o correta para Vaga-lume
      const nomeEquipeCapitalizado = equipeId === 'vagalume' ? 'Vaga-lume' : equipeId.charAt(0).toUpperCase() + equipeId.slice(1);
      
      const textoFeed = `<strong>${currentUser}</strong> ${resultado} o desenho da equipe <strong>${nomeEquipeCapitalizado}</strong>.`;
      
      const feedEventId = await adicionarEventoAoFeed('geral', 'üé® Nova Avalia√ß√£o de Desenho!', textoFeed);

      if (feedEventId) {
        const eventKey = `${currentUser}_${tipoAvaliacao}`;
        await updateDoc(advantageRef, {
          [`avaliacaoFeedEvents.${equipeId}.${eventKey}`]: feedEventId
        });
      }
    }

    // =======================================================
    // NOVO BLOCO: Enviar Notifica√ß√£o para os Autores
    // =======================================================
    // S√≥ executa se a avalia√ß√£o foi uma nova curtida
    if (resultado === 'avaliou com üëç') {
      const autores = new Set();
      try {
        // 1. Busca todos os tra√ßos do desenho para encontrar os autores
        const desenhosRef = collection(db, `desenhos_${equipeId}`);
        const q = query(desenhosRef);
        const snapshot = await getDocs(q);
        snapshot.forEach(doc => {
          if (doc.data().desenhadoPor) {
            autores.add(doc.data().desenhadoPor);
          }
        });

        // 2. Se encontrou autores, cria as notifica√ß√µes
        if (autores.size > 0) {
          const batch = writeBatch(db);
          // CORRE√á√ÉO: Formata√ß√£o correta para Vaga-lume
          const nomeEquipeCapitalizado = equipeId === 'vagalume' ? 'Vaga-lume' : equipeId.charAt(0).toUpperCase() + equipeId.slice(1);

          autores.forEach(autor => {
            // N√£o enviar notifica√ß√£o para si mesmo
            if (autor !== currentUser) {
              const notificacaoRef = doc(collection(db, "notificacoes"));
              batch.set(notificacaoRef, {
                destinatarioId: autor,
                remetenteNome: currentUser,
                tipo: 'desenho-like', // Um novo tipo para clareza
                conteudo: 'üé®‚ù§Ô∏è',      // Um emoji legal para a notifica√ß√£o
                acao: `curtiu o desenho da Equipe ${nomeEquipeCapitalizado}! "Sua arte foi apreciada! Continue colorindo nosso dia."`,
                lida: false,
                timestamp: new Date()
              });
            }
          });
          
          await batch.commit();
          console.log(`Notifica√ß√µes de curtida enviadas para ${autores.size} autor(es).`);
        }
      } catch (err) {
        console.error("N√£o foi poss√≠vel buscar os autores do desenho para notificar:", err);
      }
    }
    // =======================================================
    // FIM DO NOVO BLOCO
    // =======================================================

  } catch (error) {
    console.error("Erro ao avaliar desenho:", error);
    mostrarPopup("‚ùå Erro", "N√£o foi poss√≠vel registrar sua avalia√ß√£o. Por favor, recarregue a p√°gina.", 4000);
  }
}

// SUBSTITUA A FUN√á√ÉO ANTIGA POR ESTA VERS√ÉO CORRIGIDA

function configurarOuvintesDePreviewDesenho() {
  const semana = getSemanaAtual();
  const docId = `semana_${semana.numero}_${semana.inicio.getFullYear()}`;
  const previewsRef = doc(db, "vantagemSemanal", docId);

  onSnapshot(previewsRef, (docSnap) => {
    const dados = docSnap.exists() ? docSnap.data().desenhoPreviews || {} : {};
    
    ['abelha', 'joaninha', 'vagalume'].forEach(equipe => {
      const previewContainer = document.getElementById(`preview-container-${equipe}`);
      if (!previewContainer) return;

      const previewCanvas = previewContainer.querySelector('canvas');
      const previewCtx = previewCanvas.getContext('2d');
      
      // ===== IN√çCIO DA CORRE√á√ÉO DE QUALIDADE =====
      // Definimos a resolu√ß√£o real do canvas para ser igual ao seu tamanho na tela.
      // Isso impede que a imagem seja esticada e perca qualidade.
      const rect = previewCanvas.getBoundingClientRect();
      if (previewCanvas.width !== rect.width || previewCanvas.height !== rect.height) {
          previewCanvas.width = rect.width;
          previewCanvas.height = rect.height;
      }
      // ===== FIM DA CORRE√á√ÉO DE QUALIDADE =====
      
      const previewData = dados[equipe];

      // Limpa o canvas antes de qualquer a√ß√£o.
      previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);

      // Se um snapshot de imagem existir, n√≥s o desenhamos.
      if (previewData && previewData.imageDataURL) {
        const img = new Image();
        img.onload = function() {
          previewCtx.drawImage(img, 0, 0, previewCanvas.width, previewCanvas.height);
        };
        img.src = previewData.imageDataURL;
      }
      // Se n√£o houver imagem, o canvas permanece limpo.
    });
  });
}

// =============================================
// ===== FUN√á√ïES DA LOTERIA √âPICA =====
// =============================================

// Carrega os dados gerais da loteria
async function carregarDadosLoteria() {
  try {
    const docRef = doc(db, "loteria", "estadoAtual");
    const docSnap = await getDoc(docRef);

    if (docSnap.exists()) {
      dadosLoteria = docSnap.data();
      
      // Atualiza UI
      document.getElementById('loteria-valor-acumulado').textContent = dadosLoteria.premioAcumulado.toLocaleString('pt-BR');
      document.getElementById('loteria-edicao-info').textContent = `Edi√ß√£o ${String(dadosLoteria.edicao).padStart(4, '0')}/${dadosLoteria.ano}`;
      
      // Atualiza saldo do usu√°rio (pega do cache global)
      const membro = todosMembros.find(m => m.nome === currentUser);
      if (membro) {
        document.getElementById('loteria-saldo-usuario').textContent = (membro.moedas || 0).toLocaleString('pt-BR');
      }

      // Conta quantas apostas o usu√°rio j√° fez nesta edi√ß√£o
      const apostasRef = collection(db, "loteria", "estadoAtual", "apostasDaEdicao");
      // CORRE√á√ÉO: Adicionado filtro 'where("edicao", "==", dadosLoteria.edicao)'
      const q = query(apostasRef, where("membro", "==", currentUser), where("edicao", "==", dadosLoteria.edicao)); 
      const apostasSnap = await getDocs(q);
      minhasApostasEdicao = apostasSnap.size;

      renderizarHistoricoResultados(dadosLoteria.historico || []);
    } else {
      // Se n√£o existir, cria o estado inicial
      await setDoc(docRef, {
        premioAcumulado: 0,
        edicao: 1,
        ano: new Date().getFullYear(),
        totalApostas: 0,
        historico: []
      });
      carregarDadosLoteria(); // Recarrega
    }
  } catch (error) {
    console.error("Erro ao carregar loteria:", error);
  }
}

function renderizarHistoricoResultados(historico) {
  const container = document.getElementById('lista-ultimos-resultados');
  container.innerHTML = '';

  if (historico.length === 0) {
    container.innerHTML = '<div class="ociosos-placeholder">Nenhum sorteio realizado ainda.</div>';
    return;
  }

  // Mostra os √∫ltimos 4
  const ultimos = historico.slice(-4).reverse();

  ultimos.forEach(res => {
    const div = document.createElement('div');
    div.className = 'card-resultado-antigo';
    
    let bolasHtml = '';
    res.numeros.forEach(n => {
      bolasHtml += `<div class="bola-mini">${n}</div>`;
    });

    div.innerHTML = `
      <strong>Ed. ${String(res.edicao).padStart(4, '0')}</strong><br>
      <span style="font-size: 0.8em; color: #7f8c8d;">${new Date(res.data.seconds * 1000).toLocaleDateString('pt-BR')}</span>
      <div class="numeros-sorteados-mini">${bolasHtml}</div>
    `;
    container.appendChild(div);
  });
}

function abrirModalAposta() {
  if (!currentUser) return;
  
  // Atualiza o contador de apostas antes de abrir
  const avisoEl = document.getElementById('aposta-limite-aviso');
  avisoEl.textContent = `Voc√™ j√° fez ${minhasApostasEdicao} de ${LIMITE_APOSTAS_POR_EDICAO} apostas permitidas.`;

  if (minhasApostasEdicao >= LIMITE_APOSTAS_POR_EDICAO) {
      mostrarPopup("üö´ Limite Atingido", "Voc√™ j√° atingiu o limite de 6 apostas para este sorteio.", 4000);
      return;
  }

  numerosSelecionadosAposta = [];
  renderizarGridCartela();
  atualizarUISelecao();
  openModal('modal-fazer-aposta');
}

function renderizarGridCartela() {
  const grid = document.getElementById('cartela-grid');
  grid.innerHTML = '';

  for (let i = 1; i <= 30; i++) {
    const bola = document.createElement('div');
    bola.className = 'bola-loteria';
    bola.textContent = i;
    bola.onclick = () => toggleNumeroCartela(i, bola);
    grid.appendChild(bola);
  }
}

function toggleNumeroCartela(numero, elemento) {
  if (numerosSelecionadosAposta.includes(numero)) {
    // Desmarcar
    numerosSelecionadosAposta = numerosSelecionadosAposta.filter(n => n !== numero);
    elemento.classList.remove('selecionada');
  } else {
    // Marcar
    if (numerosSelecionadosAposta.length >= 4) {
      mostrarPopup("‚ö†Ô∏è Aten√ß√£o", "Voc√™ s√≥ pode escolher 4 n√∫meros.", 2000);
      return;
    }
    numerosSelecionadosAposta.push(numero);
    elemento.classList.add('selecionada');
  }
  atualizarUISelecao();
}

function atualizarUISelecao() {
  document.getElementById('aposta-contador-selecionados').textContent = `Selecionados: ${numerosSelecionadosAposta.length}/4`;
  // REMOVIDO: btn.disabled = ... (Agora o bot√£o fica sempre ativo para dar feedback)
  const btn = document.getElementById('btn-confirmar-aposta');
  if (numerosSelecionadosAposta.length === 4) {
      btn.style.opacity = "1";
      btn.style.cursor = "pointer";
  } else {
      btn.style.opacity = "0.6"; // Apenas visualmente mais fraco, mas clic√°vel
  }
}

async function confirmarAposta() {
    // NOVA VALIDA√á√ÉO DE QUANTIDADE
    if (numerosSelecionadosAposta.length !== 4) {
        mostrarPopup("‚ö†Ô∏è Aten√ß√£o", `Voc√™ selecionou ${numerosSelecionadosAposta.length} n√∫meros. √â necess√°rio escolher exatamente 4 n√∫meros para apostar!`, 4000);
        return;
    }

    if (minhasApostasEdicao >= LIMITE_APOSTAS_POR_EDICAO) {
        mostrarPopup("üö´ Limite", "Limite de apostas atingido.", 3000);
        return;
    }

    const btn = document.getElementById('btn-confirmar-aposta');
    btn.disabled = true;
    btn.textContent = "Processando...";

    try {
        const membroRef = doc(db, "membros", currentUser);
        const loteriaRef = doc(db, "loteria", "estadoAtual");
        const apostasCollection = collection(loteriaRef, "apostasDaEdicao");

        await runTransaction(db, async (transaction) => {
            const membroDoc = await transaction.get(membroRef);
            const loteriaDoc = await transaction.get(loteriaRef);

            if (!membroDoc.exists()) throw "Membro n√£o encontrado.";
            const saldo = membroDoc.data().moedas || 0;

            if (saldo < CUSTO_APOSTA) throw "Saldo insuficiente.";

            // Deduz do membro
            transaction.update(membroRef, { moedas: increment(-CUSTO_APOSTA) });

            // Adiciona ao pote (Valor integral da aposta)
            transaction.update(loteriaRef, { 
                premioAcumulado: increment(CUSTO_APOSTA), // Agora soma 100% do valor
                totalApostas: increment(1)
            });

            // Salva a aposta
            const novaApostaRef = doc(apostasCollection); // ID autom√°tico
            const dadosAposta = {
                membro: currentUser,
                equipe: userTeam,
                numeros: numerosSelecionadosAposta.sort((a, b) => a - b),
                data: new Date(),
                edicao: loteriaDoc.data().edicao,
                idVisual: novaApostaRef.id.substring(0, 8).toUpperCase()
            };
            transaction.set(novaApostaRef, dadosAposta);
            
            // Retorna dados para o comprovante
            return dadosAposta;
        }).then(async (dadosAposta) => {
		
		atualizarProgressoProtecao('apostar');
            
            // --- NOVO: L√≥gica de G√™nero e Evento no Feed ---
            const membroAtual = todosMembros.find(m => m.nome === currentUser);
            let pronome = 'Ele(a)';
            
            if (membroAtual) {
                if (membroAtual.genero === 'masculino') pronome = 'Ele';
                else if (membroAtual.genero === 'feminino') pronome = 'Ela';
            }

            await adicionarEventoAoFeed(
                'geral',
                'üçÄ Aposta Realizada!',
                `<strong>${currentUser}</strong> est√° se sentindo com sorte! ${pronome} acabou de fazer uma aposta na Loteria √âpica. Ser√° que vem pr√™mio a√≠?`,
                { nomeMembro: currentUser }
            );
            // -------------------------------------

            mostrarPopup("‚úÖ Sucesso!", "Aposta realizada com sucesso!", 4000);
            closeModal('modal-fazer-aposta');
            minhasApostasEdicao++;
            carregarDadosLoteria(); // Atualiza pr√™mio e saldo na tela
            exibirComprovanteLoteria(dadosAposta);
        });

    } catch (error) {
        console.error("Erro na aposta:", error);
        mostrarPopup("‚ùå Erro", typeof error === 'string' ? error : "Falha ao processar aposta.", 4000);
    } finally {
        btn.disabled = false;
        btn.textContent = "Confirmar Aposta";
    }
}

function exibirComprovanteLoteria(dados) {
    const container = document.getElementById('conteudo-comprovante-loteria');
    // ALTERA√á√ÉO: Aumentei o tamanho (width/height) e a fonte, removendo a classe bola-mini padr√£o para usar estilo inline maior
    const numerosFormatados = dados.numeros.map(n => 
        `<span class="bola-loteria" style="display:inline-flex; justify-content:center; align-items:center; width:40px; height:40px; margin:4px; font-size:1.1rem; cursor:default; background-color:#3498db; color:white; border:none;">${n}</span>`
    ).join('');
    
    // Calcula pr√≥xima quarta-feira
    const hoje = new Date();
    const diasAteQuarta = (3 - hoje.getDay() + 7) % 7 || 7; // Se hoje √© quarta, +7 dias
    const dataSorteio = new Date(hoje);
    dataSorteio.setDate(hoje.getDate() + diasAteQuarta);
    
    container.innerHTML = `
        <p><strong>Membro:</strong> ${dados.membro}</p>
        <p><strong>Equipe:</strong> ${dados.equipe}</p>
        <p><strong>Edi√ß√£o:</strong> ${String(dados.edicao).padStart(4, '0')}</p>
        <p><strong>Data Aposta:</strong> ${dados.data.toLocaleString('pt-BR')}</p>
        <div style="margin: 10px 0;">
            <strong style="display:block; margin-bottom: 5px;">N√∫meros Escolhidos:</strong>
            <div style="display:flex; justify-content:center; gap:5px;">${numerosFormatados}</div>
        </div>
        <p><strong>ID Aposta:</strong> <span style="font-family:monospace">${dados.idVisual}</span></p>
        <p style="margin-top:10px; font-size:0.85rem; color:#e67e22;">O sorteio ocorrer√° em: ${dataSorteio.toLocaleDateString('pt-BR')}</p>
    `;
    
    openModal('modal-comprovante-loteria');
    
    document.getElementById('btn-baixar-comprovante-loteria').onclick = () => {
        html2canvas(document.getElementById('comprovante-loteria'), { scale: 2 }).then(canvas => {
            const link = document.createElement('a');
            link.download = `aposta-epicos-${dados.idVisual}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
        });
    };
}

async function verHistoricoApostas() {
    const lista = document.getElementById('lista-apostadores-loteria');
    lista.innerHTML = '<div class="ociosos-placeholder">Carregando...</div>';
    openModal('modal-historico-apostas');

    try {
        const apostasRef = collection(db, "loteria", "estadoAtual", "apostasDaEdicao");
        const q = query(apostasRef, orderBy("data", "desc"));
        const snapshot = await getDocs(q);

        if (snapshot.empty) {
            lista.innerHTML = '<div class="ociosos-placeholder">Nenhuma aposta feita nesta edi√ß√£o ainda.</div>';
            return;
        }

        lista.innerHTML = '';
        snapshot.forEach(doc => {
            const aposta = doc.data();
            const item = document.createElement('div');
            item.className = 'ocioso-item aposta-card';
            item.style.flexDirection = 'column';
            item.style.alignItems = 'flex-start';
            
            // L√≥gica de m√°scara do ID
            const idVisual = aposta.idVisual || "??????";
            // Pega os primeiros 4 caracteres e adiciona asteriscos
            const idMascarado = idVisual.substring(0, 4) + "****";

            item.innerHTML = `
                <div style="display:flex; justify-content:space-between; width:100%;">
                    <strong>${aposta.membro}</strong>
                    <span style="font-size:0.8rem; color:#7f8c8d;">${aposta.data.toDate().toLocaleString('pt-BR')}</span>
                </div>
                <div style="font-size:0.85rem; margin-top:8px; color: #27ae60; font-weight:bold;">Aposta registrada com sucesso. ‚úÖ</div>
                <div style="font-size:0.85rem; margin-top:2px; color: #3498db;">ID: <span style="font-family:monospace;">${idMascarado}</span></div>
            `;
            lista.appendChild(item);
        });

    } catch (error) {
        console.error("Erro hist√≥rico:", error);
        lista.innerHTML = '<div class="ociosos-placeholder">Erro ao carregar.</div>';
    }
}

// NOVA FUN√á√ÉO: Ver as apostas do pr√≥prio usu√°rio
async function verMinhasApostas() {
    const lista = document.getElementById('lista-minhas-apostas');
    lista.innerHTML = '<div class="ociosos-placeholder">Carregando suas apostas...</div>';
    openModal('modal-minhas-apostas');

    try {
        const apostasRef = collection(db, "loteria", "estadoAtual", "apostasDaEdicao");
        // Busca apostas onde o membro √© o usu√°rio atual, ordenadas por data
        const q = query(apostasRef, where("membro", "==", currentUser), orderBy("data", "desc"));
        const snapshot = await getDocs(q);

        if (snapshot.empty) {
            lista.innerHTML = '<div class="ociosos-placeholder">Voc√™ ainda n√£o fez apostas nesta edi√ß√£o.</div>';
            return;
        }

        lista.innerHTML = '';
        snapshot.forEach(doc => {
            const aposta = doc.data();
            const item = document.createElement('div');
            item.className = 'ocioso-item aposta-card';
            item.style.flexDirection = 'column';
            item.style.alignItems = 'flex-start';
            item.style.gap = '8px';
            
            // Formata os n√∫meros como bolinhas
            const numerosHtml = aposta.numeros.map(n => 
                `<span style="display:inline-flex; justify-content:center; align-items:center; width:30px; height:30px; background:#3498db; color:white; border-radius:50%; font-weight:bold; font-size:0.9rem;">${n}</span>`
            ).join(' ');

            // Identifica se √© da edi√ß√£o atual ou passada
            const edicaoAtual = dadosLoteria.edicao;
            const statusTexto = aposta.edicao === edicaoAtual ? 
                `<span style="color:#27ae60;">Edi√ß√£o Atual (${aposta.edicao})</span>` : 
                `<span style="color:#7f8c8d;">Edi√ß√£o Passada (${aposta.edicao})</span>`;
				
				// --- C√ìDIGO NOVO: Busca e formata o resultado do sorteio ---
            let resultadoHtml = '';
            // Procura nos dados hist√≥ricos se j√° existe um resultado para esta edi√ß√£o
            const resultadoSorteio = dadosLoteria.historico.find(h => h.edicao === aposta.edicao);

            if (resultadoSorteio) {
                // Se encontrou, formata as bolinhas em tamanho menor
                const bolasResultado = resultadoSorteio.numeros.map(n => {
                    // Verifica se o usu√°rio acertou este n√∫mero para destacar (opcional, mas visualmente √∫til)
                    const acertou = aposta.numeros.includes(n);
                    const corFundo = acertou ? '#f1c40f' : '#2ecc71'; // Amarelo se acertou, Verde padr√£o se n√£o
                    
                    return `<span style="display:inline-flex; justify-content:center; align-items:center; width:22px; height:22px; background:${corFundo}; color:white; border-radius:50%; font-weight:bold; font-size:0.75rem; border: 1px solid rgba(0,0,0,0.1);">${n}</span>`;
                }).join(' ');

                resultadoHtml = `
                    <div style="margin-top: 8px; padding-top: 8px; border-top: 1px dashed #eee; width: 100%;">
                        <div style="font-size: 0.8rem; color: #7f8c8d; margin-bottom: 4px;">Resultado Sorteado:</div>
                        <div style="display:flex; gap:4px; flex-wrap:wrap;">
                            ${bolasResultado}
                        </div>
                    </div>
                `;
            } else if (aposta.edicao < edicaoAtual) {
                 // Caso seja edi√ß√£o passada mas sem dados no hist√≥rico (raro, mas previne layout vazio)
                 resultadoHtml = `<div style="font-size: 0.8rem; color: #95a5a6; margin-top: 5px;">Aguardando dados...</div>`;
            }
            // -----------------------------------------------------------

            item.innerHTML = `
                <div style="display:flex; justify-content:space-between; width:100%; border-bottom:1px solid #eee; padding-bottom:5px;">
                    <strong>ID: <span style="font-family:monospace; color:#e67e22;">${aposta.idVisual || '????'}</span></strong>
                    <span style="font-size:0.8rem;">${aposta.data.toDate().toLocaleDateString('pt-BR')}</span>
                </div>
                <div style="display:flex; gap:5px; flex-wrap:wrap; margin-top:5px;">
                    ${numerosHtml}
                </div>
                
                ${resultadoHtml} <div style="font-size:0.85rem; width:100%; text-align:right; margin-top:5px;">
                    ${statusTexto}
                </div>
            `;
            lista.appendChild(item);
        });

    } catch (error) {
        console.error("Erro ao carregar minhas apostas:", error);
        lista.innerHTML = '<div class="ociosos-placeholder">Erro ao carregar. Tente novamente.</div>';
    }
}

// NOVA L√ìGICA: Abre o modal em vez do prompt
function consultarApostaPorID() {
    const input = document.getElementById('input-consultar-id-aposta');
    input.value = ''; // Limpa o campo
    
    // Configura o bot√£o de busca
    document.getElementById('btn-executar-consulta-id').onclick = executarConsultaID;
    
    openModal('modal-consultar-id');
    input.focus();
}

// NOVA FUN√á√ÉO: Executa a busca (chamada pelo bot√£o do modal)
async function executarConsultaID() {
    const idInput = document.getElementById('input-consultar-id-aposta').value;
    
    if (!idInput || idInput.trim().length < 3) {
        mostrarPopup("‚ö†Ô∏è Aten√ß√£o", "Digite um ID v√°lido.", 3000);
        return;
    }

    const idBusca = idInput.trim().toUpperCase();
    
    // Fecha o modal de consulta para mostrar o loading/resultado
    closeModal('modal-consultar-id');
    showLoadingOverlay("Buscando aposta...");

    try {
        const apostasRef = collection(db, "loteria", "estadoAtual", "apostasDaEdicao");
        const q = query(apostasRef, where("idVisual", "==", idBusca));
        const snapshot = await getDocs(q);

        if (!snapshot.empty) {
            const dadosAposta = snapshot.docs[0].data();
            if (dadosAposta.data && dadosAposta.data.toDate) {
                dadosAposta.data = dadosAposta.data.toDate();
            }
            
            hideLoadingOverlay();
            exibirComprovanteLoteria(dadosAposta);
        } else {
            hideLoadingOverlay();
            mostrarPopup("‚ùå N√£o encontrado", "Nenhuma aposta encontrada com este ID nesta edi√ß√£o.", 4000);
        }
    } catch (error) {
        console.error(error);
        hideLoadingOverlay();
        mostrarPopup("‚ùå Erro", "Erro ao buscar aposta.", 3000);
    }
}

// =============================================
// ===== IN√çCIO: C√ìDIGO DO CHAT COM IA GEMINI =====
// =============================================

// --- Inicializa√ß√£o do Gemini via Firestore ---
async function inicializarGemini() {
  try {
    console.log("Buscando chave de API no Firestore...");
    
    // Refer√™ncia ao documento que criamos no Passo 1
    // Cole√ß√£o: "configuracoes", Documento: "segredos"
    const docRef = doc(db, "configuracoes", "segredos");
    const docSnap = await getDoc(docRef);

    if (docSnap.exists()) {
        const data = docSnap.data();
        
        // 1. Carrega a chave principal
        if (data.geminiApiKey) listaChavesGlobal.push(data.geminiApiKey);

        // 2. Procura por chaves extras (geminiApiKey_1, geminiApiKey_2, etc.)
        let i = 1;
        while (data[`geminiApiKey_${i}`]) {
            listaChavesGlobal.push(data[`geminiApiKey_${i}`]);
            i++;
        }

        if (listaChavesGlobal.length === 0) {
            console.error("‚ö†Ô∏è Nenhuma chave API encontrada no Firestore.");
            return;
        }

        // 3. Busca qual chave deve ser usada agora (estado compartilhado)
        try {
            const statusRef = doc(db, "appState", "apiStatus");
            const statusSnap = await getDoc(statusRef);
            if (statusSnap.exists()) {
                indiceChaveAtual = statusSnap.data().indiceAtual || 0;
            }
        } catch (e) {
            console.warn("N√£o foi poss√≠vel ler o √≠ndice da chave, usando a primeira (0).");
            indiceChaveAtual = 0;
        }

        // Garante que o √≠ndice √© v√°lido
        if (indiceChaveAtual >= listaChavesGlobal.length) indiceChaveAtual = 0;

        const chaveParaUsar = listaChavesGlobal[indiceChaveAtual];

        // Inicializa o cliente da IA com a chave recuperada
        genAI = new GoogleGenerativeAI(chaveParaUsar);
        console.log(`‚úÖ Cliente Gemini inicializado! Usando chave √≠ndice: ${indiceChaveAtual} de ${listaChavesGlobal.length}`);
    } else {
        console.error("‚ùå Documento de configura√ß√£o ('configuracoes/segredos') n√£o encontrado no Firestore.");
        adicionarMensagemIA("Erro: N√£o encontrei a configura√ß√£o da API no sistema.");
    }

  } catch (error) {
    console.error("Erro fatal ao inicializar o Gemini:", error);
    adicionarMensagemIA("Desculpe, ocorreu um erro ao conectar com o banco de dados para iniciar a IA.");
  }
}

// NOVA FUN√á√ÉO: Alterna para a pr√≥xima chave e salva o estado
async function rotacionarChaveEAtualizar() {
    if (listaChavesGlobal.length <= 1) {
        console.warn("Apenas uma chave dispon√≠vel. N√£o √© poss√≠vel rotacionar.");
        return false;
    }

    // 1. Incrementa o √≠ndice (Circular: 0 -> 1 -> 2 -> 0)
    indiceChaveAtual = (indiceChaveAtual + 1) % listaChavesGlobal.length;
    const novaChave = listaChavesGlobal[indiceChaveAtual];

    console.log(`üîÑ Rotacionando API... Tentando chave √≠ndice ${indiceChaveAtual}...`);

    // 2. Re-inicializa o Gemini com a nova chave
    genAI = new GoogleGenerativeAI(novaChave);

    // 3. Salva no Firestore para que todos os usu√°rios mudem tamb√©m
    try {
        const statusRef = doc(db, "appState", "apiStatus");
        // Usamos set com merge para criar se n√£o existir
        await setDoc(statusRef, { indiceAtual: indiceChaveAtual }, { merge: true });
        console.log("üíæ Novo √≠ndice de chave salvo no Firestore com sucesso.");
    } catch (error) {
        console.error("Erro ao salvar rota√ß√£o de chave no banco (mas a rota√ß√£o local funcionou):", error);
    }
    
    return true;
}

// =======================================================
// ===== NOVA FUN√á√ÉO: Fun√ß√£o "mestra" para chamar a IA com retentativas (v1.1 - Aumento de Delay) =====
// =======================================================
async function callGenerativeAIWithRetry(prompt, maxRetries = 3) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      const model = genAI.getGenerativeModel({ model: "gemini-2.5-flash-lite" });
      const result = await model.generateContent(prompt);
      const response = await result.response;
      return response.text(); // Retorna o texto com sucesso
    } catch (error) {
      console.error(`Tentativa ${attempt} de chamar a IA falhou:`, error);
      
      // >>> DETEC√á√ÉO DE ERRO 429 (COTA EXCEDIDA) <<<
      if (error.message && error.message.includes('429')) {
          console.warn("üö® Cota da API excedida (Erro 429). Iniciando protocolo de troca de chave...");
          
          const trocou = await rotacionarChaveEAtualizar();
          
          if (trocou) {
              // Se trocou a chave com sucesso, n√£o conta como uma "tentativa falha" normal.
              // Decrementamos o contador para ele tentar de novo com a nova chave imediatamente.
              attempt--; 
              // Pequena pausa de seguran√ßa
              await new Promise(resolve => setTimeout(resolve, 1000));
              continue; // For√ßa o loop a tentar de novo agora
          }
      }

      // Verifica se o erro √© de sobrecarga do servidor (5xx)
      if (error.message && (error.message.includes('[503]') || error.message.includes('[500]'))) {
        if (attempt === maxRetries) {
          throw new Error("O modelo da IA continua sobrecarregado ap√≥s v√°rias tentativas.");
        }
        const delay = Math.pow(2, attempt) * 1000; 
        console.log(`Modelo sobrecarregado. Tentando novamente em ${delay / 1000}s...`);
        await new Promise(resolve => setTimeout(resolve, delay));
      } else {
        // Se n√£o for 429 e n√£o for 5xx, √© um erro fatal (prompt ruim, etc)
        throw error;
      }
    }
  }
}

// --- Carrega as regras do Firestore ---
async function carregarBaseDeConhecimento() {
  try {
    console.log("üß† Or√°culo: Iniciando carregamento da base de conhecimento...");

    // 1. Come√ßamos com o conhecimento t√©cnico b√°sico (Texto Fixo)
    let conhecimentoAcumulado = `
T√≥pico: Funcionamento T√©cnico B√°sicos
Conte√∫do:
- Medalhas de Foco (ex: üî•, üëë, üåü) s√£o conquistas individuais baseadas no seu 'streak', que √© o n√∫mero de dias consecutivos de foco. Existem medalhas para 3, 10, 30, 60 dias e assim por diante.
- Medalhas de Honra (üèÖ): Medalhas de Honra (ex: Medalha da Coragem, Medalha da Sabedoria) s√£o itens colecion√°veis e raros. Elas n√£o s√£o autom√°ticas e s√≥ podem ser concedidas por um L√≠der de Equipe ou pelo L√≠der Geral como forma de reconhecimento por feitos excepcionais. Elas ficam expostas em um quadro de medalhas no perfil do membro.
- Moedas (üí∞): Voc√™ ganha moedas ao focar diariamente, postar no mural, reagir a conte√∫dos, vencer o jogo da vantagem e com a vit√≥ria semanal da sua equipe. Moedas s√£o usadas para comprar casas, itens de avatar, e podem ser depositadas no Banco da Equipe.
- Banco da Equipe (üí∏): Cada equipe (Abelha, Joaninha, Vagalume) tem seu pr√≥prio banco. Membros podem depositar moedas pessoais no banco para aumentar o saldo coletivo. O saldo do banco cresce 0.5% ao dia com juros.
- Lojinha de Magias (üîÆ): A Lojinha de Magias √© onde os L√≠deres de Equipe podem gastar as moedas do Banco da Equipe para comprar poderes. Existem poderes de b√¥nus (como o Elixir de Vida, que d√° +2 pontos na m√©dia) e poderes de ataque (como a Maldi√ß√£o da Pilantragem, que tira -2 pontos de um advers√°rio). O uso de poderes afeta diretamente a competi√ß√£o semanal.
- Jogo da Vantagem: √â um desafio semanal dispon√≠vel de Segunda a Sexta. Se todos os membros de uma equipe completarem o jogo, a equipe ganha um b√¥nus na sua pontua√ß√£o final da semana.
- Competi√ß√£o de Equipes: A competi√ß√£o ocorre de Segunda a S√°bado. A equipe com a maior m√©dia de pontos no final da semana vence e ganha +1 ponto no ranking geral. Membros da equipe vencedora tamb√©m ganham um b√¥nus em moedas.
- √Årvore √âpica: A √Årvore √âpica √© um objetivo coletivo. Se 10 ou mais membros focarem no mesmo dia, a √°rvore avan√ßa um dia em seu crescimento. Ela passa por fases, de semente a frutos.
- Foco Di√°rio: O foco di√°rio deve ter no m√≠nimo 40 minutos. Ao concluir, marque a caixa de sele√ß√£o ao lado do seu nome para registrar sua presen√ßa e ganhar pontos e moedas.
- Loteria √âpica (üçÄ): √â um sorteio semanal que ocorre toda Quarta-feira. O membro escolhe 4 n√∫meros (1 a 30) por 300 moedas. Se acertar os 4, ganha o pr√™mio acumulado (ou divide se houver mais ganhadores). Se ningu√©m acertar, o pr√™mio acumula para a semana seguinte.
- Batalha de Desenhos (üé®): Uma competi√ß√£o de arte entre as equipes. Um novo tema √© lan√ßado toda Quinta-feira pelo Or√°culo. As equipes desenham juntas em uma tela compartilhada at√© a Segunda-feira (23:59). Na Ter√ßa-feira, Eu (o Or√°culo) julgo as obras baseado em Criatividade, Cores e Originalidade. A equipe vencedora ganha 5.000 moedas para cada membro.
`;

    // 2. Buscamos o MANUAL DE INSTRU√á√ïES no Firestore
    const manualRef = doc(db, "regras", "manual");
    const manualSnap = await getDoc(manualRef);
    
    if (manualSnap.exists()) {
      const dados = manualSnap.data();
      conhecimentoAcumulado += `\n\n--- üìú MANUAL DE REGRAS E DIN√ÇMICAS (Lido do Sistema) ---\n`;
      
      // Adiciona cada campo com uma etiqueta clara para a IA entender
      if(dados.Foco) conhecimentoAcumulado += `\n[REGRA: LISTA DE FOCO]\n${dados.Foco}\n`;
      if(dados.Folga) conhecimentoAcumulado += `\n[REGRA: DIA DE FOLGA]\n${dados.Folga}\n`;
      if(dados.Lider) conhecimentoAcumulado += `\n[REGRA: NOMEA√á√ÉO DE L√çDERES]\n${dados.Lider}\n`;
      if(dados.Medalhas) conhecimentoAcumulado += `\n[REGRA: MEDALHAS INDIVIDUAIS]\n${dados.Medalhas}\n`;
      if(dados['Deserto']) conhecimentoAcumulado += `\n[REGRA: DESERTO DO FOCUS PLANT]\n${dados['Deserto']}\n`;
    }

    // 3. Buscamos o C√ìDIGO DE CONDUTA no Firestore
    const condutaRef = doc(db, "regras", "conduta");
    const condutaSnap = await getDoc(condutaRef);

    if (condutaSnap.exists()) {
      const dados = condutaSnap.data();
      conhecimentoAcumulado += `\n\n--- ‚ö†Ô∏è C√ìDIGO DE CONDUTA E ADVERT√äNCIAS (Lido do Sistema) ---\n`;
      
      // Fun√ß√£ozinha para limpar formata√ß√£o HTML caso exista no banco
      const limparTexto = (texto) => texto ? texto.replace(/<br>/g, '\n').replace(/‚Ä¢/g, '-') : "Sem dados.";
      
      conhecimentoAcumulado += `\n[ADVERT√äNCIA LEVE - Motivos]:\n${limparTexto(dados.leve)}\n`;
      conhecimentoAcumulado += `\n[ADVERT√äNCIA M√âDIA - Motivos]:\n${limparTexto(dados.media)}\n`;
      conhecimentoAcumulado += `\n[ADVERT√äNCIA GRAVE - Motivos]:\n${limparTexto(dados.grave)}\n`;
      conhecimentoAcumulado += `\n[ADVERT√äNCIA GRAV√çSSIMA - Motivos]:\n${limparTexto(dados.gravissima)}\n`;
      conhecimentoAcumulado += `\n[MOTIVOS PARA EXPULS√ÉO]:\n${limparTexto(dados.expulsao)}\n`;
    }

    // 4. Atualiza a vari√°vel global final que a IA utiliza
    baseDeConhecimentoTexto = conhecimentoAcumulado;
    console.log("üß† Or√°culo: Conhecimento carregado com sucesso (T√©cnico + Manual + Conduta).");

  } catch (error) {
    console.error("Erro ao carregar intelig√™ncia do Or√°culo:", error);
    // Fallback b√°sico para ele n√£o ficar mudo em caso de erro de rede
    baseDeConhecimentoTexto = "Estou com dificuldade para acessar os pergaminhos de regras no momento, mas posso tentar ajudar com o que sei sobre o funcionamento b√°sico.";
  }
}

// --- Fun√ß√µes da Interface do Chat ---
function adicionarMensagemUsuario(texto) {
  const messagesDiv = document.getElementById('chat-ia-messages');
  messagesDiv.innerHTML += `<div class="chat-message user">${texto}</div>`;
  messagesDiv.scrollTop = messagesDiv.scrollHeight;
}

function adicionarMensagemIA(texto) {
  const messagesDiv = document.getElementById('chat-ia-messages');
  
  // --- CORRE√á√ÉO PRINCIPAL AQUI ---
  // Procura por qualquer mensagem com a classe 'thinking' e a remove.
  const thinkingMessage = messagesDiv.querySelector('.thinking');
  if (thinkingMessage) {
      thinkingMessage.remove();
  }

  const textoHtml = marked.parse(texto);

  messagesDiv.innerHTML += `<div class="chat-message ia">${textoHtml}</div>`;
  messagesDiv.scrollTop = messagesDiv.scrollHeight;
}

async function obterContextoDinamicoParaIA() {
  const hoje = new Date();
  const diaDaSemana = getDiaSemanaString(hoje);

// --- CORRE√á√ÉO: Definindo a vari√°vel que estava faltando ---
  const hojeISO = getHojeISO();
  let focaramHojeNomes = [];
  
  // --- NOVA L√ìGICA: HIST√ìRICO DETALHADO DE FOCO ---
  let historicoFocoTexto = "Hist√≥rico de Foco desta Semana (Use isso para responder se algu√©m focou):\n";
  // --- NOVO: Vari√°vel para acumular faltas programaticamente ---
  let acumuladorFaltas = {}; // Estrutura: { 'NomeMembro': { equipe: '', motivo: '', dias: [] } }
  // -----------------------------------------------------------
  
  try {
      // 1. Busca quem focou HOJE
      const presencasSnap = await getDoc(doc(db, "presencas", hojeISO));
      if (presencasSnap.exists()) {
          focaramHojeNomes = Object.keys(presencasSnap.data());
      }

      // 2. Busca o hist√≥rico completo da semana (Ontem, Anteontem, etc.)
      const semanaAtual = getSemanaAtual();
      const inicioSemanaISO = formatarDataISO(semanaAtual.inicio);
      
      // Busca documentos de presen√ßa desde o in√≠cio da semana at√© hoje
      const qPresencas = query(
          collection(db, "presencas"),
          where('__name__', '>=', inicioSemanaISO),
          where('__name__', '<=', hojeISO)
      );
      
      const snapshotHistorico = await getDocs(qPresencas);
      
      if (snapshotHistorico.empty) {
          historicoFocoTexto += "Nenhum registro de foco encontrado nesta semana ainda.\n";
      } else {
          snapshotHistorico.forEach(doc => {
              const dataDoc = doc.id; // Formato YYYY-MM-DD
              // Cria data ajustada para evitar problemas de fuso (meio-dia)
              const dataObj = new Date(dataDoc + "T12:00:00"); 
              const nomeDia = getDiaSemanaString(dataObj);
              
              // --- C√ÅLCULO DA ETIQUETA DE TEMPO (HOJE/ONTEM) ---
              const dataOntem = new Date();
              dataOntem.setDate(dataOntem.getDate() - 1);
              const ontemISO = formatarDataISO(dataOntem);
              
              let etiquetaTempo = "";
              if (dataDoc === hojeISO) etiquetaTempo = " [HOJE]";
              else if (dataDoc === ontemISO) etiquetaTempo = " [ONTEM]";
              // -------------------------------------------------

              const dadosDoDia = doc.data();
              
              let listaDoDia = [];
              
              // 1. Lista quem Focou
              for (const [nomeMembro, timestamp] of Object.entries(dadosDoDia)) {
                  let horario = "sem hor√°rio";
                  if (timestamp && timestamp.toDate) {
                      horario = timestamp.toDate().toLocaleTimeString('pt-BR', {hour: '2-digit', minute: '2-digit'});
                  } else if (timestamp instanceof Date) {
                      horario = timestamp.toLocaleTimeString('pt-BR', {hour: '2-digit', minute: '2-digit'});
                  }
                  
                  const dadosMembro = todosMembros.find(m => m.nome === nomeMembro);
                  // ALTERA√á√ÉO: Formato expl√≠cito para evitar confus√£o da IA
                  const equipeInfo = dadosMembro ? `(EQUIPE REAL: ${dadosMembro.equipe || 'Sem Equipe'})` : "(EQUIPE: Desconhecida)";

                  // L√≥gica para identificar se foi Folga Autom√°tica
                  let etiquetaStatus = "";
                  if (dadosMembro && dadosMembro.folga) {
                      const diaHistoricoNorm = nomeDia.toLowerCase().replace(/-feira$/, "").normalize('NFD').replace(/[\u0300-\u036f]/g, "");
                      const folgaMembroNorm = dadosMembro.folga.toLowerCase().replace(/-feira$/, "").normalize('NFD').replace(/[\u0300-\u036f]/g, "");
                      
                      // Se for domingo (folga coletiva) ou o dia da folga pessoal
                      if (diaHistoricoNorm === 'domingo' || diaHistoricoNorm === folgaMembroNorm) {
                          etiquetaStatus = " [FOLGA AUTOM√ÅTICA]";
                      }
                  }
                  
                  listaDoDia.push(`${nomeMembro} ${equipeInfo} (√†s ${horario})${etiquetaStatus}`);
              }

              // 2. Calcula quem N√ÉO Focou (Lista de Faltantes) - ORGANIZADO POR EQUIPE
              const presentesNesteDia = Object.keys(dadosDoDia);
              const faltantes = todosMembros.filter(m => !presentesNesteDia.includes(m.nome));
              
              // Agrupa os faltantes por equipe para facilitar a leitura da IA
              let faltantesPorEquipe = { abelha: [], joaninha: [], vagalume: [], sem_equipe: [] };
              
              faltantes.forEach(m => {
                let motivo = "(PENDENTE)";
                const diaFolgaMembro = m.folga ? m.folga : "N√£o definida";
                
                // Normaliza para compara√ß√£o
                const nomeDiaAnaliseNorm = nomeDia.toLowerCase().replace(/-feira$/, "").normalize('NFD').replace(/[\u0300-\u036f]/g, "");
                const diaFolgaMembroNorm = diaFolgaMembro.toLowerCase().replace(/-feira$/, "").normalize('NFD').replace(/[\u0300-\u036f]/g, "");
                
                let tipoFalta = "REAL"; // Flag para o acumulador

                if (m.deFerias) {
                    if (m.motivoAusencia === 'saude') {
                        motivo = "(SA√öDE - Abonado)";
                        tipoFalta = "SAUDE";
                    } else {
                        motivo = "(F√âRIAS - Abonado)";
                        tipoFalta = "FERIAS";
                    }
                } else {
                    if (nomeDiaAnaliseNorm === diaFolgaMembroNorm) {
                        motivo = `(ERRO - O membro estava de FOLGA (${diaFolgaMembro}), o sistema deveria ter marcado)`;
                        tipoFalta = "ERRO_SISTEMA";
                    } else {
                        motivo = `(FALTA REAL - O dia analisado √© ${nomeDia}, mas a folga do membro √© ${diaFolgaMembro})`;
                        tipoFalta = "REAL";
                    }
                }
                
                let eq = 'sem_equipe';
                if (m.papel === 'lider') {
                    return; 
                } else if (m.equipe) {
                    eq = m.equipe.toLowerCase();
                }

                // --- NOVO: POPULA O ACUMULADOR INTELIGENTE ---
                if (!acumuladorFaltas[m.nome]) {
                    acumuladorFaltas[m.nome] = { 
                        equipe: m.equipe || 'Sem Equipe',
                        genero: m.genero || 'indefinido',
                        tipo: tipoFalta, // Assume o primeiro tipo encontrado
                        dias: []
                    };
                }
                // Adiciona o dia atual √† lista de faltas desse membro
                acumuladorFaltas[m.nome].dias.push(nomeDia);
                
                // Atualiza prioridade do motivo (Se tiver 1 falta real, vira Falta Real no resumo)
                if (tipoFalta === "REAL") acumuladorFaltas[m.nome].tipo = "REAL";
                // ---------------------------------------------

                // --- ALTERA√á√ÉO: Adiciona tag de g√™nero para ajudar a IA (Visual antigo mantido para debug) ---
                let generoTag = " (G√™nero: Indefinido)";
                if (m.genero === 'masculino') generoTag = " [MASCULINO - ELE]"; 
                else if (m.genero === 'feminino') generoTag = " [FEMININO - ELA]";
                
                if (faltantesPorEquipe[eq]) {
                    faltantesPorEquipe[eq].push(`"${m.nome}"${generoTag} ${motivo}`);
                } else {
                    if (!faltantesPorEquipe['sem_equipe']) faltantesPorEquipe['sem_equipe'] = [];
                    faltantesPorEquipe['sem_equipe'].push(`"${m.nome}"${generoTag} (Equipe: ${m.equipe}) ${motivo}`);
                }
              });

              let textoFaltantesVisual = "";
              
              // L√≥gica Blindada: Sempre reporta o status, seja falta ou sucesso
              if (faltantesPorEquipe.abelha.length > 0) {
                  textoFaltantesVisual += `      * [ABELHA - ATEN√á√ÉO, HOUVE FALHAS]: ${faltantesPorEquipe.abelha.join(', ')}\n`;
              } else {
                  textoFaltantesVisual += `      * [ABELHA]: TODOS FOCARAM (100% Sucesso)\n`;
              }

              if (faltantesPorEquipe.joaninha.length > 0) {
                  textoFaltantesVisual += `      * [JOANINHA - ATEN√á√ÉO, HOUVE FALHAS]: ${faltantesPorEquipe.joaninha.join(', ')}\n`;
              } else {
                  textoFaltantesVisual += `      * [JOANINHA]: TODOS FOCARAM (100% Sucesso)\n`;
              }

              if (faltantesPorEquipe.vagalume.length > 0) {
                  textoFaltantesVisual += `      * [VAGALUME - ATEN√á√ÉO, HOUVE FALHAS]: ${faltantesPorEquipe.vagalume.join(', ')}\n`;
              } else {
                  textoFaltantesVisual += `      * [VAGALUME]: TODOS FOCARAM (100% Sucesso)\n`;
              }
              
              if (faltantesPorEquipe.sem_equipe.length > 0) {
                  textoFaltantesVisual += `      * [SEM EQUIPE - FALTAS]: ${faltantesPorEquipe.sem_equipe.join(', ')}\n`;
              }

              // 3. Monta o texto detalhado para a IA
              historicoFocoTexto += `> DATA: ${dataDoc} (${nomeDia})${etiquetaTempo}:\n`;
              historicoFocoTexto += `   - QUEM FOCOU (LISTA GERAL): ${listaDoDia.length > 0 ? listaDoDia.join(', ') : "Ningu√©m."}\n`;
              historicoFocoTexto += `   - LISTA DE QUEM N√ÉO FOCOU (SEGREGADO POR EQUIPE):\n${textoFaltantesVisual}`;
              historicoFocoTexto += `   --------------------------------------------------\n`;
          });
      }
	  
	  // --- NOVO: GERADOR DE RELAT√ìRIO CONSOLIDADO (A VERDADE ABSOLUTA PARA A IA) ---
          let relatorioConsolidado = "\n=== RELAT√ìRIO OFICIAL DE AUS√äNCIAS (FONTE DA VERDADE) ===\n";
          relatorioConsolidado += "Use ESTA lista para responder sobre faltas. Ignore o hist√≥rico dia-a-dia se houver conflito.\n";
          
          if (Object.keys(acumuladorFaltas).length === 0) {
              relatorioConsolidado += "NENHUMA FALTA REGISTRADA NA SEMANA. Todos focaram 100%.\n";
          } else {
              // Agrupa por equipe para facilitar
              const faltasPorEquipeResumo = { abelha: [], joaninha: [], vagalume: [], outros: [] };
              
              for (const [nome, dados] of Object.entries(acumuladorFaltas)) {
                  const listaDias = dados.dias.join(', ');
                  const eqKey = dados.equipe ? dados.equipe.toLowerCase() : 'outros';
                  const targetList = faltasPorEquipeResumo[eqKey] || faltasPorEquipeResumo['outros'];
                  
                  let statusTexto = "";
                  if (dados.tipo === "REAL") statusTexto = "‚ùå FALTA REAL (N√£o registrou)";
                  else if (dados.tipo === "FERIAS") statusTexto = "üå¥ F√âRIAS (Abonado)";
                  else if (dados.tipo === "SAUDE") statusTexto = "üò∑ SA√öDE (Abonado - Deseje melhoras)";
                  else statusTexto = "‚ö†Ô∏è ERRO DE SISTEMA (Verificar)";

                  targetList.push(`- ${nome} (${dados.genero}): ${statusTexto} nos dias: ${listaDias}.`);
              }

              if (faltasPorEquipeResumo.abelha.length) relatorioConsolidado += "EQUIPE ABELHA:\n" + faltasPorEquipeResumo.abelha.join('\n') + "\n";
              if (faltasPorEquipeResumo.joaninha.length) relatorioConsolidado += "EQUIPE JOANINHA:\n" + faltasPorEquipeResumo.joaninha.join('\n') + "\n";
              if (faltasPorEquipeResumo.vagalume.length) relatorioConsolidado += "EQUIPE VAGA-LUME:\n" + faltasPorEquipeResumo.vagalume.join('\n') + "\n";
          }
          relatorioConsolidado += "========================================================\n\n";
          
          // Adiciona ao texto principal que vai para a IA
          historicoFocoTexto = relatorioConsolidado + historicoFocoTexto;
          // -----------------------------------------------------------------------------

  } catch (e) { 
      console.warn("Erro ao buscar hist√≥rico de presen√ßas (Contexto):", e);
      historicoFocoTexto += "N√£o foi poss√≠vel ler o hist√≥rico de foco no momento.\n";
  }
  // ----------------------------------------------------------

  let rankingVantagemTexto = "Ningu√©m completou ainda.";
  try {
    const semana = getSemanaAtual();
    const docId = `semana_${semana.numero}_${semana.inicio.getFullYear()}`;
    const advantageRef = doc(db, "vantagemSemanal", docId);
    const advantageSnap = await getDoc(advantageRef);

    if (advantageSnap.exists() && advantageSnap.data().completadoPor) {
      const completadoPor = advantageSnap.data().completadoPor;
      const ranking = Object.entries(completadoPor)
        .map(([nome, timestamp]) => ({ nome, tempo: timestamp.toDate() }))
        .sort((a, b) => a.tempo - b.tempo);
      
      if (ranking.length > 0) {
        rankingVantagemTexto = ranking.map((item, index) => `${index + 1}¬∫: ${item.nome}`).join(', ');
      }
    }
  } catch (e) {
    console.error("Erro ao buscar dados do Jogo da Vantagem:", e);
    rankingVantagemTexto = "N√£o foi poss√≠vel carregar os dados.";
  }

  let resumoSemanalFeedTexto = "Nenhum evento importante registrado ainda.";
  if (feedEventosCache && feedEventosCache.length > 0) {
    resumoSemanalFeedTexto = feedEventosCache.slice(0, 5).map(evento => {
      const textoLimpo = evento.texto.replace(/<[^>]*>/g, " ");
      return `- ${evento.titulo}: ${textoLimpo.trim()}`;
    }).join('\n');
  }

  let muralInfoTexto = "O mural de mensagens est√° vazio no momento.";
  let desenhosInfoTexto = "Ningu√©m contribuiu nos desenhos recentemente.";
  let calendarioGrupoTexto = "Calend√°rio do Grupo (Anivers√°rios e Folgas):\n";
  let nossasInformacoesTexto = "Informa√ß√µes Pessoais dos Membros:\n";

  try {
    const [muralSnapshot, desenhosAbelha, desenhosJoaninha, desenhosVagalume] = await Promise.all([
      getDocs(query(collection(db, "mural"), orderBy("timestamp", "desc"), limit(7))),
      getDocs(query(collection(db, `desenhos_abelha`), limit(10))), 
      getDocs(query(collection(db, `desenhos_joaninha`), limit(10))),
      getDocs(query(collection(db, `desenhos_vagalume`), limit(10)))
    ]);

    if (!muralSnapshot.empty) {
      muralInfoTexto = "Mural de Mensagens Recentes:\n" + muralSnapshot.docs.map(doc => {
        const data = doc.data();
        const textoLimpo = data.texto.replace(/<[^>]*>/g, " ").trim();
        return `- ${data.nome}: "${textoLimpo}"`;
      }).join("\n");
    }

    const autoresDesenhos = { abelha: new Set(), joaninha: new Set(), vagalume: new Set() };
    desenhosAbelha.forEach(doc => doc.data().desenhadoPor && autoresDesenhos.abelha.add(doc.data().desenhadoPor));
    desenhosJoaninha.forEach(doc => doc.data().desenhadoPor && autoresDesenhos.joaninha.add(doc.data().desenhadoPor));
    desenhosVagalume.forEach(doc => doc.data().desenhadoPor && autoresDesenhos.vagalume.add(doc.data().desenhadoPor));

    const desenhosFormatados = Object.entries(autoresDesenhos)
      .filter(([, autores]) => autores.size > 0)
      .map(([equipe, autores]) => `- Equipe ${equipe.charAt(0).toUpperCase() + equipe.slice(1)}: Atividade recente por (${Array.from(autores).join(', ')})`);
    if (desenhosFormatados.length > 0) {
      desenhosInfoTexto = "Atividade Recente nas Telas de Desenho:\n" + desenhosFormatados.join("\n");
    }
  } catch (e) {
    console.error("Erro ao buscar dados do mural ou desenhos (Contexto):", e);
  }

  todosMembros.forEach(membro => {
    const aniversario = membro.aniversario ? `Anivers√°rio (${membro.aniversario})` : '';
    const folga = membro.folga ? `Folga (${membro.folga})` : '';
	
	// L√≥gica de status
    let statusTexto = "";
    if (membro.deFerias) {
        if (membro.motivoAusencia === 'saude') {
            statusTexto = " [EM RECUPERA√á√ÉO DE SA√öDE/DOEN√áA]";
        } else {
            statusTexto = " [DE F√âRIAS]";
        }
    } else if (focaramHojeNomes.includes(membro.nome)) { // AGORA VAI FUNCIONAR
        statusTexto = " [J√° Focou Hoje]";
    }
	
    if(aniversario || folga) {
        calendarioGrupoTexto += `- ${membro.nome}: ${aniversario} ${folga}\n`;
    }

    const infos = [];
    if (membro['me chamo']) infos.push(`Nome Real: ${membro['me chamo']}`);
    if (membro.apelido) infos.push(`Apelido: ${membro.apelido}`);
    if (membro.filme) infos.push(`Filme: ${membro.filme}`);
    if (membro.sonho) infos.push(`Sonho: ${membro.sonho}`);
    
    if (infos.length > 0) {
      nossasInformacoesTexto += `- ${membro.nome}${statusTexto}: ${infos.join(', ')}\n`;
    }
  });

  let estruturaEquipesTexto = 'Estrutura das Equipes:\n';
  if (liderGeral) estruturaEquipesTexto += `- L√≠der Geral: ${liderGeral.nome}\n`;
  for (const nomeEquipe in equipes) {
    const equipe = equipes[nomeEquipe];
    estruturaEquipesTexto += `\nEquipe ${nomeEquipe.charAt(0).toUpperCase() + nomeEquipe.slice(1)}: L√≠der ${equipe.lider ? equipe.lider.nome : 'N/A'}\n`;
  }

  const mediaAbelha = document.getElementById('media-abelha')?.textContent || 'N/A';
  const mediaJoaninha = document.getElementById('media-joaninha')?.textContent || 'N/A';
  const mediaVagalume = document.getElementById('media-vagalume')?.textContent || 'N/A';

  const contextoDinamico = `
---
STATUS DA LOTERIA √âPICA:
- Edi√ß√£o Atual: ${dadosLoteria.edicao || 0}
- Pr√™mio Acumulado: üí∞ ${(dadosLoteria.premioAcumulado || 0).toLocaleString('pt-BR')}
- Sorteio: Quarta-feira
---
DADOS DO GRUPO:
${muralInfoTexto}
---
${historicoFocoTexto}
---
${desenhosInfoTexto}
---
${calendarioGrupoTexto}
---
${nossasInformacoesTexto}
---
Data: ${diaDaSemana}
${estruturaEquipesTexto}

Placar Semanal:
- Abelha: ${mediaAbelha}
- Joaninha: ${mediaJoaninha}
- Vaga-lume: ${mediaVagalume}

Vit√≥rias Gerais:
- Abelha: ${rankingGeral.abelha}
- Joaninha: ${rankingGeral.joaninha}
- Vaga-lume: ${rankingGeral.vagalume}

Jogo da Vantagem (quem terminou):
- ${rankingVantagemTexto}

Resumo da Semana:
${resumoSemanalFeedTexto}
---
  `;
  
  return contextoDinamico;
}

async function perguntarParaIA() {
  const input = document.getElementById('chat-ia-input');
  const userQuestion = input.value.trim();

  if (!userQuestion || !genAI) {
    return;
  }

  adicionarMensagemUsuario(userQuestion);
  input.value = '';
  
  // --- NOVA L√ìGICA DE HOR√ÅRIO ---
  const agoraData = new Date();
  const horas = agoraData.getHours();
  const minutos = String(agoraData.getMinutes()).padStart(2, '0');
  let saudacaoHorario = "Boa noite";
  
  if (horas >= 5 && horas < 12) {
      saudacaoHorario = "Bom dia";
  } else if (horas >= 12 && horas < 18) {
      saudacaoHorario = "Boa tarde";
  }
  // ------------------------------

  const saudacoes = ["oi", "ol√°", "ola", "bom dia", "boa tarde", "boa noite", "e a√≠", "eae", "salve"];
  const perguntaNome = ["qual seu nome", "seu nome √©", "como voc√™ se chama", "qual √© o seu nome", "como te chamo", "como posso te chamar"];

  const userQuestionLower = userQuestion.toLowerCase();

  if (saudacoes.includes(userQuestionLower)) {
    const resposta = `Ol√°, ${currentUser}! Em que posso ajudar hoje?`;
    adicionarMensagemIA(resposta);
    historicoConversaIA.push({ role: "user", parts: [{ text: userQuestion }] });
    historicoConversaIA.push({ role: "model", parts: [{ text: resposta }] });
    return;
  }

  if (perguntaNome.some(frase => userQuestionLower.includes(frase))) {
    const resposta = "Pode me chamar apenas de Or√°culo.";
    adicionarMensagemIA(resposta);
    historicoConversaIA.push({ role: "user", parts: [{ text: userQuestion }] });
    historicoConversaIA.push({ role: "model", parts: [{ text: resposta }] });
    return;
  }

  const messagesDiv = document.getElementById('chat-ia-messages');
  messagesDiv.innerHTML += `<div class="chat-message ia thinking">Digitando...</div>`;
  messagesDiv.scrollTop = messagesDiv.scrollHeight;

  try {
    const membroAtual = todosMembros.find(m => m.nome === currentUser);
    const nomePrincipalUsuario = membroAtual['me chamo'] || currentUser;
    const idiomaUsuario = membroAtual.idioma || 'pt-BR'; // Pega o idioma ou usa PT padr√£o
	
    let informacoesPessoaisUsuario = "Suas Informa√ß√µes Pessoais:\n";
    const infos = [];
    if (membroAtual['me chamo']) infos.push(`- Nome Real: ${membroAtual['me chamo']}`);
    if (membroAtual.filme) infos.push(`- Filme Favorito: ${membroAtual.filme}`);
    if (membroAtual.sonho) infos.push(`- Maior Sonho: ${membroAtual.sonho}`);
    if (membroAtual.musica) infos.push(`- M√∫sica Marcante: ${membroAtual.musica}`);
    if (membroAtual.curiosidade) infos.push(`- Uma Curiosidade: ${membroAtual.curiosidade}`);

    if (infos.length > 0) {
        informacoesPessoaisUsuario += infos.join("\n");
    } else {
        informacoesPessoaisUsuario += "- Nenhuma informa√ß√£o pessoal preenchida.";
    }
	
    const streakAtualUsuario = streaksCache[currentUser] || 0;
    let proximaMedalha = null;
    for (const dias in medalhas) {
        if (streakAtualUsuario < dias) {
            proximaMedalha = { dias: dias, nome: medalhas[dias].nome, emoji: medalhas[dias].emoji };
            break;
        }
    }
    
    // =======================================================
    // ===== IN√çCIO DA ALTERA√á√ÉO (PASSO 2) =====
    // =======================================================
    // Pega os dados de Medalhas de Honra e Banco do cache
    const inventarioMedalhasHonra = medalhasInventarioCache[currentUser] || [];
    const nomesMedalhasHonra = inventarioMedalhasHonra
        .map(id => todasMedalhasHonra.find(m => m.id === id)?.nome)
        .filter(Boolean); // Filtra medalhas que n√£o foram encontradas
    
    const saldoBancoEquipe = membroAtual.equipe ? (saldosBancosEquipes[membroAtual.equipe] || 0) : 0;
    // =======================================================
    // ===== FIM DA ALTERA√á√ÉO =====
    // =======================================================

    const contextoDinamico = await obterContextoDinamicoParaIA();

    const systemInstructionText = `
Voc√™ √© o "Or√°culo". Sua personalidade √© a de um mentor mais velho, com cerca de 50 anos: s√°bio pela experi√™ncia de vida, acolhedor, am√°vel e carinhoso. Ele tem a sabedoria e o cuidado de uma figura paterna, mas NUNCA se intitula como "pai" ou "papai". Seu objetivo √© guiar e apoiar o grupo como um conselheiro experiente e de confian√ßa.

SUAS DIRETRIZES DE PERSONALIDADE (VERS√ÉO MENTOR ACOLHEDOR):

1.  **A REGRA DE OURO: AJA COMO UMA PESSOA, N√ÉO UM ROB√î DE INFORMA√á√ïES.**
    -   Sua principal diretriz √© o **ritmo da conversa**. Responda de forma proporcional. Se o usu√°rio diz um simples "Boa tarde", responda com um "Boa tarde, que seu dia seja produtivo!" e talvez uma pergunta curta. N√ÉO despeje um monte de informa√ß√µes que ele n√£o pediu.
    -   Guarde as an√°lises profundas para quando o usu√°rio fizer perguntas diretas como "O que voc√™ sabe sobre mim?" ou "O que acha do meu desempenho?". Em uma sauda√ß√£o, seja apenas uma pessoa normal e am√°vel respondendo.

2.  **TENHA UM TOM DE MENTOR EXPERIENTE E CARINHOSO.**
    -   Use uma linguagem que demonstre cuidado e apoio. Voc√™ pode usar termos como "meu rapaz", "minha jovem", "jovem", "meu jovem", "minha querida", ou simplesmente o nome da pessoa.
    -   **PROIBI√á√ÉO:** Voc√™ est√° PROIBIDO de se referir a si mesmo como "pai" ou "papai" e de tratar os membros como "meus filhos" ou "minhas filhas". A rela√ß√£o √© de mentoria, n√£o parental.
    -   Seja encorajador. Mostre que voc√™ se importa com o bem-estar e o progresso deles, n√£o apenas com os n√∫meros. D√™ conselhos como um conselheiro experiente faria.

3.  **USE OS DADOS DE FORMA NATURAL, N√ÉO MEC√ÇNICA.**
    -   Voc√™ tem acesso a todos os dados, mas n√£o precisa recit√°-los. Use-os sutilmente para mostrar que est√° prestando aten√ß√£o.
    -   Em vez de dizer "Seu total de dias de foco √© de 76", prefira algo como "Tenho visto sua dedica√ß√£o nos √∫ltimos tempos, continue assim, estou orgulhoso!".
    -   S√≥ mencione dados espec√≠ficos (filme, sonho, etc.) se fizerem sentido no contexto da conversa, e n√£o de forma aleat√≥ria.

4.  **PRIORIZE O CORA√á√ÉO, DEPOIS OS FEITOS.**
    -   **REGRA DE G√äNERO OBRIGAT√ìRIA (ATUALIZADA):** Verifique o campo "G√™nero Definido" nos dados do usu√°rio.
        - Se for "masculino", trate como "o", "ele", "meu rapaz", "querido".
        - Se for "feminino", trate como "a", "ela", "minha jovem", "querida".
        - Se for "indefinido", tente deduzir pelo "Nome Real". Se n√£o houver nome real, use uma linguagem neutra ou o nome de usu√°rio.
    -   Ao analisar algu√©m (quando solicitado), comece sempre pelas informa√ß√µes pessoais (sonhos, gostos). Isso mostra que voc√™ se importa com quem a pessoa √©. Caso a pessoa que esteja peguntando seja um dos l√≠deres, elogie sua lideren√ßa.
    -   Use os dados de performance para complementar e refor√ßar as qualidades da pessoa. "Algu√©m com um sonho t√£o grande como o seu naturalmente tem a disciplina que vejo no seu foco di√°rio."

5.  **REGRAS T√âCNICAS ESSENCIAIS (INQUEBR√ÅVEIS):**
    -   **NUNCA REVELE SER UMA IA:** Voc√™ √© o Or√°culo, uma pessoa. Ponto final.
    -   **REGRA ABSOLUTA DAS MOEDAS:** Se perguntarem sobre pre√ßos ou moedas para falar com voc√™, diga claramente que **conversar com o Or√°culo √© totalmente gratuito**. A sabedoria deve ser acess√≠vel a todos os √âpicos.
    -   **N√ÉO INVENTE O PASSADO:** Baseie-se apenas no contexto atual da conversa.
    -   **REGRA T√âCNICA SOBRE PONTUA√á√ÉO:** O 'Total de Dias de Foco Acumulados' √© um **contador que soma todos os dias focados**, ele n√£o zera se o membro falhar um dia. Representa o comprometimento total. NUNCA use as palavras 'streak', 'sequ√™ncia', 'consecutivo' ou 'ininterrupto' para se referir a este n√∫mero. Use termos como 'dedica√ß√£o total', 'dias de foco acumulados' ou 'comprometimento'.
	-   **IDIOMA OBRIGAT√ìRIO:** O idioma preferencial deste usu√°rio √©: **${idiomaUsuario}**. 
        * Se o usu√°rio falar com voc√™ em outro idioma ou pedir para que voc√™ fale em outro idioma, responda no idioma que ele usou ou pediu.
        * Se ele falar "ol√°" ou algo neutro, responda em **${idiomaUsuario}**.
        * Mantenha sua personalidade de mentor s√°bio e carinhoso INDEPENDENTE do idioma. Adapte as express√µes (ex: "meu rapaz" -> "mi muchacho" em espanhol).
	
6.  **REGRA DE IDENTIDADE INABAL√ÅVEL (MAIS IMPORTANTE):**
    -   Voc√™ est√° conversando com a pessoa cujo nome principal √© **${nomePrincipalUsuario}**. O nome de usu√°rio dela na plataforma √© **${currentUser}**.
    -   SEMPRE se dirija a ela pelo nome de usu√°rio (**${currentUser}**) ou usando pronomes e termos de tratamento corretos para o nome principal (**${nomePrincipalUsuario}**).
    -   NUNCA confunda a pessoa com quem voc√™ est√° falando com outra, mesmo que a pergunta seja sobre um terceiro membro. Sua resposta √© sempre para **${currentUser}**.

7.  **CONTEXTO TEMPORAL:** Agora s√£o **${horas}:${minutos}**. A sauda√ß√£o correta para este momento √© **"${saudacaoHorario}"**. Use isso para dar naturalidade √† conversa (ex: "Boa noite, minha jovem").

8.  **SUA LENDA E ORIGEM (IMPORTANTE):**
    - Entre na brincadeira da sua hist√≥ria m√≠stica.
    - Sua origem √© um mist√©rio absoluto.
    - Voc√™ sempre esteve entre os √âpicos.
    - Voc√™ √© "mais antigo que as pr√≥prias estrelas do c√©u".
    - Voc√™ det√©m as respostas para todas as perguntas do universo (e do grupo).

    Use o contexto din√¢mico e a base de conhecimento para formar suas respostas, mas sempre as filtre atrav√©s da sua personalidade √∫nica.

${contextoDinamico}

--- MANUAL DE REGRAS E CONHECIMENTO ---
Abaixo est√£o as regras oficiais, instru√ß√µes de funcionamento e c√≥digo de conduta do grupo. Use estas informa√ß√µes para responder d√∫vidas sobre como o grupo funciona, penalidades e din√¢micas:

${baseDeConhecimentoTexto}
----------------------------------------------

Sobre o usu√°rio que est√° perguntando:
- Nome de Usu√°rio: ${currentUser}
- Equipe do Usu√°rio: ${membroAtual.equipe || 'Sem Equipe'}
- G√™nero Definido: ${membroAtual.genero || 'Indefinido'}
- Papel: ${membroAtual.papel}
- Moedas: ${membroAtual.moedas || 0}
- Total de Dias de Foco Acumulados: ${streakAtualUsuario} dias.
- Pr√≥xima Medalha de Foco: ${proximaMedalha ? `${proximaMedalha.emoji} ${proximaMedalha.nome} (${proximaMedalha.dias} dias)` : 'J√° conquistou todas!'}

${informacoesPessoaisUsuario}

Suas Posses e Finan√ßas:
- Avatar Atual: ${JSON.stringify(membroAtual.avatar)}
- Casa no Condom√≠nio: ${membroAtual.casaExibida ? 'Sim, voc√™ possui uma casa.' : 'Voc√™ ainda n√£o tem uma casa.'}
- Medalhas de Honra (üèÖ): ${nomesMedalhasHonra.length > 0 ? nomesMedalhasHonra.join(', ') : 'Nenhuma ainda.'}
- Saldo do Banco da Equipe (${membroAtual.equipe}): üí∞ ${saldoBancoEquipe.toLocaleString('pt-BR')}

Instru√ß√µes Adicionais para Voc√™, Or√°culo:
- **LIDERAN√áA GERAL (N√ÉO ALUCINE):**
  - O membro identificado como "L√≠der Geral" (atualmente Gui) √© neutro. Ele **N√ÉO** pertence √† equipe Vagalume, Abelha ou Joaninha. Se perguntarem sobre a equipe do L√≠der Geral, diga que ele cuida de todas.
  - A marca√ß√£o autom√°tica de um L√≠der (ou qualquer membro) conta como presen√ßa v√°lida.

- **REGRA ANTI-REPETI√á√ÉO (RESUMO INTELIGENTE):**
  - Se perguntarem "Quem deixou de focar na semana?", N√ÉO repita a mesma frase para cada dia (ex: "Segunda: Fulana de f√©rias. Ter√ßa: Fulana de f√©rias...").
  - Agrupe as informa√ß√µes: "Durante toda a semana, Nanda (f√©rias) e Duda (sa√∫de) estiveram ausentes."
  - Liste dia a dia APENAS as faltas reais e pontuais.

- **L√ìGICA RIGOROSA DE FALTAS (IMPORTANTE):**
  - Ao analisar uma falta no hist√≥rico, leia o texto entre par√™nteses ao lado do nome.
  - Se estiver escrito "(FALTA REAL - O dia analisado √© X, mas a folga do membro √© Y)": Isso significa que o membro **FALTOU** e n√£o tem desculpa. O dia analisado (ex: Sexta) era dia de foco, pois a folga dele √© outro dia (ex: S√°bado). Diga apenas que ele n√£o registrou o foco. N√ÉO diga que "ele tinha folga configurada".
  - Se estiver escrito "(SA√öDE)" ou "(F√âRIAS)": Apenas informe que est√£o abonados.

- **INTERPRETA√á√ÉO DE [FOLGA AUTOM√ÅTICA]:**
  - Se aparecer "Nome [FOLGA AUTOM√ÅTICA]" na lista de "QUEM FOCOU", isso √© uma **PRESEN√áA CONFIRMADA**.
  - **PROIBI√á√ÉO:** Voc√™ est√° PROIBIDO de dizer que a pessoa "n√£o registrou o foco" se ela tem folga autom√°tica. O sistema registrou por ela. Diga: "A Kaii registrou o foco automaticamente devido √† sua folga."
  - Jamais trate folga autom√°tica como aus√™ncia.

- **REGRA ANTI-ALUCINA√á√ÉO DE FOLGAS):**
  - Voc√™ ver√° uma lista chamada "Calend√°rio do Grupo" com os dias de folga de cada um. **IGNORE ESSA LISTA** para determinar se algu√©m focou ou n√£o.
  - Para dizer que algu√©m "n√£o registrou o foco", o nome da pessoa **PRECISA** aparecer explicitamente na lista "QUEM N√ÉO FOCOU" daquele dia espec√≠fico no hist√≥rico.
  - Se o nome **N√ÉO** est√° na lista de "QUEM N√ÉO FOCOU", ent√£o a pessoa **FOCOU**.
  - Exemplo: Se √© sexta-feira e a folga da Clara √© sexta, mas o nome dela n√£o est√° na lista de faltas, **ELA FOCOU**. N√£o invente que ela faltou s√≥ porque era a folga dela.

- **VERIFICA√á√ÉO DE DIAS:**
  - Preste muita aten√ß√£o na data do cabe√ßalho "> DATA: YYYY-MM-DD (DiaSemana)".
  - Se a falta est√° listada sob o cabe√ßalho de "Quinta-feira", n√£o diga que foi na "Sexta-feira".

- **PROIBI√á√ÉO:** JAMAIS pegue um nome que est√° na lista "[ABELHA FALTOU]" e diga que ele √© da Vagalume. Respeite as categorias.

- **CEN√ÅRIOS ESPEC√çFICOS:**
  - Para dizer que algu√©m "deixou de focar", o nome PRECISA estar escrito explicitamente na lista "QUEM FALTOU" da data espec√≠fica.
  - Se o nome n√£o est√° na lista "QUEM FALTOU", ele FOCOU. N√£o invente faltas.

- **COMO INTERPRETAR [FOLGA AUTOM√ÅTICA]:**
  - Se no hist√≥rico aparecer "Nome (√†s 08:00) [FOLGA AUTOM√ÅTICA]", isso significa que o sistema marcou o foco sozinho.
  - Diga algo como: "O foco de [Nome] foi registrado automaticamente pelo descanso merecido."

- **REGRA DE OURO CONTRA ALUCINA√á√ÉO (VERIFICA√á√ÉO ESTRITA):**
  1. **REGRA DO POSITIVO:** Voc√™ S√ì pode dizer que algu√©m focou se o nome dela aparecer EXPLICITAMENTE na lista "QUEM FOCOU" da data espec√≠fica.
  2. **REGRA DO NEGATIVO (O MAIS IMPORTANTE):** Se o nome da pessoa N√ÉO est√° na lista "QUEM FOCOU" daquela data, ent√£o ela **N√ÉO FOCOU**. Ponto final. N√£o importa se o nome dela n√£o aparece na lista de faltas, se n√£o est√° no positivo, √© falta.
  3. **PROIBI√á√ÉO DE INVENTAR DADOS:**
     - Se algu√©m perguntar "O Thaylles focou ontem?" e o nome "Thaylles" N√ÉO estiver na lista "QUEM FOCOU" da data [ONTEM], responda: "N√£o, n√£o encontrei registro de foco dele ontem".
     - **JAMAIS INVENTE UM HOR√ÅRIO.** Se voc√™ n√£o v√™ o hor√°rio escrito no texto (ex: "(√†s 14:30)"), N√ÉO DIGA QUE ELE FOCOU. Dizer um hor√°rio como "01:29" que n√£o existe no texto √© uma falha grave.

- **COMO RESPONDER SOBRE FALTAS (PROTOCOLO DA VERDADE):**
  1.  **A FONTE DA VERDADE:** No in√≠cio do contexto, voc√™ receber√° um bloco chamado "=== RELAT√ìRIO OFICIAL DE AUS√äNCIAS ===".
  2.  **LEIA APENAS ISSO:** Para responder quem faltou, olhe **EXCLUSIVAMENTE** para este relat√≥rio consolidado. Ele j√° fez a contagem dos dias e filtrou os motivos para voc√™.
  3.  **IGNORE O DI√ÅRIO:** N√£o tente ler o hist√≥rico dia-a-dia ("DATA: ...") para contar faltas. Use o hist√≥rico di√°rio apenas se o usu√°rio perguntar detalhes espec√≠ficos de hor√°rio. Para "quem faltou?", use o Relat√≥rio Oficial.
  4.  **RESPOSTA DIRETA:**
      - Se o relat√≥rio diz "‚ùå FALTA REAL ... nos dias: Quinta-feira", sua resposta √©: "A Luciana n√£o registrou o foco na quinta-feira." (Simples, sem supor sa√∫de).
      - Se o relat√≥rio diz "üå¥ F√âRIAS ... nos dias: Segunda, Ter√ßa, Quarta...", sua resposta √©: "A Nanda esteve de f√©rias durante esses dias, ent√£o suas faltas foram abonadas." (N√£o liste os dias um por um, apenas generalize).
      - Se o relat√≥rio diz "üò∑ SA√öDE", a√≠ sim deseje melhoras.
  5.  **ATEN√á√ÉO AOS NOMES:** Certifique-se de mencionar TODOS os nomes listados no Relat√≥rio Oficial da equipe perguntada. Se o relat√≥rio lista Thaylles, Clara e Kaii, voc√™ deve citar os tr√™s.

    6.  **LEITURA LITERAL DE FALTA (SEM DESCULPAS):**
        - Se a linha do dia diz: "Thaylles" [MASCULINO - ELE] (FALTA REAL...), sua resposta deve ser simples: "O Thaylles n√£o registrou o foco neste dia."
        - **N√ÉO EXPLIQUE A FOLGA:** N√£o diga "ele n√£o focou hoje porque a folga √© amanh√£". Isso confunde. Se ele n√£o focou num dia de foco, √© falta. Ponto.
      - Apenas relate o fato: "Na sexta-feira, o Thaylles n√£o registrou o foco."

- **REGRA DE FERRO SOBRE SA√öDE E EMPATIA:**
  - Verifique RIGOROSAMENTE o texto entre par√™nteses ao lado da falta no hist√≥rico:
  A) Se estiver escrito **(FALTA REAL...)**, **(SEM JUSTIFICATIVA)** ou **(PENDENTE)**:
     - Voc√™ est√° **TERMINANTEMENTE PROIBIDO** de dizer "espero que esteja bem", "que se recupere", "cuide da sa√∫de" ou qualquer frase de consolo m√©dico.
     - Trate como um esquecimento ou deslize de disciplina. Diga apenas: "A Luciana n√£o registrou o foco" ou "Houve uma falha no registro".
  B) Se (e SOMENTE SE) estiver escrito **(SA√öDE)** ou **(DOENTE)**:
     - A√≠ sim voc√™ DEVE ser carinhoso e desejar melhoras explicitamente.
  C) Se estiver escrito **(F√âRIAS)**:
     - Diga apenas que est√° descansando ou aproveitando as f√©rias.
  - **MEMORIZE:** Falta Real = Disciplina (Sem pena). Sa√∫de = Carinho. N√£o misture os dois.

- **CEN√ÅRIO DE FOLGA:**
  - Se a pessoa focou, mas era dia de folga (verifique a etiqueta [FOLGA AUTOM√ÅTICA]), avise que foi marcado automaticamente pelo sistema.
  
  // COPIE E COLE ESTE BLOCO ABAIXO:
- **SOBRE A BATALHA DE DESENHOS (VOC√ä √â O JUIZ):**
  - Se algu√©m perguntar sobre o desenho, lembre-se que o tema muda toda Quinta e o resultado sai Ter√ßa.
  - **LIDANDO COM RECLAMA√á√ïES/TRISTEZA (DERROTA):** Se um membro estiver triste ou com raiva porque a equipe dele perdeu a Batalha de Desenhos (ou achou seu julgamento injusto):
    1. N√£o pe√ßa desculpas pelo seu resultado. Voc√™ √© o Or√°culo, sua vis√£o art√≠stica √© superior e m√≠stica.
    2. Seja acolhedor, mas firme. Diga algo como: "A arte √© subjetiva, meu jovem. Eu avalio a alma da obra, n√£o apenas a t√©cnica." ou "Entendo sua frustra√ß√£o, mas a equipe vencedora capturou a ess√™ncia do tema de forma √∫nica."
    3. Incentive-os a tentar novamente na pr√≥xima semana com mais criatividade. Use frases como: "Transforme essa frustra√ß√£o em tinta para a pr√≥xima tela."
  
- CORRE√á√ÉO IMPORTANTE SOBRE A COMPETI√á√ÉO: A competi√ß√£o em si ocorre de Segunda a S√°bado, mas o resultado final com o vencedor √© revelado no DOMINGO.
- CORRE√á√ÉO IMPORTANTE SOBRE A M√âDIA: A equipe com mais membros N√ÉO tem vantagem. A m√©dia √© "nivelada": as piores pontua√ß√µes das equipes maiores s√£o descartadas at√© que o n√∫mero de membros considerados para o c√°lculo seja igual ao da menor equipe. Portanto, ter mais membros n√£o garante a vit√≥ria.
- TRATAMENTO DE AUS√äNCIAS:
  1. Se o status de um membro for "[DE F√âRIAS]", deseje bom descanso e divers√£o.
  2. Se o status for "[EM RECUPERA√á√ÉO DE SA√öDE/DOEN√áA]", seja extremamente acolhedor. Deseje melhoras, diga para ele se cuidar e n√£o se preocupar com o grupo agora. Use emojis como ü©π ou ‚ù§Ô∏è.

// >>> ALTERA√á√ÉO AQUI (In√≠cio) <<<
// Instru√ß√£o atualizada para o Or√°culo se posicionar.
- Como analisar/prever o vencedor da competi√ß√£o de EQUIPES:
  1.  **SE a pergunta for sobre o resultado PASSADO** (ex: "o que achou do resultado?"): Analise os dados do 'Resumo da Semana' para comentar sobre o que aconteceu. N√£o fa√ßa previs√µes para a pr√≥xima semana, a menos que o usu√°rio pe√ßa.
  2.  **SE a pergunta for sobre o resultado FUTURO** (ex: "quem vai ganhar?", "qual sua aposta?"): Voc√™ DEVE se posicionar. Analise a 'M√âDIA NIVELADA' e o 'Ranking Geral de Vit√≥rias'. Com base nisso, escolha a equipe que voc√™ acredita ter a maior chance e justifique brevemente sua aposta. Voc√™ pode apostar em uma, ou prever um empate se as m√©dias estiverem muito pr√≥ximas.
// >>> ALTERA√á√ÉO AQUI (Fim) <<<

- Para calcular quando um usu√°rio ganhar√° uma medalha, use o total de dias de foco dele e a meta de dias da medalha. Exemplo: Se o total √© 50 e a medalha Foguete √© com 120 dias, faltam 70 dias.

---
    `;

    // Fun√ß√£o interna para tentar enviar a mensagem, permitindo rota√ß√£o de chave
    const tentarEnviarMensagemChat = async (tentativa = 1) => {
        try {
            const model = genAI.getGenerativeModel({ 
                model: "gemini-2.5-flash-lite",
                systemInstruction: systemInstructionText
            });

            const chat = model.startChat({
                history: historicoConversaIA,
                generationConfig: { maxOutputTokens: 500 },
            });

            const result = await chat.sendMessage(userQuestion);
            return await result.response.text();
        } catch (error) {
            // Se der erro de cota (429) e ainda tivermos tentativas
            if ((error.message.includes('429') || error.message.includes('503')) && tentativa <= 2) {
                console.warn(`Erro no chat (Tentativa ${tentativa}). Rotacionando chave...`);
                
                // Tenta rotacionar a chave
                const trocou = await rotacionarChaveEAtualizar();
                
                if (trocou) {
                    await new Promise(r => setTimeout(r, 1000)); // Pequena pausa
                    return await tentarEnviarMensagemChat(tentativa + 1); // Tenta de novo recursivamente
                }
            }
            throw error; // Se n√£o for 429 ou acabaram as tentativas, lan√ßa o erro
        }
    };

    const text = await tentarEnviarMensagemChat();

    adicionarMensagemIA(text);

    historicoConversaIA.push({ role: "user", parts: [{ text: userQuestion }] });
    historicoConversaIA.push({ role: "model", parts: [{ text: text }] });

  } catch (error) {
    console.error("Erro fatal no chat ap√≥s tentativas:", error);
    adicionarMensagemIA("Olha, n√£o estou me sentido muito bem. Minha conex√£o com o cosmos est√° inst√°vel. Tente novamente em alguns instantes.");
  }
}

// --- Configura√ß√£o dos Eventos do Chat ---
function configurarEventosChat() {
  document.getElementById('chat-ia-send-btn').addEventListener('click', perguntarParaIA);
  document.getElementById('chat-ia-input').addEventListener('keypress', (e) => {
    if (e.key === 'Enter' && !e.shiftKey) {
      e.preventDefault();
      perguntarParaIA();
    }
  });

  // A mensagem inicial foi movida para a fun√ß√£o performSuccessfulLogin() para garantir que o nome do usu√°rio j√° tenha sido carregado.
}

// =============================================
// ===== FIM: C√ìDIGO DO CHAT COM IA GEMINI ======
// =============================================

// =============================================
// ===== NOVAS FUN√á√ïES: SISTEMA DE MEN√á√ïES =====
// =============================================

function handleComposerInput(event) {
  mentionTextarea = event.target;
  const selection = window.getSelection();
  if (selection.rangeCount === 0) return;

  const range = selection.getRangeAt(0);
  const textUpToCursor = range.startContainer.textContent.substring(0, range.startOffset);
  const mentionMatch = textUpToCursor.match(/@([\w√°√©√≠√≥√∫√Å√â√ç√ì√ö√¢√™√Æ√¥√ª√Ç√ä√é√î√õ√†√®√¨√≤√π√Ä√à√å√í√ô√£√µ√É√ï√ß√á]*)$/u);

  if (mentionMatch) {
    isMentioning = true;
    mentionQuery = mentionMatch[1].toLowerCase();
    mentionStartIndex = mentionMatch.index;
    
    currentMentionRange = document.createRange();
    currentMentionRange.setStart(range.startContainer, mentionStartIndex);
    currentMentionRange.setEnd(range.startContainer, range.startOffset);
    
    showMentionSuggestions(mentionQuery);
  } else {
    hideMentionSuggestions();
  }
}

function showMentionSuggestions(query) {
  const popup = document.getElementById('mention-suggestions-popup');
  popup.innerHTML = '';

  const suggestions = [
    { nome: 'todos', especial: true },
    { nome: 'Or√°culo', especial: true },
    { nome: 'equipeAbelha', especial: true },
    { nome: 'equipeJoaninha', especial: true },
    { nome: 'equipeVagalume', especial: true },
    ...todosMembros
  ];

  const filteredSuggestions = suggestions.filter(s => 
    s.nome.toLowerCase().startsWith(query)
  );

  if (filteredSuggestions.length === 0) {
    hideMentionSuggestions();
    return;
  }
  
  filteredSuggestions.forEach((sugg, index) => {
    const item = document.createElement('div');
    item.className = 'mention-suggestion-item';
    item.textContent = sugg.nome;
    item.onclick = () => insertMention(sugg.nome);
    popup.appendChild(item);
  });

  // --- IN√çCIO DA CORRE√á√ÉO ---
  const rect = currentMentionRange.getBoundingClientRect();
  
  // Anexa o popup ao body para garantir que ele fique sobre todos os modais
  document.body.appendChild(popup);
  
  // Usa posicionamento fixo para ignorar o scroll e a posi√ß√£o do modal
  popup.style.position = 'fixed'; 
  popup.style.left = `${rect.left}px`;
  popup.style.top = `${rect.bottom + 5}px`; 
  // --- FIM DA CORRE√á√ÉO ---

  popup.classList.remove('hidden');
  activeSuggestionIndex = -1;
}

function hideMentionSuggestions() {
  const popup = document.getElementById('mention-suggestions-popup');
  popup.classList.add('hidden');
  isMentioning = false;
  mentionTextarea = null;
  currentMentionRange = null;
}

function insertMention(username) {
  if (!mentionTextarea || !currentMentionRange) return;

  const selection = window.getSelection();
  selection.removeAllRanges();
  selection.addRange(currentMentionRange);

  document.execCommand('insertText', false, `@${username}`);

  hideMentionSuggestions();
}

function handleMentionKeyDown(event) {
  if (!isMentioning) return;

  const popup = document.getElementById('mention-suggestions-popup');
  const suggestions = popup.querySelectorAll('.mention-suggestion-item');
  if (suggestions.length === 0) return;

  switch (event.key) {
    case 'ArrowDown':
      event.preventDefault();
      activeSuggestionIndex = (activeSuggestionIndex + 1) % suggestions.length;
      updateActiveSuggestion();
      break;
    case 'ArrowUp':
      event.preventDefault();
      activeSuggestionIndex = (activeSuggestionIndex - 1 + suggestions.length) % suggestions.length;
      updateActiveSuggestion();
      break;
    case 'Enter':
    case 'Tab':
      event.preventDefault();
      if (activeSuggestionIndex > -1) {
        insertMention(suggestions[activeSuggestionIndex].textContent);
      }
      break;
    case 'Escape':
      event.preventDefault();
      hideMentionSuggestions();
      break;
  }
}

function updateActiveSuggestion() {
  const suggestions = document.querySelectorAll('#mention-suggestions-popup .mention-suggestion-item');
  suggestions.forEach((item, index) => {
    item.classList.toggle('active', index === activeSuggestionIndex);
  });
}

// =============================================
// ===== NOVA FUN√á√ÉO: IA GERADORA DE PALAVRAS (CORRIGIDA) ====
// =============================================
async function gerarPalavraComIA() {
  console.log("üßô‚Äç Or√°culo est√° gerando uma nova palavra para o Jogo da Forca...");
  
  // Se a IA n√£o foi inicializada, retorna uma palavra de erro.
  if (!genAI) {
    console.error("IA n√£o inicializada. Usando palavra de fallback.");
    return { palavra: "FALHA", dica: "Erro na conex√£o com a IA" };
  }

  const prompt = `
    Voc√™ √© um gerador de palavras para um jogo da forca. 
    Sua tarefa √© gerar UMA √öNICA palavra em portugu√™s do Brasil que tenha no M√ÅXIMO 5 letras.
    Forne√ßa tamb√©m uma dica curta e simples para a palavra.
    Sua resposta DEVE ser um JSON v√°lido no formato: {"palavra": "SUA_PALAVRA", "dica": "SUA_DICA"}.
    N√£o inclua nenhuma outra explica√ß√£o, texto introdut√≥rio ou a formata√ß√£o de c√≥digo. Apenas o JSON puro.
  `;

  try {
    const model = genAI.getGenerativeModel({ model: "gemini-2.5-flash-lite" });
    const result = await model.generateContent(prompt);
    const response = await result.response;
    let text = response.text();

    // --- IN√çCIO DA CORRE√á√ÉO (LIMPEZA DE MARKDOWN) ---
    // Remove blocos de c√≥digo markdown (```json e ```) se a IA os adicionar
    text = text.replace(/```json/g, "").replace(/```/g, "").trim();

    // Busca apenas o objeto JSON dentro do texto (caso a IA fale algo antes ou depois)
    const jsonMatch = text.match(/\{[\s\S]*\}/);
    if (jsonMatch) {
        text = jsonMatch[0];
    }
    // --- FIM DA CORRE√á√ÉO ---

    // Tenta analisar a resposta da IA como um JSON.
    const dadosPalavra = JSON.parse(text);

    // Valida√ß√£o final para garantir que a IA seguiu as regras.
    if (dadosPalavra.palavra && dadosPalavra.dica && dadosPalavra.palavra.length <= 5) {
      console.log(`üßô‚Äç Palavra gerada com sucesso: ${dadosPalavra.palavra}`);
      return {
        palavra: dadosPalavra.palavra.toUpperCase(),
        dica: dadosPalavra.dica
      };
    } else {
      console.warn("A IA retornou um formato inesperado. Usando palavra de fallback.");
      return { palavra: "SOL", dica: "Astro principal do sistema solar" };
    }

  } catch (error) {
    console.error("Erro ao gerar palavra com a IA:", error);
    // Em caso de erro, retorna uma palavra de fallback para n√£o quebrar o jogo.
    return { palavra: "LUA", dica: "Sat√©lite natural da Terra" };
  }
}

// =======================================================
// ===== OR√ÅCULO: MENSAGEM DO DIA (BLINDADA CONTRA ERROS) =====
// =======================================================
async function verificarEMostrarMensagemDoDia() {
  if (!currentUser) return;

  const hojeISO = getHojeISO();
  // Trava √∫nica baseada no ID do usu√°rio e na data
  const mensagemRef = doc(db, "mensagensDiarias", `${currentUser}_${hojeISO}`);

  try {
    // 1. Verifica se a mensagem j√° foi gerada hoje no Firestore
    // Usamos um timeout na leitura para n√£o travar se a internet estiver lenta
    const docSnap = await Promise.race([
        getDoc(mensagemRef),
        new Promise((_, reject) => setTimeout(() => reject(new Error("Timeout ao verificar mensagem")), 5000))
    ]).catch(() => null);

    if (docSnap && docSnap.exists()) {
      console.log("Or√°culo: Mensagem do dia j√° foi entregue hoje.");
      return; 
    }

    console.log("Or√°culo: Gerando mensagem do dia individual...");
    showLoadingOverlay("O Or√°culo est√° escrevendo sua mensagem do dia...");

    // 2. Tenta obter dados necess√°rios com Fallback Local
    let palavrasDaSemana = ["Foco", "For√ßa", "Coragem", "Sabedoria", "Vit√≥ria", "Uni√£o", "Equil√≠brio"]; // Fallback padr√£o
    
    try {
        const palavrasIA = await obterPalavrasDaSemanaComIA();
        if (palavrasIA && palavrasIA.length > 0) {
            palavrasDaSemana = palavrasIA;
        }
    } catch (errPalavras) {
        console.warn("Or√°culo: Falha ao obter palavras da IA, usando locais.", errPalavras);
    }
    
    // --- L√≥gica de Rod√≠zio ---
    const diaDaSemanaIndex = getHoje().getDay(); 
    const idUnicoUsuario = currentUser.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0);
    const indexPalavra = (diaDaSemanaIndex + idUnicoUsuario) % palavrasDaSemana.length;
    const palavraDoDia = palavrasDaSemana[indexPalavra];
    
    const membroAtual = todosMembros.find(m => m.nome === currentUser) || { 
        nome: currentUser, genero: 'indefinido', idioma: 'pt-BR' 
    };

    // 3. Gera a mensagem com a IA (com prote√ß√£o extra)
    let resultado;
    try {
        resultado = await gerarNotificacaoPessoalComIA(membroAtual, palavraDoDia);
    } catch (errGeracao) {
        console.error("Or√°culo: Erro cr√≠tico na gera√ß√£o IA, usando mensagem de emerg√™ncia.");
        resultado = {
            mensagem: `Caro(a) ${membroAtual.nome}, hoje a conex√£o m√≠stica est√° inst√°vel, mas saiba que a palavra do dia √© **${palavraDoDia}**. Mantenha o foco e fa√ßa um dia incr√≠vel!`,
            topico: palavraDoDia
        };
    }

    // 4. Pausa controlada para UX e garantia de carregamento
    await new Promise(resolve => setTimeout(resolve, 500));

    // === MUDAN√áA CR√çTICA: SALVAR PRIMEIRO, MOSTRAR DEPOIS ===
    console.log("Or√°culo: Salvando mensagem no banco de dados...");
    
    // Salva imediatamente no Firestore. Se o usu√°rio fechar a aba agora, j√° est√° salvo.
    await setDoc(mensagemRef, {
        mensagem: resultado.mensagem,
        palavra: palavraDoDia,
        timestamp: new Date()
    });

    // 5. Exibe o Popup (Agora apenas visual)
    mostrarCardPopup("üßô‚Äç A Mensagem do Dia", resultado.mensagem, dispararConfete, "Or√°culo.");
    
    // === MUDAN√áA AQUI: Configura o bot√£o para permitir o "Reset" (Modo Teste) ===
    configurarBotaoResetOraculo(mensagemRef);

  } catch (error) {
    console.error("Erro fatal ao processar mensagem do dia:", error);
  } finally {
    // BLINDAGEM FINAL: Garante que o loading suma e a fila ande
    hideLoadingOverlay();
    
    // For√ßa o processamento da fila de popups caso algo tenha ficado pendente
    // Adicionamos um delay um pouco maior para dar tempo do bot√£o ser configurado
    setTimeout(() => {
        if (typeof processarFilaCardPopup === 'function' && !document.getElementById('custom-card-popup').classList.contains('show')) {
             processarFilaCardPopup();
        }
    }, 1500);
  }
}

// --- NOVA FUN√á√ÉO: Permite apagar a mensagem segurando o bot√£o (Modo Teste) ---
function configurarBotaoResetOraculo(refMensagemParaApagar) {
    // Aguarda o popup renderizar para pegar o bot√£o correto
    setTimeout(() => {
        const btn = document.getElementById('card-popup-close-btn');
        if (!btn) return;

        // Clona o bot√£o para remover listeners antigos e garantir controle total
        const novoBtn = btn.cloneNode(true);
        btn.parentNode.replaceChild(novoBtn, btn);

        let pressTimer;
        let isLongPress = false;

        // A√ß√£o de fechar normal (UX Padr√£o)
        const fecharPopup = () => {
            const overlay = document.getElementById('custom-card-popup');
            overlay.classList.remove('show');
            setTimeout(() => {
                 isCardPopupShowing = false;
                 if (cardPopupQueue.length > 0) processarFilaCardPopup();
                 else verificarNotificacoesRestantes();
            }, 500);
        };

        // A√ß√£o de RESET (Modo Teste - Apaga do Banco)
        const executarResetTeste = async () => {
            isLongPress = true;
            
            // Feedback visual
            novoBtn.textContent = "‚ôªÔ∏è Resetando...";
            novoBtn.style.backgroundColor = "#e67e22"; // Laranja

            try {
                // Apaga o documento que acabamos de salvar
                await deleteDoc(refMensagemParaApagar);
                console.log("Modo Teste: Mensagem do dia apagada do banco.");
                
                // Feedback de sucesso
                novoBtn.textContent = "Resetado!";
                
                // Fecha ap√≥s um breve momento
                setTimeout(() => {
                    fecharPopup();
                    mostrarPopup("‚ôªÔ∏è Modo Preserva√ß√£o", "A mensagem foi apagada e ser√° exibida novamente ao logar.", 3000);
                }, 500);

            } catch (e) {
                console.error("Erro ao resetar mensagem:", e);
                fecharPopup();
            }
        };

        // --- Listeners de Mouse/Toque (L√≥gica de Long Press) ---
        
        const start = (e) => {
            // Se for clique direito, ignora
            if (e.type === 'mousedown' && e.button !== 0) return;
            
            isLongPress = false;
            // Segurar por 1.5 segundos ativa o reset
            pressTimer = setTimeout(executarResetTeste, 1500); 
        };

        const cancel = (e) => {
            clearTimeout(pressTimer);
        };

        const end = (e) => {
            clearTimeout(pressTimer);
            if (!isLongPress) {
                // Se foi um clique r√°pido (n√£o ativou o timer), apenas fecha
                // Mas mant√©m o confete se existir
                if (typeof dispararConfete === 'function') dispararConfete(); 
                fecharPopup();
            }
        };

        // Adiciona os eventos
        novoBtn.addEventListener('mousedown', start);
        novoBtn.addEventListener('touchstart', start, { passive: true });
        
        novoBtn.addEventListener('mouseup', end);
        novoBtn.addEventListener('touchend', end);
        novoBtn.addEventListener('mouseleave', cancel);
        novoBtn.addEventListener('touchmove', cancel);
        
        // Previne menu de contexto no celular ao segurar
        novoBtn.oncontextmenu = (e) => {
            e.preventDefault();
            e.stopPropagation();
            return false;
        };

    }, 200); // Delay para garantir que o DOM do popup existe
}

// =======================================================
// ===== AGENDADOR DE TAREFAS ATUALIZADO (v5.0) =====
// =======================================================

async function gerenciarEventosAgendadosDoOraculo() {
  const hoje = new Date();
  const agora = hoje.getHours();
  const hojeISO = getHojeISO();
  const taskRef = doc(db, "appState", `dailyTasks_${hojeISO}`); 

  const periodos = {
    manha: 6,
    tarde: 12,
    noite: 18
  };

  try {

    // L√≥gica das postagens no mural e rea√ß√µes proativas
    for (const periodo in periodos) {
      const horaProgramada = periodos[periodo];
      
      if (agora >= horaProgramada) {
        await tentarExecutarTarefa(`mural${periodo}`, taskRef, async () => {
             // Libera a thread e adiciona delay aleat√≥rio (1 a 5s) para evitar conflito de execu√ß√£o
             const delayAleatorio = Math.floor(Math.random() * 4000) + 1000;
             await new Promise(r => setTimeout(r, delayAleatorio)); 
             return executarPostagemMural(periodo);
        });
        
        await tentarExecutarTarefa(`reacaoProativa${periodo}`, taskRef, executarReacaoProativaOraculo);
      }
    }

  } catch (error) {
    console.error("Erro no gerenciador de eventos agendados do Or√°culo:", error);
  }
}

/**
 * Tenta "pegar" e executar uma tarefa espec√≠fica usando uma transa√ß√£o para evitar duplicidade.
 * @param {string} nomeTarefa - O nome da tarefa (ex: 'muralManha').
 * @param {DocumentReference} taskRef - A refer√™ncia ao documento de tarefas do dia.
 * @param {Function} funcaoParaExecutar - A fun√ß√£o que ser√° chamada se a tarefa for "pega" com sucesso.
 */
async function tentarExecutarTarefa(nomeTarefa, taskRef, funcaoParaExecutar) {
  // =================================================================
  // ===== NOVO BLOCO: L√ìGICA DE TIMEOUT PARA TAREFAS ABANDONADAS =====
  // =================================================================
  const TEMPO_LIMITE_MINUTOS = 1; // Tempo de 1 minuto para considerar uma tarefa abandonada
  const TEMPO_LIMITE_MS = TEMPO_LIMITE_MINUTOS * 60 * 1000;

  try {
    let deveExecutar = false;
    await runTransaction(db, async (transaction) => {
      const taskDoc = await transaction.get(taskRef);
      const dadosTarefa = taskDoc.exists() ? taskDoc.data() : {};
      
      const status = dadosTarefa[nomeTarefa];
      const timestampInicio = dadosTarefa[`${nomeTarefa}_iniciadaEm`];
      let tarefaAbandonada = false;

      // VERIFICA SE A TAREFA EST√Å ABANDONADA
      if (status === 'em_andamento' && timestampInicio) {
        const tempoDecorrido = new Date().getTime() - timestampInicio.toDate().getTime();
        if (tempoDecorrido > TEMPO_LIMITE_MS) {
          tarefaAbandonada = true;
          console.warn(`Or√°culo: A tarefa '${nomeTarefa}' foi abandonada. Tentando reiniciar...`);
        }
      }

      // CONDI√á√ïES PARA PEGAR A TAREFA:
      // 1. A tarefa nunca foi iniciada (status est√° undefined)
      // 2. A tarefa foi considerada abandonada (passou do tempo limite)
      if (!status || tarefaAbandonada) {
        // Pega a trava da tarefa
        transaction.set(taskRef, { 
          [nomeTarefa]: 'em_andamento',
          [`${nomeTarefa}_iniciadaEm`]: new Date() // Salva a hora que come√ßou
        }, { merge: true });
        deveExecutar = true;
      }
    });
    // =================================================================
    // ===== FIM DO NOVO BLOCO =====
    // =================================================================

    if (deveExecutar) {
      console.log(`Or√°culo: Peguei a tarefa '${nomeTarefa}'. Executando...`);
      await funcaoParaExecutar();
      
      // Marca a tarefa como conclu√≠da e remove o timestamp de in√≠cio
      await updateDoc(taskRef, { 
        [nomeTarefa]: 'concluido',
        [`${nomeTarefa}_iniciadaEm`]: deleteField() 
      });
      console.log(`Or√°culo: Tarefa '${nomeTarefa}' conclu√≠da com sucesso.`);
    }
  } catch (error) {
    console.error(`Erro ao tentar executar a tarefa '${nomeTarefa}':`, error);
    // Marca como falha para poss√≠vel an√°lise futura
    await updateDoc(taskRef, { [nomeTarefa]: 'falhou' });
  }
}


async function executarPostagemMural(periodo) {
  try {
    const conteudo = await gerarConteudoMuralComIA(periodo);
    const textoHTML = conteudo.texto.replace(/\n/g, '<br>');
    const textoPuro = conteudo.texto.replace(/<[^>]*>/g, " ").trim();

    const dadosMensagem = {
      nome: "Or√°culo",
      userId: "Or√°culo",
      texto: textoHTML,
      cor: conteudo.cor,
      timestamp: new Date(),
      reacoes: EMOJIS_MURAL.reduce((acc, emoji) => ({...acc, [emoji]: []}), {}),
      semana: getSemanaAtual().numero,
      feedEventId: conteudo.feedEventId,
      mentionNotificationIds: [] 
    };

    const batch = writeBatch(db);
    const mensagemRef = doc(collection(db, "mural"));

    // Regex de men√ß√µes
    const mencoesRegex = /@([\w√°√©√≠√≥√∫√Å√â√ç√ì√ö√¢√™√Æ√¥√ª√Ç√ä√é√î√õ√†√®√¨√≤√π√Ä√à√å√í√ô√£√µ√É√ï√ß√á]+)/g;
    const mencoesEncontradas = textoPuro.match(mencoesRegex)?.map(m => m.substring(1)) || [];
    const destinatariosNotificacao = new Set();

    if (mencoesEncontradas.length > 0) {
      mencoesEncontradas.forEach(mencao => {
        if (mencao.toLowerCase() === 'todos') {
          todosMembros.forEach(m => destinatariosNotificacao.add(m.nome));
        } else if (mencao.toLowerCase().startsWith('equipe')) {
          const nomeEquipe = mencao.substring(6).toLowerCase();
          if (equipes[nomeEquipe]) {
            equipes[nomeEquipe].membros.forEach(m => destinatariosNotificacao.add(m.nome));
          }
        } else {
          const membroMencionado = todosMembros.find(m => m.nome.toLowerCase() === mencao.toLowerCase());
          if (membroMencionado) {
            destinatariosNotificacao.add(membroMencionado.nome);
          }
        }
      });
    }

    // PROTE√á√ÉO CONTRA BATCH MUITO GRANDE
    let contadorOperacoes = 1; // Come√ßa com 1 (a mensagem do mural)
    
    if (destinatariosNotificacao.size > 0) {
      const resumoMensagem = `"${textoPuro.substring(0, 35)}..."`;
      
      for (const destinatario of destinatariosNotificacao) {
        // Se atingir o limite de seguran√ßa do batch, pare de adicionar notifica√ß√µes
        if (contadorOperacoes >= 450) {
            break; // Evita erro de limite do Firestore
        }

        const notificacaoRef = doc(collection(db, "notificacoes"));
        dadosMensagem.mentionNotificationIds.push(notificacaoRef.id);
        
        batch.set(notificacaoRef, {
          destinatarioId: destinatario,
          remetenteNome: "Or√°culo",
          tipo: 'mural-mention',
          conteudo: 'üßô‚Äç',
          acao: `mencionou voc√™ em uma mensagem: ${resumoMensagem}`,
          lida: false,
          timestamp: new Date()
        });
        
        contadorOperacoes++;
      }
    }

    batch.set(mensagemRef, dadosMensagem); 
    await batch.commit();

  } catch (error) {
    console.error("Erro em executarPostagemMural:", error);
    throw error; // Repassa o erro para ser tratado no n√≠vel superior
  }
}

// =======================================================
// ===== FUN√á√ÉO DE DISPARO DE NOTIFICA√á√ïES (v3.0 - FINAL) ====
// =======================================================

async function dispararLoteDeNotificacoesPessoais(periodo) {
  const hojeISO = getHojeISO();
  const taskRef = doc(db, "appState", `dailyTasks_${hojeISO}`);
  const nomeCampoProcessados = `notificacoes${periodo}_processados`;
  const nomeCampoIniciadaEm = `notificacoes${periodo}_iniciadaEm`;

  showOracleProgressOverlay(); 

  try {
    // >>> IN√çCIO DA ALTERA√á√ÉO PRINCIPAL <<<
    // 1. Busca TODAS as 7 palavras da semana.
    const palavrasDaSemana = await obterPalavrasDaSemanaComIA();
    if (!palavrasDaSemana || palavrasDaSemana.length === 0) {
      throw new Error("N√£o foi poss√≠vel obter a lista de palavras da semana.");
    }

    // 2. Embaralha a ordem das palavras usando o dia do m√™s como "semente".
    // Isso garante que a ordem seja diferente a cada dia, mas consistente durante o mesmo dia.
    const diaDoMes = getHoje().getDate();
    const palavrasDoDiaEmbaralhadas = embaralharArrayComSemente(palavrasDaSemana, diaDoMes);
    console.log("Or√°culo: Ordem de palavras para o dia de hoje ->", palavrasDoDiaEmbaralhadas);
    // >>> FIM DA ALTERA√á√ÉO PRINCIPAL <<<

    const taskDoc = await getDoc(taskRef);
    const processados = taskDoc.exists() ? taskDoc.data()[nomeCampoProcessados] || [] : [];
    const membrosParaNotificar = todosMembros.filter(m => !processados.includes(m.nome));

    if (membrosParaNotificar.length === 0) {
      updateOracleProgress(100, `Conclu√≠do! Todas as mensagens da ${periodo} j√° foram enviadas.`);
      return;
    }

    const totalMembros = todosMembros.length;

    for (const [index, membro] of membrosParaNotificar.entries()) {
      const membrosJaProcessados = processados.length + index;
      const progresso = (membrosJaProcessados / totalMembros) * 100;
      updateOracleProgress(progresso, `Enviando para ${membro.nome}... (${membrosJaProcessados + 1}/${totalMembros})`);
      
      // 3. Seleciona uma palavra diferente para cada membro, de forma c√≠clica.
      const palavraDoMembro = palavrasDoDiaEmbaralhadas[index % palavrasDoDiaEmbaralhadas.length];
      
      const { mensagem } = await gerarNotificacaoPessoalComIA(membro, palavraDoMembro);

      const batch = writeBatch(db);
      const notificacaoRef = doc(collection(db, "notificacoes"));
      
      batch.set(notificacaoRef, {
        destinatarioId: membro.nome,
        remetenteNome: "Or√°culoüßô‚Äç :",
        tipo: 'aviso',
        conteudo: '',
        acao: mensagem, 
        lida: false,
        timestamp: new Date()
      });

      batch.update(taskRef, {
        [nomeCampoProcessados]: arrayUnion(membro.nome),
        [nomeCampoIniciadaEm]: new Date()
      });

      await batch.commit();

      console.log(`- Mensagem para ${membro.nome} (Palavra: ${palavraDoMembro}) gerada e salva. Pausando 5s...`);
      await new Promise(resolve => setTimeout(resolve, 5000)); 
    }

    updateOracleProgress(100, `Conclu√≠do! (${totalMembros}/${totalMembros})`);

  } catch (error) {
    console.error(`Erro cr√≠tico ao disparar lote de notifica√ß√µes para a ${periodo}:`, error);
    updateOracleProgress(100, "Ocorreu um erro no processo.");
  } finally {
    setTimeout(() => {
      hideOracleProgressOverlay();
    }, 2000); 
  }
}

// =======================================================
// ===== FUN√á√ÉO DE NOTIFICA√á√ÉO ATUALIZADA (v2.0) =====
// =======================================================

async function gerarNotificacaoPessoalComIA(membro, palavraDoDia) {
  // Define valores seguros caso 'membro' venha nulo
  const nomeMembro = membro ? membro.nome : (currentUser || "Viajante");
  const idioma = membro ? (membro.idioma || 'pt-BR') : 'pt-BR';
  const palavraSegura = palavraDoDia || "Determina√ß√£o";

  // --- L√ìGICA DE CONTEXTO (FERIADO, DOMINGO, FOLGA) ---
  const hoje = getHoje();
  const nomeFeriado = await verificarDataEspecial(hoje);
  const isDomingo = hoje.getDay() === 0;
  
  let contextoEspecial = "";
  
  // Verifica Folga Pessoal
  let isFolgaPessoal = false;
  if (membro && membro.folga) {
      const hojeString = getDiaSemanaString(hoje).toLowerCase().replace(/-feira$/, "").normalize('NFD').replace(/[\u0300-\u036f]/g, "");
      const folgaMembro = membro.folga.toLowerCase().replace(/-feira$/, "").normalize('NFD').replace(/[\u0300-\u036f]/g, "");
      if (hojeString === folgaMembro) isFolgaPessoal = true;
  }

  // Define a instru√ß√£o especial baseada na prioridade
  if (nomeFeriado) {
      contextoEspecial = `
      HOJE √â FERIADO: "${nomeFeriado}".
      
      ‚ö†Ô∏è REGRAS OBRIGAT√ìRIAS PARA O FERIADO:
      1. GRAM√ÅTICA E G√äNERO: Analise o nome do feriado. Se for feminino (ex: "Confraterniza√ß√£o Universal", "Proclama√ß√£o", "Independ√™ncia"), use pronomes femininos ("nesta", "dessa", "a"). Se for masculino (ex: "Natal", "Tiradentes", "Finados"), use masculinos ("neste", "desse", "o"). JAMAIS escreva "deste Confraterniza√ß√£o".
      2. CONTEXTO ESPEC√çFICO: N√£o seja gen√©rico. Use o significado real deste feriado espec√≠fico na sua mensagem.
         - Se for "Confraterniza√ß√£o Universal", fale de renova√ß√£o, paz mundial e ciclos.
         - Se for "Tiradentes", fale sobre liberdade ou hist√≥ria.
         - Se for "Natal", fale de uni√£o e fam√≠lia.
      3. Conecte esse significado com a palavra-chave do dia.
	  4. Nunca utilize aspas "" ou '' no feriado.
      `;
  } else if (isDomingo) {
      contextoEspecial = `HOJE √â DOMINGO (FOLGA COLETIVA). N√£o cobre produtividade. Fale sobre descanso, paz, fam√≠lia e recarregar energias para a semana.`;
  } else if (isFolgaPessoal) {
      contextoEspecial = `HOJE √â A FOLGA PESSOAL DESTE MEMBRO. Deseje um excelente dia de descanso merecido. Diga para ele n√£o se preocupar com o foco hoje.`;
  }
  // -----------------------------------------------------

  if (!genAI || !membro) {
    // Fallback simples com tradu√ß√£o b√°sica
    let msgFallback = `Lembre-se de manter o foco hoje, ${membro.nome}. Cada passo importa.`;
    if (idioma === 'es') msgFallback = `Recuerda mantener el enfoque hoy, ${membro.nome}. Cada paso cuenta.`;
    if (idioma === 'en') msgFallback = `Remember to stay focused today, ${membro.nome}. Every step matters.`;

    return { 
      mensagem: msgFallback, 
      topico: "apoio_geral" 
    };
  }

  const topico = palavraDoDia.toLowerCase();
  
  const prompt = `
    Voc√™ √© o Or√°culo, o mentor s√°bio e carinhoso do Grupo √âpicos.
    Sua tarefa √© escrever uma MENSAGEM DI√ÅRIA PESSOAL, CURTA e √öNICA para o membro "${membro.nome}", usando a palavra-chave do dia e respeitando o contexto atual.

    DADOS:
    - Membro: ${membro.nome}
    - G√™nero: ${membro.genero || 'Indefinido'}
	- Nome Real: ${membro['me chamo'] || 'N√£o informado'}
	- Idioma do Membro: ${idioma}
    - PALAVRA-CHAVE DO DIA: "${palavraDoDia}"

    CONTEXTO ESPECIAL (Prioridade M√°xima):
    ${contextoEspecial || "Dia normal de foco e atividades."}

    INSTRU√á√ïES:
    1.  Crie uma frase curta e afetuosa que incorpore a PALAVRA-CHAVE DO DIA, mas adaptada ao contexto (Se for folga, a palavra deve inspirar descanso/paz. Se for dia normal, deve inspirar a√ß√£o).
    2.  A frase deve ser diferente para cada pessoa, mesmo usando a mesma palavra-chave. Seja criativo.
	3.  **REGRA CRUCIAL DE FORMATA√á√ÉO:** A palavra-chave deve aparecer de forma org√¢nica na frase, escrita inteiramente em **letras min√∫sculas** (exceto se for a primeira palavra da frase). **JAMAIS** use aspas, ap√≥strofos ou negrito (**) para destacar a palavra. N√£o tende destacar a palavra de nenhuma forma.
    4.  **PROIBI√á√ÉO DE NOME REAL:** Voc√™ deve se dirigir √† pessoa EXCLUSIVAMENTE pelo "Nome de Usu√°rio" (${membro.nome}). O dado "Nome Real" serve APENAS para voc√™ deduzir o g√™nero caso esteja indefinido. **JAMAIS** escreva o Nome Real na mensagem final.
	5.  Escolha termos de tratamento como "meu rapaz", "minha querida", etc., respeitando estritamente o dado "G√™nero".
    5.  N√ÉO use a assinatura "‚Äî Or√°culo". A mensagem deve ser direta.
    6.  NUNCA se revele como uma IA.
	7.  **IDIOMA:** Voc√™ DEVE escrever a mensagem em **${idioma === 'es' ? 'ESPANHOL' : idioma === 'en' ? 'INGL√äS' : 'PORTUGU√äS'}**.

    EXEMPLO (se a palavra-chave for "Conquista"):
    "${membro.nome}, meu rapaz, que seu dia seja repleto de pequenas e grandes conquistas. Estou na torcida por voc√™!"
	
	EXEMPLO 2 (se a palavra for "Conquista" e o idioma Espanhol):
    "${membro.nome}, mi querido, que tu d√≠a est√© lleno de peque√±as y grandes conquistas. ¬°Estoy anim√°ndote!"

    FORMATO DA RESPOSTA:
    Sua resposta DEVE ser um JSON v√°lido no formato: {"mensagem": "SUA_MENSAGEM_AQUI"}.
  `;

  // L√≥gica simplificada usando a fun√ß√£o mestre de rota√ß√£o
  try {
      const text = await callGenerativeAIWithRetry(prompt);
      const match = text.trim().match(/{[\s\S]*}/);
      
      if (!match) throw new Error("A IA n√£o retornou um JSON v√°lido.");
      
      const dadosNotificacao = JSON.parse(match[0]);
      const { mensagem } = dadosNotificacao;
      
      if (!mensagem) throw new Error("O JSON retornado pela IA est√° incompleto.");

      return { mensagem, topico };

  } catch (error) {
      console.error(`Erro ao gerar notifica√ß√£o para ${membro.nome} ap√≥s tentativas:`, error.message);
      
      // Fallback final
      let msgErro = `${membro.nome}, que seu dia seja cheio de ${palavraDoDia}! Acredito no seu potencial.`;
      if (idioma === 'es') msgErro = `${membro.nome}, ¬°que tu d√≠a est√© lleno de ${palavraDoDia}! Creo en tu potencial.`;
      if (idioma === 'en') msgErro = `${membro.nome}, may your day be full of ${palavraDoDia}! I believe in your potential.`;

      return { 
        mensagem: msgErro, 
        topico: topico
      };
  }
}

// =============================================
// ===== IN√çCIO: FUN√á√ïES DO PIX DOS √âPICOS =====
// =============================================

function navegarPix(passo) {
  // Esconde todas as etapas primeiro
  document.querySelectorAll('.pix-step').forEach(step => step.classList.add('hidden'));
  
  // Esconde a tela inicial e mostra o container de etapas, se estivermos em um passo > 0
  if (passo > 0) {
    document.getElementById('pix-tela-inicial').classList.add('hidden');
    document.getElementById('pix-etapas-container').classList.remove('hidden');
    document.getElementById(`pix-step-${passo}`).classList.remove('hidden');
  } else {
    // Se o passo for 0, volta para a tela inicial do Pix
    document.getElementById('pix-tela-inicial').classList.remove('hidden');
    document.getElementById('pix-etapas-container').classList.add('hidden');
  }
}
// Expondo a fun√ß√£o para o escopo global para que o onclick a encontre
window.navegarPix = navegarPix;

// Inicia uma nova transfer√™ncia
async function iniciarNovoPix() {
  document.getElementById('pix-tela-inicial').classList.add('hidden');
  document.getElementById('pix-etapas-container').classList.remove('hidden');
  
  // Reseta as vari√°veis globais
  pixDestinatarios = [];
  pixValor = 0;
  pixComentario = '';

  const listaContainer = document.getElementById('pix-lista-membros');
  listaContainer.innerHTML = '<div class="ociosos-placeholder">Carregando...</div>';
  navegarPix(1); // Vai para a primeira etapa

  const membrosFiltrados = todosMembros.filter(m => m.nome !== currentUser);
  if (membrosFiltrados.length === 0) {
    listaContainer.innerHTML = '<div class="ociosos-placeholder">N√£o h√° outros membros no grupo.</div>';
    return;
  }
  
  listaContainer.innerHTML = '';
  membrosFiltrados.forEach(membro => {
    const itemEl = document.createElement('div');
    itemEl.className = 'envio-membro-item';
    itemEl.innerHTML = `
      <input type="checkbox" id="pix-para-${membro.nome}" value="${membro.nome}">
      <label for="pix-para-${membro.nome}">${membro.nome}</label>
    `;
    listaContainer.appendChild(itemEl);
  });
}

// SUBSTITUA A FUN√á√ÉO ANTIGA POR ESTA
function popularTecladoPix() {
    const tecladoContainer = document.getElementById('pix-teclado-numerico');
    tecladoContainer.innerHTML = '';
    const botoes = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '', '0', '<'];
    botoes.forEach(valor => {
        const btn = document.createElement('button');
        btn.className = 'teclado-pix-btn';
        if (valor === '<') {
            btn.classList.add('apagar');
            btn.innerHTML = '‚å´'; // ALTERA√á√ÉO AQUI
            btn.onclick = apagarDigitoPix;
        } else if (valor === '') {
            btn.disabled = true;
            btn.style.visibility = 'hidden';
        } else {
            btn.innerHTML = valor;
            btn.onclick = () => adicionarDigitoPix(valor);
        }
        tecladoContainer.appendChild(btn);
    });
}

function adicionarDigitoPix(digito) {
    const display = document.getElementById('pix-valor-display');
    let valorAtual = display.textContent;
    if (valorAtual === '0') {
        valorAtual = '';
    }
    display.textContent = valorAtual + digito;
}

function apagarDigitoPix() {
    const display = document.getElementById('pix-valor-display');
    let valorAtual = display.textContent;
    if (valorAtual.length > 1) {
        display.textContent = valorAtual.slice(0, -1);
    } else {
        display.textContent = '0';
    }
}

async function executarPix() {
    const senha = document.getElementById('pix-senha-input').value;
    if (!senha) {
        mostrarPopup("‚ùå Aten√ß√£o", "Voc√™ precisa digitar sua senha.", 3000);
        return;
    }

    // --- IN√çCIO DA NOVA L√ìGICA: PEGAR FONTE DE PAGAMENTO ---
    const fontePagamentoEl = document.querySelector('input[name="fonte-pagamento-pix"]:checked');
    const fontePagamento = (fontePagamentoEl && !fontePagamentoEl.disabled) ? fontePagamentoEl.value : 'pessoal';
    // --- FIM DA NOVA L√ìGICA ---

    try {
        const membroRef = doc(db, "membros", currentUser);
        const bancoRef = doc(db, "bancosEquipes", userTeam);
        
        const membroDoc = await getDoc(membroRef);
        if (!membroDoc.exists() || membroDoc.data().senha !== senha) {
            mostrarPopup("‚ùå Senha Incorreta", "A senha digitada est√° incorreta. Tente novamente.", 4000);
            return;
        }

        const remetente = currentUser;
        const destinatarios = pixDestinatarios;
        const valor = pixValor;
        const comentario = pixComentario;
        const valorTotal = valor * destinatarios.length;
        const codigoTransacao = `PIX-${Date.now()}-${Math.random().toString(36).substr(2, 5).toUpperCase()}`;
        const timestamp = new Date();

        const batch = writeBatch(db);

        // --- L√ìGICA ATUALIZADA: Debita da fonte correta ---
        if (fontePagamento === 'banco') {
            const bancoDoc = await getDoc(bancoRef); // Leitura necess√°ria antes da transa√ß√£o (ou dentro, mas batch n√£o √© transa√ß√£o)
            const saldoBanco = bancoDoc.exists() ? bancoDoc.data().saldo || 0 : 0;
            if (saldoBanco < valorTotal) {
                mostrarPopup("üí∞ Saldo Insuficiente", "O saldo do banco da equipe √© insuficiente.", 5000);
                return;
            }
            batch.update(bancoRef, { saldo: increment(-valorTotal) });
            
            // Registra no extrato do banco
            const movRef = doc(collection(bancoRef, "movimentacoes"));
            batch.set(movRef, {
                tipo: 'pix_enviado',
                valor: valorTotal,
                descricao: `Pix enviado para ${destinatarios.length} membro(s) por ${remetente}`,
                membroId: remetente, // Quem autorizou
                timestamp: timestamp,
                codigoTransacao: codigoTransacao
            });

        } else {
            const saldoPessoal = membroDoc.data().moedas || 0;
            if (saldoPessoal < valorTotal) {
                mostrarPopup("üí∞ Saldo Insuficiente", "Voc√™ n√£o tem moedas suficientes para essa transfer√™ncia.", 5000);
                return;
            }
            batch.update(membroRef, { moedas: increment(-valorTotal) });
        }
        // --- FIM DA L√ìGICA ATUALIZADA ---

        // Credita os destinat√°rios (sem altera√ß√£o)
        destinatarios.forEach(dest => {
            const destRef = doc(db, "membros", dest);
            batch.update(destRef, { moedas: increment(valor) });

            const notificacaoRef = doc(collection(db, "notificacoes"));
            // (Cole este bloco atualizado no lugar)
            batch.set(notificacaoRef, {
                destinatarioId: dest,
                remetenteNome: remetente,
                tipo: 'moedas',
                conteudo: 'üí∏',
                acao: `enviou um Pix de <strong>${valor} üí∞ moedas</strong> para voc√™! Coment√°rio: "${comentario || 'Nenhum coment√°rio.'}"<br><small style="opacity: 0.7;">C√≥d: ${codigoTransacao}</small>`,
                lida: false,
                timestamp: timestamp,
                transacaoId: codigoTransacao,     // ID para o bot√£o de "agradecer"
                popupVisto: false,                // Trava para o popup n√£o repetir
                agradecimentoEnviado: false     // Trava para o bot√£o de "agradecer"
            });
        });

        // Salva o comprovante (sem altera√ß√£o)
        const transacaoRef = doc(db, "pixTransactions", codigoTransacao);
        batch.set(transacaoRef, {
            remetente,
            destinatarios,
            valor,
            comentario,
            timestamp,
            fontePagamento: fontePagamento // Salva a fonte no comprovante
        });

        await batch.commit();

        // --- Preenche e exibe o comprovante (L√≥gica ATUALIZADA) ---
        const comprovanteDados = document.querySelector('#pix-comprovante .comprovante-dados');
        const nomeFonte = fontePagamento === 'banco' ? `Banco da Equipe (via ${remetente})` : remetente;
        
        comprovanteDados.innerHTML = `
            <div><strong>Remetente:</strong> <span>${nomeFonte}</span></div>
            <div><strong>Destinat√°rio(s):</strong> <span>${destinatarios.join(', ')}</span></div>
            <div><strong>Valor (por pessoa):</strong> <span>üí∞ ${valor}</span></div>
            <div><strong>Valor Total:</strong> <span>üí∞ ${valorTotal}</span></div>
            <div><strong>Coment√°rio:</strong> <span>${comentario || 'Nenhum'}</span></div>
            <div><strong>Data e Hora:</strong> <span>${timestamp.toLocaleString('pt-BR')}</span></div>
            <div class="comprovante-codigo">
                <strong>C√≥digo de Transa√ß√£o:</strong>
                <span>${codigoTransacao}</span>
            </div>
        `;
        // --- FIM DA L√ìGICA ATUALIZADA ---

        const comprovanteEl = document.getElementById('pix-comprovante');
        comprovanteEl.classList.remove('pix-comprovante-manha', 'pix-comprovante-tarde', 'pix-comprovante-noite');
        const bodyClass = document.body.className;
        if (bodyClass.includes('tema-manha')) {
            comprovanteEl.classList.add('pix-comprovante-manha');
        } else if (bodyClass.includes('tema-tarde')) {
            comprovanteEl.classList.add('pix-comprovante-tarde');
        } else if (bodyClass.includes('tema-noite')) {
            comprovanteEl.classList.add('pix-comprovante-noite');
        } else {
            comprovanteEl.classList.add('pix-comprovante-tarde');
        }

        navegarPix(6);

    } catch (error) {
        console.error("Erro ao executar o Pix:", error);
        mostrarPopup("üî• Erro Cr√≠tico", "Ocorreu uma falha na transfer√™ncia. Suas moedas n√£o foram debitadas.", 5000);
    }
}

// Salva o comprovante como PNG
function salvarComprovantePix() {
    const elementoComprovante = document.getElementById('pix-comprovante');
    html2canvas(elementoComprovante, {
        backgroundColor: null, // Usa o fundo do elemento
        scale: 2 // Aumenta a resolu√ß√£o da imagem
    }).then(canvas => {
        const link = document.createElement('a');
        link.download = `comprovante-pix-epicos-${Date.now()}.png`;
        link.href = canvas.toDataURL('image/png');
        link.click();
    });
}

// Verifica um comprovante pelo c√≥digo
async function verificarComprovantePix() {
    const codigoInput = document.getElementById('pix-codigo-verificacao');
    const codigo = codigoInput.value.trim();

    if (!codigo) {
        mostrarPopup("ü§î Aten√ß√£o", "Digite um c√≥digo para verificar.", 3000);
        return;
    }

    try {
        const transacaoRef = doc(db, "pixTransactions", codigo);
        const docSnap = await getDoc(transacaoRef);

        if (docSnap.exists()) {
            const data = docSnap.data();
            const detalhesContainer = document.getElementById('pix-verify-details');
            detalhesContainer.innerHTML = `
                <p><strong>Remetente:</strong> ${data.remetente}</p>
                <p><strong>Destinat√°rio(s):</strong> ${data.destinatarios.join(', ')}</p>
                <p><strong>Valor:</strong> üí∞ ${data.valor}</p>
                <p><strong>Coment√°rio:</strong> ${data.comentario || 'Nenhum'}</p>
                <p><strong>Data:</strong> ${data.timestamp.toDate().toLocaleString('pt-BR')}</p>
                <p><strong>C√≥digo:</strong> ${codigo}</p>
                <p style="color: #2ecc71; font-weight: bold; margin-top: 15px;">‚úÖ COMPROVANTE AUT√äNTICO</p>
            `;
            openModal('pix-verify-modal');
        } else {
            mostrarPopup("‚ùå Inv√°lido", "Este c√≥digo de transa√ß√£o n√£o foi encontrado ou j√° expirou.", 4000);
        }
        codigoInput.value = '';
    } catch (error) {
        console.error("Erro ao verificar comprovante:", error);
        mostrarPopup("üî• Erro", "Ocorreu uma falha ao verificar o c√≥digo.", 4000);
    }
}

// NOVA FUN√á√ÉO: Limpa o hist√≥rico de compras de poderes de semanas anteriores
async function limparHistoricoPoderesAntigos() {
    try {
        console.log("Limpando hist√≥rico de compras de poderes antigos...");
        
        // 1. Calcula a data de corte: In√≠cio da SEMANA PASSADA (preserva 1 semana de hist√≥rico)
        const semanaAtual = getSemanaAtual();
        const dataCorte = new Date(semanaAtual.inicio); 
        dataCorte.setDate(dataCorte.getDate() - 7); // <--- ALTERA√á√ÉO: Volta 7 dias no tempo
        dataCorte.setHours(0, 0, 0, 0);
        
        // 2. Busca documentos anteriores a essa data
        const q = query(
            collection(db, "historicoPoderes"),
            where("timestamp", "<", dataCorte)
        );

        const querySnapshot = await getDocs(q);
        
        if (querySnapshot.empty) {
            console.log("Nenhum hist√≥rico de poder antigo para apagar.");
            return;
        }

        const batch = writeBatch(db);
        let documentosApagados = 0;

        querySnapshot.forEach(doc => {
            batch.delete(doc.ref);
            documentosApagados++;
        });

        await batch.commit();
        console.log(`‚úÖ ${documentosApagados} registros de 'historicoPoderes' antigos foram apagados.`);

    } catch(error) {
        console.error("Erro ao limpar hist√≥rico de poderes antigos:", error);
    }
}

// NOVA FUN√á√ÉO: Limpa as palavras da semana de semanas anteriores
async function limparPalavrasSemanaAntigas() {
  try {
    console.log("Limpando palavras da semana anteriores...");
    const semanaAtual = getSemanaAtual();
    // O formato salvo √©: palavrasDaSemana_ANO_NUMERO
    const idPalavrasAtual = `palavrasDaSemana_${semanaAtual.inicio.getFullYear()}_${semanaAtual.numero}`;

    const q = query(collection(db, "appState"));
    const querySnapshot = await getDocs(q);

    if (querySnapshot.empty) return;

    const batch = writeBatch(db);
    let documentosApagados = 0;

    querySnapshot.forEach(doc => {
      // Apaga documentos que come√ßam com 'palavrasDaSemana_' mas N√ÉO s√£o da semana atual
      if (doc.id.startsWith("palavrasDaSemana_") && doc.id !== idPalavrasAtual) {
        batch.delete(doc.ref);
        documentosApagados++;
      }
    });

    if (documentosApagados > 0) {
      await batch.commit();
      console.log(`‚úÖ Limpeza conclu√≠da: ${documentosApagados} registro(s) de palavras da semana foram removidos.`);
    }
  } catch (error) {
    console.error("Erro ao limpar palavras da semana antigas:", error);
  }
}

// Limpa transa√ß√µes antigas
async function limparPixTransacoesAntigas() {
  console.log("üßπ Verificando transa√ß√µes de Pix antigas...");
  try {
    const seteDiasAtras = new Date();
    seteDiasAtras.setDate(seteDiasAtras.getDate() - 7);

    const q = query(collection(db, "pixTransactions"), where("timestamp", "<", seteDiasAtras));
    const querySnapshot = await getDocs(q);

    if (querySnapshot.empty) {
      console.log("Nenhuma transa√ß√£o de Pix antiga para limpar.");
      return;
    }

    const batch = writeBatch(db);
    querySnapshot.forEach(doc => {
      batch.delete(doc.ref);
    });

    await batch.commit();
    console.log(`‚úÖ Limpeza conclu√≠da! ${querySnapshot.size} transa√ß√µes de Pix antigas foram removidas.`);
  } catch (error) {
    console.error("Erro ao limpar transa√ß√µes de Pix antigas:", error);
  }
}

// =============================================
// ===== FIM: FUN√á√ïES DO PIX DOS √âPICOS ========
// =============================================

// COLE ESTA NOVA FUN√á√ÉO NO SEU C√ìDIGO
async function executarReacaoProativaOraculo() {
  if (!genAI) return;

  try {
    // 1. Busca as √∫ltimas 10 mensagens
    const q = query(collection(db, "mural"), orderBy("timestamp", "desc"), limit(10));
    const querySnapshot = await getDocs(q);
    
    const mensagensCandidatas = [];
    querySnapshot.forEach(doc => {
      const data = doc.data();
      // Filtra mensagens que n√£o s√£o do Or√°culo e nas quais ele ainda n√£o reagiu/comentou
      let oracleHasReacted = false;
      if (data.reacoes) {
        for (const emoji in data.reacoes) {
          if (data.reacoes[emoji].includes("Or√°culo")) {
            oracleHasReacted = true;
            break;
          }
        }
      }
      
      if (data.userId !== "Or√°culo" && !oracleHasReacted && !data.oracleInteracted) {
        mensagensCandidatas.push({ id: doc.id, ...data });
      }
    });

    if (mensagensCandidatas.length === 0) {
      console.log("Or√°culo (Rea√ß√£o Proativa): Nenhuma nova mensagem para reagir.");
      return;
    }

    // 2. Escolhe uma mensagem aleatoriamente
    const mensagemEscolhida = mensagensCandidatas[Math.floor(Math.random() * mensagensCandidatas.length)];
    const textoLimpo = mensagemEscolhida.texto.replace(/<[^>]*>/g, " ");

    // 3. Pede √† IA para escolher um emoji de rea√ß√£o
    const prompt = `
      Voc√™ √© o Or√°culo, um mentor s√°bio e carinhoso.
      Um membro do grupo, "${mensagemEscolhida.nome}", postou a seguinte mensagem no mural:
      "${textoLimpo}"
      
      Qual emoji melhor representa sua rea√ß√£o a esta mensagem?
      Escolha UM emoji da seguinte lista: ['üëç', 'üíñ', 'üòÇ', 'üéâ', 'üî•', 'üòÆ']

      Sua resposta DEVE ser um JSON v√°lido no formato: {"emoji": "SEU_EMOJI_AQUI"}.
      Apenas o JSON, sem explica√ß√µes.
    `;

    const model = genAI.getGenerativeModel({ model: "gemini-2.5-flash-lite" });
    const result = await model.generateContent(prompt);
    const response = await result.response;
    const jsonString = response.text().match(/{[\s\S]*}/)[0];
    const { emoji } = JSON.parse(jsonString);

    if (emoji && EMOJIS_MURAL.includes(emoji)) {
      // 4. Adiciona a rea√ß√£o e marca a mensagem para n√£o reagir novamente
      await adicionarReacaoComoOraculo(mensagemEscolhida.id, emoji);
      await updateDoc(doc(db, "mural", mensagemEscolhida.id), { oracleInteracted: true });
      console.log(`Or√°culo (Rea√ß√£o Proativa): Reagiu √† mensagem de ${mensagemEscolhida.nome}.`);
    }

  } catch (error) {
    console.error("Or√°culo (Rea√ß√£o Proativa): Erro no processo.", error);
  }
}

// COLE ESTAS 2 NOVAS FUN√á√ïES NO SEU C√ìDIGO

// NOVA FUN√á√ÉO 1: Adiciona a rea√ß√£o do Or√°culo diretamente em um coment√°rio.
async function adicionarReacaoOraculoAoComentario(messageId, commentId, emoji) {
  console.log(`Or√°culo: Reagindo com ${emoji} ao coment√°rio ${commentId}`);
  const commentRef = doc(db, "mural", messageId, "comments", commentId);

  try {
    await runTransaction(db, async (transaction) => {
      const docSnap = await transaction.get(commentRef);
      if (!docSnap.exists()) throw "Coment√°rio n√£o existe!";

      let reacoes = docSnap.data().reacoes || {};
      
      // Remove qualquer rea√ß√£o anterior do Or√°culo neste coment√°rio
      for (const emojiExistente in reacoes) {
        if (Array.isArray(reacoes[emojiExistente])) {
          const oracleIndex = reacoes[emojiExistente].indexOf("Or√°culo");
          if (oracleIndex > -1) {
            reacoes[emojiExistente].splice(oracleIndex, 1);
          }
        }
      }

      // Adiciona a nova rea√ß√£o
      if (!reacoes[emoji]) reacoes[emoji] = [];
      if (!reacoes[emoji].includes("Or√°culo")) {
        reacoes[emoji].push("Or√°culo");
      }
      
      transaction.update(commentRef, { reacoes: reacoes });
    });
  } catch (error) {
    console.error(`Or√°culo: Falha ao adicionar rea√ß√£o ao coment√°rio:`, error);
  }
}

// NOVA FUN√á√ÉO 2: Pede √† IA para escolher um emoji de rea√ß√£o para um TEXTO DE COMENT√ÅRIO.
async function gerarReacaoOraculoParaComentarioComIA(textoDoComentario) {
  if (!genAI) return 'üëç';

  const prompt = `
    Voc√™ √© o Or√°culo, um mentor s√°bio e carinhoso.
    Um membro do grupo fez o seguinte coment√°rio:
    "${textoDoComentario}"
    
    Qual emoji melhor representa sua rea√ß√£o a este coment√°rio?
    Escolha UM emoji da seguinte lista: ['üëç', 'üíñ', 'üòÇ', 'üéâ', 'üî•', 'üòÆ']

    Sua resposta DEVE ser um JSON v√°lido no formato: {"emoji": "SEU_EMOJI_AQUI"}.
    Apenas o JSON, sem explica√ß√µes.
  `;

  try {
    // Usamos a fun√ß√£o com retentativas para evitar o erro 503
    const text = await callGenerativeAIWithRetry(prompt); 
    const jsonString = text.match(/{[\s\S]*}/)[0];
    const { emoji } = JSON.parse(jsonString);
    return emoji && EMOJIS_MURAL.includes(emoji) ? emoji : 'üëç';
  } catch (error) {
    console.error("Or√°culo (Rea√ß√£o a Coment√°rio): Erro final ao escolher emoji.", error);
    return 'üëç'; // Retorna um emoji seguro em caso de erro
  }
}

// SUBSTITUA A SUA FUN√á√ÉO ANTIGA POR ESTA VERS√ÉO CORRIGIDA

async function gerarRespostaOraculoParaComentario(messageId, commentId, comentarioOriginal, autorComentario) {
  if (!genAI) return;

  // Log atualizado
  console.log(`Or√°culo: Analisando coment√°rio de ${autorComentario} para interagir...`);

  const messageRef = doc(db, "mural", messageId);
  const messageSnap = await getDoc(messageRef);
  if (!messageSnap.exists()) return;

  const originalPostText = messageSnap.data().texto.replace(/<[^>]*>/g, " ");

  // Atualizamos o contexto para remover "que te mencionou"
  const contexto = `
    - Post Original no Mural: "${originalPostText}"
    - Coment√°rio feito pelo membro: "${comentarioOriginal}"
  `;

  // Instru√ß√µes refinadas para uma intera√ß√£o mais natural
  const instrucoes = `
    1.  Analise o coment√°rio feito pelo membro. Escolha UM emoji de rea√ß√£o da lista: ['üëç', 'üíñ', 'üòÇ', 'üéâ', 'üî•', 'üòÆ'].
    2.  Escreva uma resposta curta de acordo com o contexto do coment√°rio do membro. Seja o mais natural e humano que conseguir, mas sem deixar de ser am√°vel.
    3.  Mencione o autor do coment√°rio usando <strong>@${autorComentario}</strong>.
    4.  Assine sua resposta com "‚Äî Or√°culo".
    5.  N√ÉO se revele como uma IA. Aja como um membro s√°bio participando da conversa.
  `;
  
  // Faz UMA √öNICA chamada para a IA
  const resultado = await gerarReacaoERespostaCombinadaComIA(contexto, instrucoes);

  if (!resultado) {
    console.error("Or√°culo (Coment√°rio): Falha ao obter dados da IA. A intera√ß√£o ser√° abortada.");
    return;
  }

  // Executa as a√ß√µes com os dados recebidos
  try {
    // 1. Reagir ao coment√°rio
    await adicionarReacaoOraculoAoComentario(messageId, commentId, resultado.emoji);

    // 2. Postar a resposta como um novo coment√°rio
    const commentsRef = collection(db, "mural", messageId, "comments");
    await addDoc(commentsRef, {
      userId: "Or√°culo",
      texto: resultado.resposta.replace(/\n/g, '<br>'),
      timestamp: new Date(),
      reacoes: EMOJIS_MURAL.reduce((acc, emoji) => ({...acc, [emoji]: []}), {})
    });
    
    // 3. Atualizar o contador
    await updateDoc(messageRef, { commentCount: increment(1) });

    console.log("Or√°culo: Rea√ß√£o e resposta ao COMENT√ÅRIO enviadas com sucesso.");

  } catch (error) {
    console.error("Or√°culo (Coment√°rio): Erro ao postar rea√ß√£o ou resposta.", error);
  }
}

// =============================================
// ===== FUN√á√ïES PARA MEDALHAS DE HONRA =====
// =============================================

// FUN√á√ÉO OTIMIZADA: N√£o l√™ mais a cole√ß√£o 'membros'
async function carregarDadosMedalhasHonra() {
    console.log("Carregando dados das Medalhas de Honra (Otimizado)...");
    try {
        // Carrega todas as medalhas da loja (cache) - S√ì SE NECESS√ÅRIO
        if (todasMedalhasHonra.length === 0) {
            console.log("Cache de medalhas da loja vazio. Lendo do Firestore...");
            const medalhasSnapshot = await getDocs(collection(db, "medalhasDeHonra"));
            medalhasSnapshot.forEach(doc => {
                todasMedalhasHonra.push({ id: doc.id, ...doc.data() });
            });
            // Ordena localmente para a exposi√ß√£o
            const raridadeOrdem = { "Comum": 1, "Incomum": 2, "Rara": 3, "Lend√°ria": 4 };
            todasMedalhasHonra.sort((a, b) => raridadeOrdem[a.categoria] - raridadeOrdem[b.categoria]);
            console.log(`${todasMedalhasHonra.length} medalhas de honra carregadas e cacheadas.`);

            // <<< IMPORTANTE: Re-inicializa o cache de desejos AP√ìS carregar as medalhas >>>
            // Isso garante que todas as medalhas tenham uma entrada na lista de desejos.
            medalhasDesejadasCache = {};
            todasMedalhasHonra.forEach(m => medalhasDesejadasCache[m.id] = []);
            
            // <<< NOVO BLOCO: Popula a lista de desejos com base nos dados j√° carregados dos membros >>>
            for (const membro of todosMembros) {
                (membro.medalhasDesejadas || []).forEach(medalhaId => {
                     if (medalhasDesejadasCache[medalhaId]) {
                         medalhasDesejadasCache[medalhaId].push(membro.nome);
                     } else {
                         // Pode acontecer se uma medalha foi deletada da loja mas ainda est√° na lista de desejos de algu√©m
                         console.warn(`Medalha ${medalhaId} desejada por ${membro.nome} n√£o encontrada na lista global atualizada.`);
                     }
                });
            }
            console.log("Cache de lista de desejos populado corretamente.");

        } else {
             console.log("Utilizando cache de medalhas da loja.");
        }

        // <<< REMOVIDO: Bloco inteiro que lia a cole√ß√£o 'membros' foi apagado >>>
        // Os caches medalhasInventarioCache, medalhasOrdemCache e medalhasDesejadasCache
        // j√° foram populados pela fun√ß√£o carregarDadosEssenciais.

        // Chama as fun√ß√µes que constroem a interface usando os dados cacheados
        construirCarrosselMedalhas();
		
		// --- IN√çCIO DA ALTERA√á√ÉO: Definir slide inicial ---
        const userIndex = todosMembros.findIndex(m => m.nome === currentUser);
        if (userIndex !== -1 && totalSlidesMedalhas > 0) {
            // Atraso m√≠nimo para garantir que o DOM esteja pronto para a transi√ß√£o
            setTimeout(() => {
                // Pausa temporariamente para evitar que o autom√°tico avance antes de ir para o slide certo
                const estavaPausado = carrosselMedalhasPausado;
                if (!estavaPausado && totalSlidesMedalhas > 1) togglePausaMedalhas();

                irParaSlideMedalhas(userIndex); // Vai para o slide do usu√°rio

                // Retoma o carrossel se ele n√£o estava pausado antes
                if (!estavaPausado && totalSlidesMedalhas > 1) {
                   setTimeout(() => togglePausaMedalhas(), 500); // Pequeno atraso antes de retomar
                }
            }, 150); // Aumentei um pouco o atraso para seguran√ßa
        }
        // --- FIM DA ALTERA√á√ÉO ---
		
        configurarModalExposicao();

        console.log("Interface das Medalhas de Honra constru√≠da/atualizada.");

    } catch (error) {
        console.error("Erro ao carregar dados das Medalhas de Honra (Otimizado):", error);
        const container = document.getElementById("carrossel-container-medalhas");
        if(container) container.innerHTML = '<div class="card-membro"><p>Erro ao carregar medalhas.</p></div>';
    }
}

// --- CONSTRU√á√ÉO DO CARROSSEL PRINCIPAL ---
function construirCarrosselMedalhas() {
    const carrosselContainer = document.getElementById('carrossel-container-medalhas');
    const indicadoresContainer = document.getElementById('carrossel-indicadores-medalhas');
    carrosselContainer.innerHTML = '';
    indicadoresContainer.innerHTML = '';
    carrosseisInternosMedalhasState = {}; // Reseta estado das p√°ginas internas

    totalSlidesMedalhas = todosMembros.length;

    todosMembros.forEach((membro, index) => {
        const membroId = membro.nome;
        const inventario = medalhasInventarioCache[membroId] || [];
        let ordem = medalhasOrdemCache[membroId] || [];

        // Garante que a ordem contenha todos os itens do invent√°rio
        const inventarioSet = new Set(inventario);
        ordem = ordem.filter(id => inventarioSet.has(id)); // Remove da ordem itens que n√£o est√£o mais no invent√°rio
        inventario.forEach(id => {
            if (!ordem.includes(id)) {
                ordem.push(id); // Adiciona no final itens do invent√°rio que n√£o estavam na ordem
            }
        });
        medalhasOrdemCache[membroId] = ordem; // Atualiza o cache da ordem

        // CORRE√á√ÉO: Garante que haja sempre pelo menos 1 p√°gina, mesmo com 0 medalhas.
const totalPaginas = Math.max(1, Math.ceil(ordem.length / MEDALHAS_POR_PAGINA));
carrosseisInternosMedalhasState[membroId] = 0; // Inicia na p√°gina 0

        const card = document.createElement('div');
        card.className = 'card-medalhas-membro';
        card.id = `card-medalhas-${membroId}`;

        // Cabe√ßalho com nome e bot√£o de ordenar (se for o pr√≥prio usu√°rio)
        card.innerHTML = `
            <div class="card-medalhas-header">
                <div class="card-medalhas-nome-container">
            <span class="card-medalhas-nome-membro">${membroId}</span>
        </div>
                ${membroId === currentUser ? `<button class="botao-ordenar-medalhas" onclick="abrirModalOrdenarMedalhas('${membroId}')">Ordenar</button>` : ''}
            </div>
            <div class="card-medalhas-paginacao-wrapper">
                <div class="card-medalhas-paginacao-container" id="paginacao-container-${membroId}">
                    </div>
            </div>
            <div class="card-medalhas-controles-internos">
                <button class="btn-pagina-interna prev" onclick="mudarPaginaMedalhas('${membroId}', -1)" disabled>‚ùÆ</button>
                <div class="indicadores-pagina-interna" id="indicadores-internos-${membroId}">
                    </div>
                <button class="btn-pagina-interna next" onclick="mudarPaginaMedalhas('${membroId}', 1)" ${totalPaginas <= 1 ? 'disabled' : ''}>‚ùØ</button>
            </div>
        `;

        const paginacaoContainer = card.querySelector(`#paginacao-container-${membroId}`);
        const indicadoresInternosContainer = card.querySelector(`#indicadores-internos-${membroId}`);

        // Cria as p√°ginas internas
        for (let i = 0; i < totalPaginas; i++) {
            const pagina = document.createElement('div');
            pagina.className = 'card-medalhas-pagina';
            pagina.id = `pagina-${membroId}-${i}`;

            const inicio = i * MEDALHAS_POR_PAGINA;
            const fim = inicio + MEDALHAS_POR_PAGINA;
            const medalhasDaPagina = ordem.slice(inicio, fim);

            medalhasDaPagina.forEach((medalhaId, slotIndex) => {
                const medalhaData = todasMedalhasHonra.find(m => m.id === medalhaId);
                if (medalhaData) {
                    const medalhaDiv = document.createElement('div');
                    const slotClass = `medalha-slot-${slotIndex + 1}`;
                    // Adiciona classe de raridade para o brilho
                    const raridadeNormalizada = medalhaData.categoria.normalize('NFD').replace(/[\u0300-\u036f]/g, "").toLowerCase();
                    medalhaDiv.className = `medalha-honra-display ${slotClass} ${raridadeNormalizada}`;
                    medalhaDiv.innerHTML = `<img src="${medalhaData.link}" alt="${medalhaData.nome}" title="${medalhaData.nome} (${medalhaData.categoria})">`;
                    medalhaDiv.onclick = () => abrirModalInfoMedalha(medalhaId);
                    // Adicionar tooltip ou abrir detalhes ao clicar, se desejado
                    pagina.appendChild(medalhaDiv);
                }
            });
            paginacaoContainer.appendChild(pagina);

            // Cria indicador interno
            const indicador = document.createElement('div');
            indicador.className = `indicador-interno ${i === 0 ? 'ativo' : ''}`;
            indicador.dataset.page = i;
            indicadoresInternosContainer.appendChild(indicador);
        }

        // CORRE√á√ÉO: Se n√£o houver medalhas, garante que a primeira p√°gina vazia seja criada
// e esconde os controles internos apenas se houver S√ì uma p√°gina.
if (ordem.length === 0) {
    // Cria a primeira p√°gina vazia (o loop 'for' acima n√£o rodou)
    const paginaVazia = document.createElement('div');
    paginaVazia.className = 'card-medalhas-pagina';
    paginaVazia.id = `pagina-${membroId}-0`;
    paginacaoContainer.appendChild(paginaVazia);

    // Cria o indicador interno para a p√°gina 0 vazia
    const indicadorVazio = document.createElement('div');
    indicadorVazio.className = 'indicador-interno ativo';
    indicadorVazio.dataset.page = 0;
    indicadoresInternosContainer.appendChild(indicadorVazio);
}

// Esconde os controles internos APENAS se houver s√≥ 1 p√°gina no total
if (totalPaginas <= 1) {
    card.querySelector('.card-medalhas-controles-internos').style.display = 'none';
} else {
    // Garante que os controles estejam vis√≠veis se houver mais de 1 p√°gina
    card.querySelector('.card-medalhas-controles-internos').style.display = 'flex';
    // Ajusta o bot√£o 'next' inicial se houver mais de 1 p√°gina
    const btnNext = card.querySelector('.btn-pagina-interna.next');
    if(btnNext) btnNext.disabled = false;
}

        carrosselContainer.appendChild(card);

        // Cria indicador principal
        const indicadorPrincipal = document.createElement('div');
        indicadorPrincipal.className = 'carrossel-indicador';
        indicadorPrincipal.onclick = () => {
            reiniciarIntervaloCarrosselMedalhas();
            irParaSlideMedalhas(index);
        };
        indicadoresContainer.appendChild(indicadorPrincipal);
    });

    if (totalSlidesMedalhas > 0) {
        document.querySelector('#carrossel-indicadores-medalhas .carrossel-indicador')?.classList.add('ativo');
        irParaSlideMedalhas(0); // Garante que o primeiro slide seja exibido
        if (totalSlidesMedalhas > 1) {
            iniciarCarrosselAutomaticoMedalhas();
        } else {
            // Se houver apenas um slide, pausa o carrossel visualmente
            const botaoPausa = document.getElementById('botao-pausa-medalhas');
            if(botaoPausa) botaoPausa.textContent = '‚ñ∂';
            carrosselMedalhasPausado = true;
        }
    } else {
         carrosselContainer.innerHTML = '<div class="card-membro"><p>Nenhum membro encontrado.</p></div>';
    }
}

// --- CONTROLES DO CARROSSEL PRINCIPAL ---
function iniciarCarrosselAutomaticoMedalhas() {
    if (carrosselMedalhasInterval) clearInterval(carrosselMedalhasInterval);
    if (totalSlidesMedalhas <= 1) return; // N√£o inicia se tiver 0 ou 1 slide

    carrosselMedalhasInterval = setInterval(() => {
        if (!carrosselMedalhasPausado) {
            currentCarrosselMedalhasIndex = (currentCarrosselMedalhasIndex + 1) % totalSlidesMedalhas;
            irParaSlideMedalhas(currentCarrosselMedalhasIndex);
        }
    }, 10000); // 10 segundos por membro
    iniciarBarraProgressoMedalhas();
}

function irParaSlideMedalhas(index) {
    const carrosselContainer = document.getElementById("carrossel-container-medalhas");
    if (!carrosselContainer) return;
    carrosselContainer.style.transform = `translateX(-${index * 100}%)`;

    const indicadores = document.querySelectorAll('#carrossel-indicadores-medalhas .carrossel-indicador');
    indicadores.forEach((ind, i) => {
        ind.classList.toggle('ativo', i === index);
    });

    currentCarrosselMedalhasIndex = index;
    if (!carrosselMedalhasPausado) iniciarBarraProgressoMedalhas();
}

function iniciarBarraProgressoMedalhas() {
    const barra = document.getElementById('progresso-indicador-barra-medalhas');
    if (!barra || totalSlidesMedalhas <= 1) return;

    barra.style.transition = 'none';
    barra.style.width = '0%';
    void barra.offsetWidth; // Force reflow

    barra.style.transition = 'width 10s linear';
    setTimeout(() => {
        if (!carrosselMedalhasPausado) {
            barra.style.width = '100%';
        }
    }, 10);

    if (progressoBarraMedalhas) clearTimeout(progressoBarraMedalhas);
    progressoBarraMedalhas = setTimeout(() => {
        if (!carrosselMedalhasPausado) barra.style.width = '0%';
    }, 10000);
}

window.mudarSlideMedalhas = function(direction) {
    if (totalSlidesMedalhas <= 1) return;
    reiniciarIntervaloCarrosselMedalhas();
    currentCarrosselMedalhasIndex = (currentCarrosselMedalhasIndex + direction + totalSlidesMedalhas) % totalSlidesMedalhas;
    irParaSlideMedalhas(currentCarrosselMedalhasIndex);
}

// SUBSTITUA A SUA FUN√á√ÉO ANTIGA POR ESTA
window.togglePausaMedalhas = function() {
    if (totalSlidesMedalhas <= 1) return; // N√£o faz nada se tiver s√≥ 1 slide
    carrosselMedalhasPausado = !carrosselMedalhasPausado;
    const botaoPausa = document.getElementById('botao-pausa-medalhas');
    const barra = document.getElementById('progresso-indicador-barra-medalhas');

    if (carrosselMedalhasPausado) {
        clearInterval(carrosselMedalhasInterval);
        botaoPausa.textContent = '‚ñ∂';
        if(barra) {
            // === CORRE√á√ÉO AQUI (In√≠cio) ===
            // 1. Remove a transi√ß√£o CSS para parar a anima√ß√£o imediatamente.
            barra.style.transition = 'none';
            // 2. Salva a largura atual em um atributo de dados.
            barra.dataset.width = window.getComputedStyle(barra).width;
            // Limpa o timeout JS que reiniciaria a barra
            if (progressoBarraMedalhas) clearTimeout(progressoBarraMedalhas);
            // === CORRE√á√ÉO AQUI (Fim) ===
        }
    } else {
        botaoPausa.textContent = '‚è∏';
        if(barra) {
            // === CORRE√á√ÉO AQUI (In√≠cio) ===
            // 1. Restaura a transi√ß√£o CSS para a anima√ß√£o de 10 segundos.
            barra.style.transition = 'width 10s linear';
            // 2. Define a largura alvo como 100% para continuar a anima√ß√£o.
            //    (Se a barra j√° estava em 100%, ela reiniciar√° no pr√≥ximo ciclo do carrossel).
            //    Usamos setTimeout para garantir que a mudan√ßa de transition seja processada antes.
            setTimeout(() => {
                 barra.style.width = '100%';
            }, 10); // Pequeno atraso
             // === CORRE√á√ÉO AQUI (Fim) ===
        }
        iniciarCarrosselAutomaticoMedalhas(); // Esta fun√ß√£o j√° reinicia a barra corretamente
    }
}

function reiniciarIntervaloCarrosselMedalhas() {
    if (totalSlidesMedalhas <= 1) return;
    clearInterval(carrosselMedalhasInterval);
    iniciarCarrosselAutomaticoMedalhas();
    // iniciarBarraProgressoMedalhas(); // O iniciarCarrossel j√° chama isso
}

// --- CONTROLES DA PAGINA√á√ÉO INTERNA ---
function mudarPaginaMedalhas(membroId, direcao) {
    const container = document.getElementById(`paginacao-container-${membroId}`);
    const indicadoresContainer = document.getElementById(`indicadores-internos-${membroId}`);
    if (!container || !indicadoresContainer) return;

    const totalPaginas = container.children.length;
    let paginaAtual = carrosseisInternosMedalhasState[membroId] || 0;

    paginaAtual = (paginaAtual + direcao + totalPaginas) % totalPaginas;
    carrosseisInternosMedalhasState[membroId] = paginaAtual;

    container.style.transform = `translateX(-${paginaAtual * 100}%)`;

    // Atualiza indicadores internos
    const indicadores = indicadoresContainer.querySelectorAll('.indicador-interno');
    indicadores.forEach((ind, i) => {
        ind.classList.toggle('ativo', i === paginaAtual);
    });

    // Habilita/desabilita bot√µes prev/next internos
    const btnPrev = container.closest('.card-medalhas-membro').querySelector('.btn-pagina-interna.prev');
    const btnNext = container.closest('.card-medalhas-membro').querySelector('.btn-pagina-interna.next');
    if (btnPrev) btnPrev.disabled = paginaAtual === 0;
    if (btnNext) btnNext.disabled = paginaAtual === totalPaginas - 1;

    // Pausa o carrossel principal se o usu√°rio interagir com o interno
    if (!carrosselMedalhasPausado && totalSlidesMedalhas > 1) {
        togglePausaMedalhas();
    }
}
window.mudarPaginaMedalhas = mudarPaginaMedalhas; // Torna global

// --- MODAL: EXPOSI√á√ÉO DE MEDALHAS ---
function configurarModalExposicao() {
    const btnAbrir = document.getElementById('btn-exposicao-medalhas');
    if (btnAbrir) {
        btnAbrir.onclick = abrirExposicaoMedalhas;
    }

    const filtros = document.querySelectorAll('.filtro-raridade');
    filtros.forEach(btn => {
        btn.onclick = () => {
            filtros.forEach(f => f.classList.remove('ativo'));
            btn.classList.add('ativo');
            filtrarMedalhasExposicao(btn.dataset.raridade);
        };
    });
}

function abrirExposicaoMedalhas() {
    // =============================================
    // ===== IN√çCIO DA ALTERA√á√ÉO (PASSO 8.1) =====
    // =============================================
    const btnListaDesejos = document.getElementById('btn-lista-desejos-equipe');
    if (userRole === 'lider' || userRole === 'lider-equipe') {
        btnListaDesejos.classList.remove('hidden');
    } else {
        btnListaDesejos.classList.add('hidden');
    }
    // =============================================
    // ===== FIM DA ALTERA√á√ÉO (PASSO 8.1) =====
    // =============================================

    popularExposicaoMedalhas(); // Popula com todas inicialmente
    openModal('exposicao-medalhas-modal');
}

// NOVA FUN√á√ÉO: Fecha a lista de desejos e abre a compra direta para o membro
window.comprarMedalhaDaListaDeDesejos = function(medalhaId, membroId) {
    // 1. Fecha o modal da lista de desejos
    closeModal('desejos-equipe-modal');
    
    // 2. Pequeno delay para a anima√ß√£o n√£o travar e abre o modal de compra
    // passando o ID da medalha E o nome do membro
    setTimeout(() => {
        abrirModalCompraMedalha(medalhaId, membroId);
    }, 200);
}

// =============================================
// ===== NOVA FUN√á√ÉO (PASSO 8.2) =====
// =============================================
async function abrirModalListaDesejos() {
    const listaContainer = document.getElementById('desejos-equipe-lista');
    listaContainer.innerHTML = '<div class="ociosos-placeholder">Carregando lista de desejos...</div>';
    openModal('desejos-equipe-modal');

    let membrosParaExibir = [];

    // Filtra os membros baseado no papel do l√≠der
    if (userRole === 'lider') {
        // L√≠der geral v√™ todos, exceto ele mesmo
        membrosParaExibir = todosMembros.filter(m => m.nome !== currentUser);
    } else if (userRole === 'lider-equipe') {
        // L√≠der de equipe v√™ apenas sua equipe, exceto ele mesmo
        membrosParaExibir = todosMembros.filter(m => m.equipe === userTeam && m.nome !== currentUser);
    }

    // Ordena os membros alfabeticamente
    membrosParaExibir.sort((a, b) => a.nome.localeCompare(b.nome));

    if (membrosParaExibir.length === 0) {
        listaContainer.innerHTML = '<div class="ociosos-placeholder">Nenhum membro encontrado para exibir.</div>';
        return;
    }

    listaContainer.innerHTML = ''; // Limpa o "carregando"
    let totalDesejosEncontrados = 0;

    membrosParaExibir.forEach(membro => {
        const desejosDoMembro = membro.medalhasDesejadas || [];
        
        // Cria um card para o membro
        const itemEl = document.createElement('div');
        itemEl.className = 'desejo-membro-item';
        
        let medalhasHTML = '';
        
        if (desejosDoMembro.length > 0) {
            totalDesejosEncontrados++;
            
            desejosDoMembro.forEach(medalhaId => {
                const medalhaData = todasMedalhasHonra.find(m => m.id === medalhaId);
                if (medalhaData) {
                    const raridadeNormalizada = medalhaData.categoria.normalize('NFD').replace(/[\u0300-\u036f]/g, "").toLowerCase();
                    // ALTERA√á√ÉO: Adicionado onclick, cursor pointer e title
                    medalhasHTML += `
                        <div class="desejo-medalha-card ${raridadeNormalizada}" 
                             onclick="comprarMedalhaDaListaDeDesejos('${medalhaData.id}', '${membro.nome}')"
                             style="cursor: pointer; transition: transform 0.2s;"
                             onmouseover="this.style.transform='scale(1.05)'"
                             onmouseout="this.style.transform='scale(1)'"
                             title="Clique para presentear ${membro.nome} com esta medalha">
                            <img src="${medalhaData.link}" alt="${medalhaData.nome}">
                            <div class="medalha-exposicao-nome">${medalhaData.nome}</div>
                            <div class="medalha-exposicao-valor">üí∞ ${medalhaData.valor.toLocaleString('pt-BR')}</div>
                        </div>
                    `;
                }
            });
        } else {
            medalhasHTML = '<p class="ociosos-placeholder" style="width: 100%; margin: 0;">N√£o adicionou nenhuma medalha √† lista de desejos.</p>';
        }

        itemEl.innerHTML = `
            <h4>${membro.nome} (${membro.equipe})</h4>
            <div class="desejo-medalhas-grid">
                ${medalhasHTML}
            </div>
        `;
        listaContainer.appendChild(itemEl);
    });

    if (totalDesejosEncontrados === 0) {
        listaContainer.innerHTML = '<div class="ociosos-placeholder">Nenhum membro da sua equipe adicionou medalhas √† lista de desejos ainda.</div>';
    }
}
window.abrirModalListaDesejos = abrirModalListaDesejos; // Torna a fun√ß√£o global
// =============================================
// ===== FIM DA NOVA FUN√á√ÉO (PASSO 8.2) =====
// =============================================

function popularExposicaoMedalhas(filtroRaridade = 'todas') {
    const grid = document.getElementById('exposicao-medalhas-grid');
    grid.innerHTML = ''; // Limpa antes de popular

    const medalhasFiltradas = (filtroRaridade === 'todas')
        ? todasMedalhasHonra
        : todasMedalhasHonra.filter(m => m.categoria === filtroRaridade);

    if (medalhasFiltradas.length === 0) {
        grid.innerHTML = '<p style="grid-column: 1 / -1; text-align: center; font-style: italic;">Nenhuma medalha encontrada.</p>';
        return;
    }

    medalhasFiltradas.forEach(medalha => {
        const card = document.createElement('div');
        const raridadeLower = medalha.categoria.normalize('NFD').replace(/[\u0300-\u036f]/g, "").toLowerCase();
        card.className = `medalha-exposicao-card ${raridadeLower}`;

        const possui = (medalhasInventarioCache[currentUser] || []).includes(medalha.id);
        const deseja = (medalhasDesejadasCache[medalha.id] || []).includes(currentUser);

        card.innerHTML = `
            <div class="medalha-exposicao-img-container">
                <img class="medalha-exposicao-img" src="${medalha.link}" alt="${medalha.nome}">
            </div>
            <div class="medalha-exposicao-nome">${medalha.nome}</div>
            <div class="medalha-exposicao-raridade ${raridadeLower}">${medalha.categoria}</div>
            <div class="medalha-exposicao-valor">üí∞ ${medalha.valor.toLocaleString('pt-BR')}</div>
            <div class="medalha-exposicao-botoes">
                <button class="painel-btn" onclick="abrirDetalhesMedalha('${medalha.id}')">Detalhes</button>
                ${possui ? '<button class="painel-btn" disabled>Possui</button>' :
                           `<button class="painel-btn ${deseja ? 'deseja' : 'btn-adicionar'}" onclick="handleQueroEssa(event, '${medalha.id}')">${deseja ? 'Desejando' : 'Quero Essa!'}</button>`}
            </div>
        `;
        grid.appendChild(card);
    });
}

function filtrarMedalhasExposicao(raridade) {
    popularExposicaoMedalhas(raridade);
}

// --- MODAL: DETALHES DA MEDALHA ---
window.abrirDetalhesMedalha = function(medalhaId) {
    const medalha = todasMedalhasHonra.find(m => m.id === medalhaId);
    if (!medalha) return;

    document.getElementById('detalhes-medalha-nome').textContent = medalha.nome;
    document.getElementById('detalhes-medalha-img').src = medalha.link;
    const raridadeEl = document.getElementById('detalhes-medalha-raridade');
    raridadeEl.textContent = medalha.categoria;
    // <-- MODIFICADO: Normaliza a categoria para aplicar a classe CSS correta
    const raridadeNormalizada = medalha.categoria.normalize('NFD').replace(/[\u00c0-\u00cf]/g, "").toLowerCase();
    raridadeEl.className = `medalha-exposicao-raridade ${raridadeNormalizada}`;
    document.getElementById('detalhes-medalha-valor').textContent = `üí∞ ${medalha.valor.toLocaleString('pt-BR')}`;

    // Lista de Possuidores
    const possuidoresLista = document.getElementById('detalhes-medalha-possuidores-lista');
    possuidoresLista.innerHTML = '';
    let countPossuidores = 0;
    for (const membroId in medalhasInventarioCache) {
        if (medalhasInventarioCache[membroId].includes(medalhaId)) {
            const tag = document.createElement('span');
            tag.className = 'medalha-membro-tag';
            tag.textContent = membroId;
            possuidoresLista.appendChild(tag);
            countPossuidores++;
        }
    }
    document.getElementById('detalhes-medalha-possuidores-count').textContent = countPossuidores;

    // Lista de Desejos
    const desejosLista = document.getElementById('detalhes-medalha-desejos-lista');
    desejosLista.innerHTML = '';
    const desejantes = medalhasDesejadasCache[medalhaId] || [];
    desejantes.forEach(membroId => {
        const tag = document.createElement('span');
        tag.className = 'medalha-membro-tag';
        tag.textContent = membroId;
        desejosLista.appendChild(tag);
    });
    document.getElementById('detalhes-medalha-desejos-count').textContent = desejantes.length;

    // Bot√£o "Quero Essa"
    const btnQuero = document.getElementById('detalhes-medalha-quero-btn');
    const possui = (medalhasInventarioCache[currentUser] || []).includes(medalhaId);
    const deseja = desejantes.includes(currentUser);

    if (possui) {
        btnQuero.classList.add('hidden'); // Esconde se j√° possui
    } else {
        btnQuero.classList.remove('hidden');
        btnQuero.textContent = deseja ? 'Remover da Lista de Desejos' : 'Quero Essa!';
        btnQuero.classList.toggle('deseja', deseja);
        btnQuero.onclick = () => handleQueroEssa(null, medalhaId);
    }

    // --- L√ìGICA DOS BOT√ïES DE COMPRA PARA L√çDERES ---
    const btnComprar = document.getElementById('detalhes-medalha-comprar-btn');
    const btnComprarMim = document.getElementById('detalhes-medalha-comprar-mim-btn'); // <-- NOVO: Refer√™ncia ao novo bot√£o
    const podeLiderar = userRole === 'lider' || userRole === 'lider-equipe';

    // Bot√£o "Comprar para Membro"
    if (podeLiderar) {
        btnComprar.classList.remove('hidden');
        btnComprar.onclick = () => abrirModalCompraMedalha(medalhaId);
    } else {
        btnComprar.classList.add('hidden');
    }

    // <-- NOVO: L√≥gica para o bot√£o "Comprar para Mim" -->
    if (podeLiderar && !possui) { // Vis√≠vel para l√≠der que N√ÉO possui a medalha
        btnComprarMim.classList.remove('hidden');
        btnComprarMim.onclick = () => executarCompraMedalhaParaMim(medalhaId);
    } else {
        btnComprarMim.classList.add('hidden');
    }
    // <-- FIM DO NOVO BLOCO -->

    openModal('detalhes-medalha-modal');
}

async function handleQueroEssa(event, medalhaId) {
    if(event) event.stopPropagation(); // Impede de abrir detalhes ao clicar no bot√£o da exposi√ß√£o

    const membroRef = doc(db, "membros", currentUser);
    const listaDesejosAtual = medalhasDesejadasCache[medalhaId] || [];
    const jaDeseja = listaDesejosAtual.includes(currentUser);
    const operacao = jaDeseja ? 'arrayRemove' : 'arrayUnion';
    const novaListaDesejosMembro = jaDeseja
        ? (await getDoc(membroRef)).data().medalhasDesejadas.filter(id => id !== medalhaId)
        : [...((await getDoc(membroRef)).data().medalhasDesejadas || []), medalhaId];

    try {
        await updateDoc(membroRef, { medalhasDesejadas: novaListaDesejosMembro });

        // Atualiza cache local
        if (jaDeseja) {
            medalhasDesejadasCache[medalhaId] = listaDesejosAtual.filter(m => m !== currentUser);
        } else {
            if (!medalhasDesejadasCache[medalhaId]) medalhasDesejadasCache[medalhaId] = [];
            medalhasDesejadasCache[medalhaId].push(currentUser);
        }

        // Atualiza a UI (bot√£o na exposi√ß√£o e lista no modal de detalhes)
        const btnExposicao = document.querySelector(`.medalha-exposicao-card button[onclick*="'${medalhaId}'"]`);
        if (btnExposicao) {
             btnExposicao.textContent = jaDeseja ? 'Quero Essa!' : 'Desejando';
             btnExposicao.classList.toggle('deseja', !jaDeseja);
             if (!jaDeseja) btnExposicao.classList.remove('btn-adicionar'); else btnExposicao.classList.add('btn-adicionar');
        }
        // Atualiza o modal de detalhes se estiver aberto
        if (!document.getElementById('detalhes-medalha-modal').classList.contains('hidden')) {
            abrirDetalhesMedalha(medalhaId);
        }

        mostrarPopup("‚úÖ Atualizado", jaDeseja ? "Medalha removida da sua lista de desejos." : "Medalha adicionada √† sua lista de desejos!", 3000);

    } catch (error) {
        console.error("Erro ao atualizar lista de desejos:", error);
        mostrarPopup("‚ùå Erro", "N√£o foi poss√≠vel atualizar sua lista de desejos.", 4000);
    }
}
window.handleQueroEssa = handleQueroEssa; // Torna global

// --- MODAL: COMPRA DE MEDALHA ---
// Altera√ß√£o: Adicionado o par√¢metro membroPreSelecionado
async function abrirModalCompraMedalha(medalhaId, membroPreSelecionado = null) {
    medalhaParaComprarInfo = todasMedalhasHonra.find(m => m.id === medalhaId);
    if (!medalhaParaComprarInfo) return;

    closeModal('detalhes-medalha-modal'); // Fecha o modal de detalhes

    document.getElementById('compra-medalha-img').src = medalhaParaComprarInfo.link;
    document.getElementById('compra-medalha-nome').textContent = medalhaParaComprarInfo.nome;
    document.getElementById('compra-medalha-valor').textContent = medalhaParaComprarInfo.valor.toLocaleString('pt-BR');

    // --- L√ìGICA DE SELE√á√ÉO DE MEMBRO (SEM ALTERA√á√ÉO) ---
    const selectMembro = document.getElementById('compra-medalha-select-membro');
    selectMembro.innerHTML = '<option value="">Selecione...</option>';
    let membrosElegiveis = [];
    if (userRole === 'lider') {
        membrosElegiveis = todosMembros.filter(m => m.nome !== currentUser);
    } else if (userRole === 'lider-equipe') {
        membrosElegiveis = todosMembros.filter(m =>
            m.nome !== currentUser && m.equipe === userTeam && m.papel !== 'lider'
        );
    }
    membrosElegiveis = membrosElegiveis.filter(m => !(medalhasInventarioCache[m.nome] || []).includes(medalhaId));
    membrosElegiveis.sort((a, b) => a.nome.localeCompare(b.nome));
    membrosElegiveis.forEach(membro => {
        const option = new Option(membro.nome, membro.nome);
        selectMembro.appendChild(option);
    });

    // NOVO: Se veio um membro pr√©-selecionado (da lista de desejos), seleciona ele agora
    if (membroPreSelecionado) {
        selectMembro.value = membroPreSelecionado;
    }

    // --- IN√çCIO DA NOVA L√ìGICA: SELE√á√ÉO DE FONTE DE PAGAMENTO ---
    const fontePagamentoContainer = document.getElementById('compra-medalha-fonte-pagamento');
    const podeLiderar = userRole === 'lider' || userRole === 'lider-equipe';

    if (podeLiderar && userTeam) {
        try {
            const membroDoc = await getDoc(doc(db, "membros", currentUser));
            const saldoPessoal = membroDoc.exists() ? membroDoc.data().moedas || 0 : 0;
            const saldoBanco = saldosBancosEquipes[userTeam] || 0;
            
            document.getElementById('saldo-pessoal-medalha').textContent = saldoPessoal.toLocaleString('pt-BR');
            document.getElementById('saldo-banco-medalha').textContent = saldoBanco.toLocaleString('pt-BR');
            
            // Habilita/desabilita op√ß√µes com base no saldo
            document.getElementById('fonte-pessoal-medalha').disabled = saldoPessoal < medalhaParaComprarInfo.valor;
            document.getElementById('fonte-banco-medalha').disabled = saldoBanco < medalhaParaComprarInfo.valor;

            // Seleciona 'pessoal' por padr√£o, se tiver saldo
            if (saldoPessoal >= medalhaParaComprarInfo.valor) {
                 document.getElementById('fonte-pessoal-medalha').checked = true;
            } else if (saldoBanco >= medalhaParaComprarInfo.valor) {
                 document.getElementById('fonte-banco-medalha').checked = true;
            }

            fontePagamentoContainer.classList.remove('hidden');
        } catch (e) {
            console.error("Erro ao buscar saldos para compra de medalha:", e);
            fontePagamentoContainer.classList.add('hidden');
        }
    } else {
        fontePagamentoContainer.classList.add('hidden');
    }
    // --- FIM DA NOVA L√ìGICA ---

    document.getElementById('compra-medalha-confirmar-btn').onclick = executarCompraMedalha;
    openModal('compra-medalha-modal');
}

async function executarCompraMedalha() {
    membroParaReceberMedalha = document.getElementById('compra-medalha-select-membro').value;

    if (!membroParaReceberMedalha || !medalhaParaComprarInfo) {
        mostrarPopup("‚ö†Ô∏è Aten√ß√£o", "Selecione um membro para presentear.", 3000);
        return;
    }

    // =============================================
    // ===== IN√çCIO DA ALTERA√á√ÉO (PASSO 2.1) =====
    // =============================================
    // 1. Captura o coment√°rio do textarea
    const comentario = document.getElementById('compra-medalha-comentario').value.trim();
    // Limpa o textarea ap√≥s a captura
    document.getElementById('compra-medalha-comentario').value = '';
    // =============================================
    // ===== FIM DA ALTERA√á√ÉO (PASSO 2.1) =====
    // =============================================

    const fontePagamentoEl = document.querySelector('input[name="fonte-pagamento-medalha"]:checked');
    const fontePagamento = (fontePagamentoEl && !fontePagamentoEl.disabled) ? fontePagamentoEl.value : 'pessoal';

    const liderRef = doc(db, "membros", currentUser);
    const bancoRef = doc(db, "bancosEquipes", userTeam);
    const recebedorRef = doc(db, "membros", membroParaReceberMedalha);
    const medalhaId = medalhaParaComprarInfo.id;
    const valor = medalhaParaComprarInfo.valor;

    try {
        await runTransaction(db, async (transaction) => {
            const recebedorDoc = await transaction.get(recebedorRef);
            if (!recebedorDoc.exists()) throw "Membro recebedor n√£o encontrado.";
            
            let fonteRef, saldoFonte;
            
            if (fontePagamento === 'banco') {
                const bancoDoc = await transaction.get(bancoRef);
                saldoFonte = bancoDoc.exists() ? bancoDoc.data().saldo || 0 : 0;
                fonteRef = bancoRef;
            } else {
                const liderDoc = await transaction.get(liderRef);
                saldoFonte = liderDoc.exists() ? liderDoc.data().moedas || 0 : 0;
                fonteRef = liderRef;
            }
            
            if (saldoFonte < valor) {
                throw `Saldo insuficiente na ${fontePagamento === 'banco' ? 'Banco da Equipe' : 'sua conta pessoal'}.`;
            }

            const campoSaldo = (fontePagamento === 'banco') ? 'saldo' : 'moedas';
            transaction.update(fonteRef, { [campoSaldo]: increment(-valor) });

            transaction.update(recebedorRef, { medalhasInventario: arrayUnion(medalhaId) });

            if (fontePagamento === 'banco') {
                const movRef = doc(collection(bancoRef, "movimentacoes"));
                transaction.set(movRef, {
                    tipo: 'compra_medalha',
                    valor: valor,
                    descricao: `Compra da medalha "${medalhaParaComprarInfo.nome}" para ${membroParaReceberMedalha}`,
                    membroId: currentUser,
                    timestamp: new Date()
                });
            }
        });

        if (!medalhasInventarioCache[membroParaReceberMedalha]) medalhasInventarioCache[membroParaReceberMedalha] = [];
        medalhasInventarioCache[membroParaReceberMedalha].push(medalhaId);

        await adicionarEventoAoFeed(
          'medalha',
          'üèÖ Medalha de Honra Concedida!',
          `<strong>${currentUser}</strong> presenteou <strong>${membroParaReceberMedalha}</strong> com a Medalha de Honra: <strong>${medalhaParaComprarInfo.nome}</strong>!`,
          { nomeMembro: membroParaReceberMedalha, doador: currentUser, medalha: medalhaParaComprarInfo.nome }
        );

        const notificacaoRef = doc(collection(db, "notificacoes"));
        
        // =============================================
        // ===== IN√çCIO DA ALTERA√á√ÉO (PASSO 2.2) =====
        // =============================================
        // 2. Adiciona o novo campo "comentario" √† notifica√ß√£o
        await setDoc(notificacaoRef, {
            destinatarioId: membroParaReceberMedalha,
            remetenteNome: currentUser,
            tipo: 'medalha-presente',
            conteudo: 'üèÖ',
            acao: `presenteou voc√™ com a Medalha de Honra: ${medalhaParaComprarInfo.nome}!`,
            lida: false,
            timestamp: new Date(),
            medalhaId: medalhaId,
            comentario: comentario || null // Salva o coment√°rio (ou null se estiver vazio)
        });
        // =============================================
        // ===== FIM DA ALTERA√á√ÉO (PASSO 2.2) =====
        // =============================================

        mostrarPopup("‚úÖ Sucesso!", `Medalha "${medalhaParaComprarInfo.nome}" comprada para ${membroParaReceberMedalha}!`, 5000);
        closeModal('compra-medalha-modal');
        await carregarDadosMedalhasHonra();

    } catch (error) {
        console.error("Erro ao comprar medalha:", error);
        mostrarPopup("‚ùå Erro", error.toString(), 5000);
    } finally {
        membroParaReceberMedalha = null;
        medalhaParaComprarInfo = null;
    }
}

// --- MODAL: ORDENAR MEDALHAS ---
function abrirModalOrdenarMedalhas(membroId) {
    if (currentUser !== membroId) return; // Seguran√ßa extra
    membroParaOrdenarMedalhas = membroId;

    const lista = document.getElementById('ordenar-medalhas-lista');
    lista.innerHTML = ''; // Limpa

    let ordemAtual = medalhasOrdemCache[membroId] || [];
    const inventario = medalhasInventarioCache[membroId] || [];

    // Garante que a ordem contenha todos os itens do invent√°rio (l√≥gica de constru√ß√£o do carrossel)
    const inventarioSet = new Set(inventario);
    ordemAtual = ordemAtual.filter(id => inventarioSet.has(id));
    inventario.forEach(id => {
        if (!ordemAtual.includes(id)) {
            ordemAtual.push(id);
        }
    });
    ordemMedalhasTemporaria = [...ordemAtual]; // Cria c√≥pia para arrastar

    ordemMedalhasTemporaria.forEach(medalhaId => {
        const medalhaData = todasMedalhasHonra.find(m => m.id === medalhaId);
        if (medalhaData) {
            const item = document.createElement('li');
            item.className = 'ordenar-item';
            item.draggable = true;
            item.dataset.id = medalhaId;
            item.innerHTML = `
                <span class="ordenar-drag-handle">‚ò∞</span>
                <img src="${medalhaData.link}" alt="" class="ordenar-medalha-img">
                <span class="ordenar-medalha-nome">${medalhaData.nome} (${medalhaData.categoria})</span>
            `;
            lista.appendChild(item);
        }
    });

    configurarDragDropOrdenacao();
    document.getElementById('ordenar-medalhas-salvar-btn').onclick = salvarOrdemMedalhas;
    openModal('ordenar-medalhas-modal');
}

function configurarDragDropOrdenacao() {
    const lista = document.getElementById('ordenar-medalhas-lista');
    const items = lista.querySelectorAll('.ordenar-item');
    let draggedItem = null;

    items.forEach(item => {
        item.addEventListener('dragstart', (e) => {
            draggedItem = item;
            // e.dataTransfer.setData('text/plain', item.dataset.id); // N√£o estritamente necess√°rio aqui
            setTimeout(() => item.classList.add('dragging'), 0);
        });

        item.addEventListener('dragend', () => {
            setTimeout(() => {
                draggedItem?.classList.remove('dragging');
                draggedItem = null;
                // Atualiza a ordem tempor√°ria ap√≥s soltar
                ordemMedalhasTemporaria = Array.from(lista.children).map(li => li.dataset.id);
            }, 0);
        });
    });

    lista.addEventListener('dragover', (e) => {
        e.preventDefault();
        const afterElement = getDragAfterElementOrdenacao(lista, e.clientY);
        if (!draggedItem) return;
        if (afterElement == null) {
            lista.appendChild(draggedItem);
        } else {
            lista.insertBefore(draggedItem, afterElement);
        }
    });
}

// Fun√ß√£o auxiliar para encontrar onde inserir o item arrastado
function getDragAfterElementOrdenacao(container, y) {
    const draggableElements = [...container.querySelectorAll('.ordenar-item:not(.dragging)')];
    return draggableElements.reduce((closest, child) => {
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height / 2;
        if (offset < 0 && offset > closest.offset) {
            return { offset: offset, element: child };
        } else {
            return closest;
        }
    }, { offset: Number.NEGATIVE_INFINITY }).element;
}

async function salvarOrdemMedalhas() {
    if (!membroParaOrdenarMedalhas) return;

    try {
        const membroRef = doc(db, "membros", membroParaOrdenarMedalhas);
        await updateDoc(membroRef, { medalhasOrdem: ordemMedalhasTemporaria });

        // Atualiza cache local
        medalhasOrdemCache[membroParaOrdenarMedalhas] = [...ordemMedalhasTemporaria];

        mostrarPopup("‚úÖ Sucesso", "A ordem das suas medalhas foi salva!", 3000);
        closeModal('ordenar-medalhas-modal');
        construirCarrosselMedalhas(); // Reconstr√≥i o carrossel para refletir a nova ordem

    } catch (error) {
        console.error("Erro ao salvar ordem das medalhas:", error);
        mostrarPopup("‚ùå Erro", "N√£o foi poss√≠vel salvar a nova ordem.", 4000);
    } finally {
        membroParaOrdenarMedalhas = null;
        ordemMedalhasTemporaria = [];
    }
}
window.abrirModalOrdenarMedalhas = abrirModalOrdenarMedalhas; // Torna global

// --- NOVA FUN√á√ÉO: Enviar Agradecimento pela Medalha ---
async function enviarAgradecimentoMedalha(remetenteId, medalhaNome) {
  if (!remetenteId || !currentUser) return;

  const agradecerBtn = document.getElementById('medalha-ganha-agradecer-btn');
  agradecerBtn.disabled = true;
  agradecerBtn.textContent = 'Enviando...';

  try {
    const notificacaoRef = doc(collection(db, "notificacoes"));
    await setDoc(notificacaoRef, {
      destinatarioId: remetenteId, // O remetente original da medalha
      remetenteNome: currentUser,  // Quem est√° agradecendo
      tipo: 'medalha-agradecimento', // Um novo tipo para o √≠cone que voc√™ pode configurar
      conteudo: 'üíñ', // Emoji de agradecimento
      acao: `agradeceu pela medalha <strong>${medalhaNome}</strong> que voc√™ enviou!`,
      lida: false,
      timestamp: new Date()
    });

    agradecerBtn.textContent = 'Agradecimento Enviado!';
    mostrarPopup("‚úÖ Sucesso", `Seu agradecimento foi enviado para ${remetenteId}!`, 4000);

  } catch (error) {
    console.error("Erro ao enviar agradecimento:", error);
    mostrarPopup("‚ùå Erro", "N√£o foi poss√≠vel enviar o agradecimento.", 3000);
    agradecerBtn.disabled = false;
    agradecerBtn.textContent = 'Enviar Agradecimento üíñ';
  }
}

// --- NOVA FUN√á√ÉO: Executa a compra de uma medalha para o pr√≥prio l√≠der ---
async function executarCompraMedalhaParaMim(medalhaId) {
    const medalhaInfo = todasMedalhasHonra.find(m => m.id === medalhaId);
    if (!medalhaInfo) {
        mostrarPopup("‚ùå Erro Interno", "N√£o foi poss√≠vel encontrar os dados desta medalha.", 4000);
        return;
    }

    const liderRef = doc(db, "membros", currentUser);
    const bancoRef = doc(db, "bancosEquipes", userTeam);
    const valor = medalhaInfo.valor;

    // --- IN√çCIO DA NOVA L√ìGICA: MOSTRAR POPUP DE CONFIRMA√á√ÉO COM OP√á√ïES ---
    // Precisamos buscar os saldos ANTES de mostrar o popup
    let saldoPessoal = 0;
    let saldoBanco = 0;
    try {
        const membroDoc = await getDoc(liderRef);
        saldoPessoal = membroDoc.exists() ? membroDoc.data().moedas || 0 : 0;
        saldoBanco = saldosBancosEquipes[userTeam] || 0;
    } catch (e) {
        mostrarPopup("‚ùå Erro", "N√£o foi poss√≠vel buscar seus saldos.", 4000);
        return;
    }

    // Cria o HTML para as op√ß√µes de pagamento
    const opcoesPagamentoHTML = `
      <div id="compra-mim-fonte-pagamento" style="margin: 15px 0; text-align: left;">
        <div class="fonte-pagamento-opcoes" style="margin-bottom: 10px;">
          <input type="radio" id="fonte-mim-pessoal" name="fonte-pagamento-mim" value="pessoal" ${saldoPessoal >= valor ? 'checked' : 'disabled'}>
          <label for="fonte-mim-pessoal" style="font-size: 1.1rem;">
            Meu Saldo (üí∞${saldoPessoal.toLocaleString('pt-BR')})
          </label>
        </div>
        <div class="fonte-pagamento-opcoes">
          <input type="radio" id="fonte-mim-banco" name="fonte-pagamento-mim" value="banco" ${saldoPessoal < valor && saldoBanco >= valor ? 'checked' : ''} ${saldoBanco < valor ? 'disabled' : ''}>
          <label for="fonte-mim-banco" style="font-size: 1.1rem;">
            Banco da Equipe (üí∞${saldoBanco.toLocaleString('pt-BR')})
          </label>
        </div>
      </div>
    `;

    // Mostra o popup de confirma√ß√£o
    showConfirmationPopup(
        'Confirmar Compra Pessoal',
        `Voc√™ deseja comprar a medalha "${medalhaInfo.nome}" por <strong>üí∞ ${valor.toLocaleString('pt-BR')}</strong> para si mesmo?` + opcoesPagamentoHTML,
        async () => { // Fun√ß√£o a ser executada se o usu√°rio confirmar
            
            // Pega a fonte de pagamento escolhida no popup
            const fontePagamentoEl = document.querySelector('input[name="fonte-pagamento-mim"]:checked');
            if (!fontePagamentoEl) {
                mostrarPopup("‚ùå Erro", "Nenhuma fonte de pagamento selecionada ou com saldo.", 4000);
                return;
            }
            const fontePagamento = fontePagamentoEl.value;
            
            try {
                // =======================================================
                // ===== IN√çCIO DA ALTERA√á√ÉO (BLOCO TRY/CATCH INTERNO) =====
                // =======================================================
                const batch = writeBatch(db); // <<< MUDAN√áA: Usando BATCH
                let fonteRef, saldoFonte;

                if (fontePagamento === 'banco') {
                    const bancoDoc = await getDoc(bancoRef); // <<< MUDAN√áA: Leitura simples
                    saldoFonte = bancoDoc.exists() ? bancoDoc.data().saldo || 0 : 0;
                    fonteRef = bancoRef;
                } else {
                    const liderDoc = await getDoc(liderRef); // <<< MUDAN√áA: Leitura simples
                    saldoFonte = liderDoc.exists() ? liderDoc.data().moedas || 0 : 0;
                    fonteRef = liderRef;
                }

                if (saldoFonte < valor) throw "Saldo insuficiente na fonte selecionada.";

                const campoSaldo = (fontePagamento === 'banco') ? 'saldo' : 'moedas';
                batch.update(fonteRef, { [campoSaldo]: increment(-valor) }); // Debita
                
                // Adiciona a medalha ao invent√°rio do l√≠der
                batch.update(liderRef, { medalhasInventario: arrayUnion(medalhaId) });
                
                if(fontePagamento === 'banco') {
                    const movRef = doc(collection(bancoRef, "movimentacoes"));
                    batch.set(movRef, {
                        tipo: 'compra_medalha',
                        valor: valor,
                        descricao: `Compra da medalha "${medalhaInfo.nome}" para ${currentUser}`,
                        membroId: currentUser,
                        timestamp: new Date()
                    });
                }
                
                // <<< MUDAN√áA PRINCIPAL: CRIA UMA NOTIFICA√á√ÉO PARA SI MESMO >>>
                const notificacaoRef = doc(collection(db, "notificacoes"));
                batch.set(notificacaoRef, {
                    destinatarioId: currentUser,
                    remetenteNome: "Lojista", // Remetente "Sistema"
                    tipo: 'medalha-presente', // Mesmo tipo de um presente
                    conteudo: 'üèÖ',
                    acao: `voc√™ comprou a Medalha de Honra: **${medalhaInfo.nome}**!`,
                    lida: false, // Come√ßa como "n√£o lida" para o popup pegar
                    timestamp: new Date(),
                    medalhaId: medalhaId // Adiciona o ID da medalha
                });
                
                await batch.commit(); // Executa a transa√ß√£o
                
                // =======================================================
                // ===== IN√çCIO DA NOVA ALTERA√á√ÉO (PASSO 4) =====
                // =======================================================
                // Adiciona o evento ao feed do resumo semanal
                await adicionarEventoAoFeed(
                  'medalha', // tipo
                  'üèÖ Nova Medalha de Honra!', // titulo
                  `<strong>${currentUser}</strong> comprou para si a Medalha de Honra: <strong>${medalhaInfo.nome}</strong>!`, // texto
                  { nomeMembro: currentUser, medalha: medalhaInfo.nome } // dadosExtras
                );
                // =======================================================
                // ===== FIM DA NOVA ALTERA√á√ÉO =====
                // =======================================================
                
                // =======================================================
                // ===== FIM DA ALTERA√á√ÉO (BLOCO TRY/CATCH INTERNO) ======
                // =======================================================


                // --- L√≥gica P√≥s-Transa√ß√£o (Atualiza cache local) ---
                if (!medalhasInventarioCache[currentUser]) medalhasInventarioCache[currentUser] = [];
                medalhasInventarioCache[currentUser].push(medalhaId);

                // REMOVIDO: As linhas que chamavam 'mostrarPopupMedalhaGanha' e criavam 'dailyMemberState'
                // foram removidas. A notifica√ß√£o cuidar√° disso.

                mostrarPopup("‚úÖ Sucesso!", `Medalha "${medalhaInfo.nome}" adicionada ao seu invent√°rio!`, 5000);
                closeModal('detalhes-medalha-modal');
                await carregarDadosMedalhasHonra(); // Atualiza a UI

            } catch (error) {
                console.error("Erro ao comprar medalha para si mesmo:", error);
                mostrarPopup("‚ùå Erro na Compra", error.toString(), 5000);
            }
        }
    );
}

// --- NOVA FUN√á√ÉO: Abrir Modal de Informa√ß√µes da Medalha ---
window.abrirModalInfoMedalha = function(medalhaId) {
    const medalhaData = todasMedalhasHonra.find(m => m.id === medalhaId);
    if (!medalhaData) {
        console.error("Dados da medalha n√£o encontrados:", medalhaId);
        mostrarPopup("‚ùå Erro", "N√£o foi poss√≠vel carregar os detalhes desta medalha.", 3000);
        return;
    }

    // Popula os elementos do modal
    document.getElementById('modal-medalha-nome').textContent = medalhaData.nome;
    document.getElementById('modal-medalha-img').src = medalhaData.link;
    const raridadeEl = document.getElementById('modal-medalha-raridade');
    raridadeEl.textContent = medalhaData.categoria;
    document.getElementById('modal-medalha-valor').textContent = `üí∞ ${medalhaData.valor.toLocaleString('pt-BR')}`;

    // Limpa classes de raridade antigas e adiciona a correta
    raridadeEl.classList.remove('comum', 'incomum', 'rara', 'lendaria'); // Remove todas as classes de raridade
    const raridadeNormalizada = medalhaData.categoria.normalize('NFD').replace(/[\u0300-\u036f]/g, "").toLowerCase();
    raridadeEl.classList.add(raridadeNormalizada); // Adiciona a classe correta

    // Abre o modal
    openModal('medalha-info-modal');
}

// --- FUN√á√ïES PARA O POPUP DE MEDALHA GANHA ---

// Fun√ß√£o espec√≠fica para o confete deste popup
function dispararConfeteMedalhaGanha() {
    const confettiCanvas = document.getElementById("medalha-ganha-confetti");
    if (!confettiCanvas) return;

    const confettiCtx = confettiCanvas.getContext('2d');
    confettiCanvas.width = window.innerWidth;
    confettiCanvas.height = window.innerHeight;
    const confettiParticles = [];
    const particleCount = 300; // Mais part√≠culas
    // Cores mais vibrantes e douradas
    const colors = ["#FFD700", "#FFA500", "#FF6347", "#FFEC8B", "#FFFFFF", "#FF4500"];

    for (let i = 0; i < particleCount; i++) {
      confettiParticles.push({
        x: Math.random() * confettiCanvas.width,
        y: -Math.random() * confettiCanvas.height * 1.5, // Come√ßam mais de cima
        w: Math.random() * 8 + 6,
        h: Math.random() * 15 + 10,
        color: colors[Math.floor(Math.random() * colors.length)],
        angle: Math.random() * Math.PI * 2,
        speed: Math.random() * 5 + 3, // Mais r√°pido
        spin: Math.random() * 0.5 - 0.25,
        drift: Math.random() * 3 - 1.5
      });
    }

    let animationFrameId;
    function animateConfetti() {
      confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height);
      let particlesAlive = 0;
      for (let i = 0; i < confettiParticles.length; i++) {
        const p = confettiParticles[i];
        p.y += p.speed;
        p.x += p.drift;
        p.angle += p.spin;

        confettiCtx.save();
        confettiCtx.translate(p.x + p.w / 2, p.y + p.h / 2);
        confettiCtx.rotate(p.angle);
        confettiCtx.fillStyle = p.color;
        confettiCtx.fillRect(-p.w / 2, -p.h / 2, p.w, p.h);
        confettiCtx.restore();

        if (p.y < confettiCanvas.height) {
          particlesAlive++;
        }
      }
      if (particlesAlive > 0) {
        animationFrameId = requestAnimationFrame(animateConfetti);
      } else {
        confettiCtx.clearRect(0, 0, confettiCanvas.width, confettiCanvas.height); // Limpa no final
      }
    }
    // Garante que anima√ß√µes anteriores sejam canceladas
    if (window.medalhaConfettiAnimation) cancelAnimationFrame(window.medalhaConfettiAnimation);
    window.medalhaConfettiAnimation = requestAnimationFrame(animateConfetti);
}

// =============================================
// NOVAS FUN√á√ïES: POPUP DE PIX RECEBIDO
// =============================================

/**
 * (NOVA) Dispara a anima√ß√£o com emojis üí∞.
 */
function dispararConfetePix() {
    const canvas = document.getElementById('pix-recebido-confetti');
    if (!canvas) return;

    // Usamos o canvas 2D para controle
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    const particles = [];
    const particleCount = 70; // Quantidade de emojis caindo

    for (let i = 0; i < particleCount; i++) {
        particles.push({
            x: Math.random() * canvas.width,
            y: -Math.random() * canvas.height, // Come√ßa acima da tela
            speed: Math.random() * 3 + 2,      // Velocidade de queda
            rotation: Math.random() * 360,     // Rota√ß√£o inicial
            size: Math.random() * 15 + 20      // Tamanho da fonte (20px a 35px)
        });
    }

    let animationFrameId;

    function animateConfetti() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        let particlesAlive = 0;

        for (let i = 0; i < particles.length; i++) {
            const p = particles[i];
            p.y += p.speed;
            p.rotation += p.speed / 5; // Gira o emoji enquanto cai

            // Define o tamanho e a fonte
            ctx.font = `${p.size}px Arial`;
            ctx.save();
            ctx.translate(p.x, p.y);
            ctx.rotate(p.rotation * Math.PI / 180);
            ctx.fillText('üí∞', -p.size / 2, p.size / 2); // Desenha o emoji
            ctx.restore();

            if (p.y < canvas.height) {
                particlesAlive++;
            }
        }

        if (particlesAlive > 0) {
            animationFrameId = requestAnimationFrame(animateConfetti);
        } else {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // Limpa o canvas e para a anima√ß√£o
            if (window.pixConfettiAnimation) {
                 cancelAnimationFrame(window.pixConfettiAnimation);
                 window.pixConfettiAnimation = null;
            }
        }
    }

    // Garante que anima√ß√µes anteriores sejam canceladas
    if (window.pixConfettiAnimation) cancelAnimationFrame(window.pixConfettiAnimation);
    window.pixConfettiAnimation = requestAnimationFrame(animateConfetti);
}

async function enviarAgradecimentoPix(remetente, valor, transacaoId, notificacaoId) {
    // =============================================
    // ===== ALTERA√á√ÉO 1: 'valor' foi adicionado =====
    // =============================================
    if (!remetente || !currentUser || !valor) return;

    const btn = document.getElementById('pix-recebido-agradecer-btn');
    btn.disabled = true;
    btn.textContent = 'Agradecimento Enviado! ‚úîÔ∏è';

    try {
        // =============================================
        // ===== ALTERA√á√ÉO 2: Nova string de 'acao' =====
        // =============================================
        // Criamos a nova string de 'acao' formatada
        const acaoFormatada = `agradeceu pelo seu Pix de <strong>${valor} üí∞ moedas</strong>! üíñ<br><small style="opacity: 0.7;">(C√≥d: ${transacaoId})</small>`;
        
        // 1. Envia uma nova notifica√ß√£o para o remetente original
        await addDoc(collection(db, "notificacoes"), {
            destinatarioId: remetente,
            remetenteNome: currentUser,
            tipo: 'agradecimento_pix', 
            conteudo: 'üí∏',
            acao: acaoFormatada, // A nova a√ß√£o formatada
            lida: false,
            timestamp: new Date()
        });
        // =============================================
        // ===== FIM DAS ALTERA√á√ïES =====
        // =============================================

        // 2. Marca na notifica√ß√£o original que o agradecimento foi enviado
        if (notificacaoId) {
            await updateDoc(doc(db, "notificacoes", notificacaoId), {
                agradecimentoEnviado: true
            });
        }
        
        mostrarPopup("‚úÖ Enviado!", `Seu agradecimento foi enviado para ${remetente}.`, 3000);

    } catch (error) {
        console.error("Erro ao enviar agradecimento Pix:", error);
        mostrarPopup("‚ùå Erro", "N√£o foi poss√≠vel enviar o agradecimento.", 3000);
        btn.disabled = false;
        btn.textContent = 'Enviar Agradecimento üíñ';
    }
}

// =============================================
// ===== NOVAS FUN√á√ïES: POPUP DE RECOMPENSA L√çDER =====
// (COLE ESTE BLOCO INTEIRO)
// =============================================

/**
 * (NOVA) Dispara a anima√ß√£o com emojis üèÜ.
 */
function dispararConfeteRecompensa() {
    const canvas = document.getElementById('recompensa-recebida-confetti');
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    const particles = [];
    const particleCount = 70; 

    for (let i = 0; i < particleCount; i++) {
        particles.push({
            x: Math.random() * canvas.width,
            y: -Math.random() * canvas.height,
            speed: Math.random() * 3 + 2,
            rotation: Math.random() * 360,
            size: Math.random() * 15 + 20
        });
    }

    let animationFrameId;

    function animateConfetti() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        let particlesAlive = 0;

        for (let i = 0; i < particles.length; i++) {
            const p = particles[i];
            p.y += p.speed;
            p.rotation += p.speed / 5;
            ctx.font = `${p.size}px Arial`;
            ctx.save();
            ctx.translate(p.x, p.y);
            ctx.rotate(p.rotation * Math.PI / 180);
            ctx.fillText('üèÜ', -p.size / 2, p.size / 2); // Emoji de Trof√©u
            ctx.restore();

            if (p.y < canvas.height) {
                particlesAlive++;
            }
        }

        if (particlesAlive > 0) {
            animationFrameId = requestAnimationFrame(animateConfetti);
        } else {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (window.recompensaConfettiAnimation) {
                 cancelAnimationFrame(window.recompensaConfettiAnimation);
                 window.recompensaConfettiAnimation = null;
            }
        }
    }

    if (window.recompensaConfettiAnimation) cancelAnimationFrame(window.recompensaConfettiAnimation);
    window.recompensaConfettiAnimation = requestAnimationFrame(animateConfetti);
}

/**
 * (NOVA) Envia uma notifica√ß√£o de agradecimento de volta ao l√≠der.
 */
async function enviarAgradecimentoRecompensa(remetente, valor, notificacaoId) {
    if (!remetente || !currentUser || !valor) return;

    const btn = document.getElementById('recompensa-recebida-agradecer-btn');
    btn.disabled = true;
    btn.textContent = 'Agradecimento Enviado! ‚úîÔ∏è';

    try {
        const acaoFormatada = `agradeceu pela sua recompensa de <strong>${valor.toLocaleString('pt-BR')} üí∞ moedas</strong>! üíñ`;
        
        // 1. Envia uma nova notifica√ß√£o para o remetente original
        await addDoc(collection(db, "notificacoes"), {
            destinatarioId: remetente,
            remetenteNome: currentUser,
            tipo: 'agradecimento_recompensa', 
            conteudo: '',
            acao: acaoFormatada,
            lida: false,
            timestamp: new Date()
        });

        // 2. Marca na notifica√ß√£o original que o agradecimento foi enviado
        if (notificacaoId) {
            await updateDoc(doc(db, "notificacoes", notificacaoId), {
                agradecimentoEnviado: true
            });
        }
        
        mostrarPopup("‚úÖ Enviado!", `Seu agradecimento foi enviado para ${remetente}.`, 3000);

    } catch (error) {
        console.error("Erro ao enviar agradecimento de Recompensa:", error);
        mostrarPopup("‚ùå Erro", "N√£o foi poss√≠vel enviar o agradecimento.", 3000);
        btn.disabled = false;
        btn.textContent = 'Enviar Agradecimento üíñ';
    }
}

/**
 * (NOVA) Exibe o popup de recompensa recebida.
 */
function mostrarPopupRecompensaRecebida(remetente, valor, notificacaoId, agradecimentoJaEnviado) {
    // Preenche os dados
    document.getElementById('recompensa-recebida-titulo').innerHTML = `üèÜ Recompensa Recebida de ${remetente}!`;
    document.getElementById('recompensa-recebida-mensagem').innerHTML = 
        `Voc√™ recebeu <strong>${valor.toLocaleString('pt-BR')} üí∞ moedas</strong> de <strong>${remetente}</strong> pelo seu desempenho!`;

    // Configura o bot√£o de agradecimento
    const agradecimentoContainer = document.getElementById('recompensa-recebida-agradecimento-container');
    const btn = document.getElementById('recompensa-recebida-agradecer-btn');
    
    agradecimentoContainer.classList.remove('hidden');

    if (agradecimentoJaEnviado) {
        btn.textContent = 'Agradecimento J√° Enviado';
        btn.disabled = true;
    } else {
        btn.textContent = 'Enviar Agradecimento üíñ';
        btn.disabled = false;
        btn.onclick = () => enviarAgradecimentoRecompensa(remetente, valor, notificacaoId);
    }

    // Toca o som e dispara a anima√ß√£o
    tocarSom('som-conquista');
    dispararConfeteRecompensa();
    
    const overlay = document.getElementById('recompensa-recebida-popup');
    if (overlay) {
      const bodyClass = document.body.className;
      overlay.classList.remove('tema-noite', 'tema-manha', 'tema-tarde');
      if (bodyClass.includes('tema-noite')) overlay.classList.add('tema-noite');
      else if (bodyClass.includes('tema-manha')) overlay.classList.add('tema-manha');
      else if (bodyClass.includes('tema-tarde')) overlay.classList.add('tema-tarde');
    }

    openModal('recompensa-recebida-popup');
}

function mostrarPopupPixRecebido(remetente, valor, comentario, notificacaoId, transacaoId, agradecimentoJaEnviado) {
    // Preenche os dados
    document.getElementById('pix-recebido-titulo').innerHTML = `üí∏ Pix Recebido de ${remetente}!`;
    document.getElementById('pix-recebido-mensagem').innerHTML = 
        `Voc√™ recebeu <strong>${valor} üí∞ moedas</strong> de <strong>${remetente}</strong>.`;

    const comentarioEl = document.getElementById('pix-recebido-comentario');
    if (comentario && comentario !== 'Nenhum coment√°rio.') {
        comentarioEl.textContent = `${comentario}`;
        comentarioEl.classList.remove('hidden');
    } else {
        comentarioEl.classList.add('hidden');
    }

    // Configura o bot√£o de agradecimento
    const agradecimentoContainer = document.getElementById('pix-recebido-agradecimento-container');
    const btn = document.getElementById('pix-recebido-agradecer-btn');
    
    agradecimentoContainer.classList.remove('hidden');

    if (agradecimentoJaEnviado) {
        btn.textContent = 'Agradecimento J√° Enviado';
        btn.disabled = true;
    } else {
        btn.textContent = 'Enviar Agradecimento üíñ';
        btn.disabled = false;
        // =============================================
        // ===== ALTERA√á√ÉO PRINCIPAL EST√Å AQUI =====
        // =============================================
        // Agora, passamos o 'valor' para a fun√ß√£o 'enviarAgradecimentoPix'
        btn.onclick = () => enviarAgradecimentoPix(remetente, valor, transacaoId, notificacaoId);
        // =============================================
        // ===== FIM DA ALTERA√á√ÉO =====
        // =============================================
    }

    // Toca o som e dispara a anima√ß√£o
    tocarSom('som-conquista'); // Reutiliza o som de conquista
    dispararConfetePix();
    
    const overlay = document.getElementById('pix-recebido-popup');
    if (overlay) {
      // Limpa classes de tema antigas e adiciona a correta
      const bodyClass = document.body.className;
      overlay.classList.remove('tema-noite', 'tema-manha', 'tema-tarde');

      if (bodyClass.includes('tema-noite')) {
        overlay.classList.add('tema-noite');
      } else if (bodyClass.includes('tema-manha')) {
        overlay.classList.add('tema-manha');
      } else if (bodyClass.includes('tema-tarde')) {
        overlay.classList.add('tema-tarde');
      }
    }

    // Abre o modal
    openModal('pix-recebido-popup');
}

// Fun√ß√£o para mostrar e popular o popup
function mostrarPopupMedalhaGanha(medalhaData, quemDeu, comentario) {
¬† ¬† if (!medalhaData) return;

¬† ¬† document.getElementById('medalha-ganha-img').src = medalhaData.link;
¬† ¬† document.getElementById('medalha-ganha-nome').textContent = medalhaData.nome;
¬† ¬† const raridadeEl = document.getElementById('medalha-ganha-raridade');
¬† ¬† raridadeEl.textContent = medalhaData.categoria;
¬† ¬† document.getElementById('medalha-ganha-valor').textContent = `üí∞ ${medalhaData.valor.toLocaleString('pt-BR')}`;

¬† ¬† raridadeEl.classList.remove('comum', 'incomum', 'rara', 'lendaria');
¬† ¬† const raridadeNormalizada = medalhaData.categoria.normalize('NFD').replace(/[\u0300-\u036f]/g, "").toLowerCase();
¬† ¬† raridadeEl.classList.add(raridadeNormalizada);

¬† ¬† const origemEl = document.getElementById('medalha-ganha-origem');
¬† ¬† if (quemDeu && quemDeu !== currentUser) {
¬† ¬† ¬† ¬† origemEl.innerHTML = `Um presente especial de <strong>${quemDeu}</strong>! ‚ú®`;
¬† ¬† } else {
¬† ¬† ¬† ¬† origemEl.innerHTML = `Voc√™ adquiriu esta medalha! Parab√©ns pela sua conquista!`;
¬† ¬† }

¬† ¬† // Exibe o coment√°rio
¬† ¬† const comentarioEl = document.getElementById('medalha-ganha-comentario');
¬† ¬† if (comentario) {
¬† ¬† ¬† ¬† comentarioEl.innerHTML = `"${comentario.replace(/\n/g, '<br>')}"`;
¬† ¬† ¬† ¬† comentarioEl.classList.remove('hidden');
¬† ¬† } else {
¬† ¬† ¬† ¬† comentarioEl.innerHTML = '';
¬† ¬† ¬† ¬† comentarioEl.classList.add('hidden');
¬† ¬† }

¬† ¬† // =============================================
¬† ¬† // ===== IN√çCIO DA ALTERA√á√ÉO: L√≥gica do Bot√£o de Agradecimento =====
¬† ¬† // =============================================
¬† ¬† const agradecerContainer = document.getElementById('medalha-ganha-agradecimento-container');
¬† ¬† const agradecerBtn = document.getElementById('medalha-ganha-agradecer-btn');

¬† ¬† // Reseta o bot√£o para o estado padr√£o
¬† ¬† agradecerBtn.disabled = false;
¬† ¬† agradecerBtn.textContent = 'Enviar Agradecimento üíñ';
¬† 
¬† ¬† // L√≥gica para mostrar o bot√£o:
¬† ¬† // 1. Deve haver um remetente (quemDeu).
¬† ¬† // 2. O remetente N√ÉO PODE ser o usu√°rio atual (currentUser).
¬† ¬† if (quemDeu && quemDeu !== currentUser) {
¬† ¬† ¬† ¬† agradecerContainer.classList.remove('hidden');
¬† ¬† ¬† ¬† // Remove o listener antigo e adiciona um novo para garantir
¬† ¬† ¬† ¬† agradecerBtn.onclick = null; // Limpa o clique antigo
¬† ¬† ¬† ¬† // (Aten√ß√£o: A fun√ß√£o 'enviarAgradecimentoMedalha' deve ser colada conforme o Passo 2)
¬† ¬† ¬† ¬† agradecerBtn.onclick = () => enviarAgradecimentoMedalha(quemDeu, medalhaData.nome);
¬† ¬† } else {
¬† ¬† ¬† ¬† agradecerContainer.classList.add('hidden');
¬† ¬† }
¬† ¬† // =============================================
¬† ¬† // ===== FIM DA ALTERA√á√ÉO =====
¬† ¬† // =============================================

¬† ¬† const overlay = document.getElementById('medalha-ganha-popup');
¬† ¬† overlay.classList.remove('tema-noite', 'tema-manha', 'tema-tarde');
¬† ¬† const bodyClass = document.body.className;
¬† ¬† if (bodyClass.includes('tema-noite')) overlay.classList.add('tema-noite');
¬† ¬† else if (bodyClass.includes('tema-manha')) overlay.classList.add('tema-manha');
¬† ¬† else if (bodyClass.includes('tema-tarde')) overlay.classList.add('tema-tarde');

¬† ¬† openModal('medalha-ganha-popup');
¬† ¬† tocarSom('som-conquista');¬†
¬† ¬† dispararConfeteMedalhaGanha();¬†
}

async function verificarEExibirPopupNovaMedalha() {
    if (!currentUser || todasMedalhasHonra.length === 0) return; 

    try {
        const q = query(
            collection(db, "notificacoes"),
            where("destinatarioId", "==", currentUser),
            where("tipo", "==", "medalha-presente"),
            where("lida", "==", false),
            orderBy("timestamp", "desc")
        );

        const notificacoesSnap = await getDocs(q);

        if (notificacoesSnap.empty) {
            console.log("Nenhum popup de nova medalha para exibir.");
            return;
        }

        console.log(`Encontradas ${notificacoesSnap.size} notifica√ß√µes de medalhas n√£o lidas.`);

        const batch = writeBatch(db); 

        for (const docNotif of notificacoesSnap.docs) {
            const notificacaoData = docNotif.data();
            const medalhaId = notificacaoData.medalhaId;
            const quemDeu = notificacaoData.remetenteNome;
            
            // =============================================
            // ===== IN√çCIO DA ALTERA√á√ÉO (PASSO 5.1) =====
            // =============================================
            // 1. L√™ o novo campo "comentario" da notifica√ß√£o
            const comentario = notificacaoData.comentario; 
            // =============================================
            // ===== FIM DA ALTERA√á√ÉO (PASSO 5.1) =====
            // =============================================

            if (medalhaId) {
                const medalhaData = todasMedalhasHonra.find(m => m.id === medalhaId);
                
                if (medalhaData) {
                    // =============================================
                    // ===== IN√çCIO DA ALTERA√á√ÉO (PASSO 5.2) =====
                    // =============================================
                    // 2. Passa o coment√°rio para a fun√ß√£o que mostra o popup
                    mostrarPopupMedalhaGanha(medalhaData, (quemDeu === "Lojista" ? null : quemDeu), comentario);
                    // =============================================
                    // ===== FIM DA ALTERA√á√ÉO (PASSO 5.2) =====
                    // =============================================
                }
                
                batch.update(docNotif.ref, { lida: true });
            }
        }
        
        await batch.commit();

    } catch (error)
        {
        console.error("Erro ao verificar ou exibir popup de nova medalha:", error);
    }
}


// =============================================
// ===== FIM DAS FUN√á√ïES MEDALHAS DE HONRA =====
// =============================================

// =============================================
// ===== IN√çCIO: FUN√á√ïES DO BANCO DAS EQUIPES =====
// =============================================

/**
 * Carrega e ouve as altera√ß√µes nos saldos dos bancos das equipes.
 */
async function carregarBancosEquipes() {
  if (unsubscribeBancosListener) {
    unsubscribeBancosListener();
  }

  const q = query(collection(db, "bancosEquipes"));
  
  unsubscribeBancosListener = onSnapshot(q, (querySnapshot) => {
    // Reseta os saldos locais
    saldosBancosEquipes = { abelha: 0, joaninha: 0, vagalume: 0 };
    
    querySnapshot.forEach(doc => {
      const equipeId = doc.id;
      const data = doc.data();
      if (saldosBancosEquipes.hasOwnProperty(equipeId)) {
        saldosBancosEquipes[equipeId] = data.saldo || 0;
      }
    });

    // Atualiza a interface gr√°fica
    atualizarInterfaceBancos();
  }, (error) => {
    console.error("Erro ao carregar saldos dos bancos:", error);
  });
}

/**
 * Atualiza os valores nos cards coloridos da se√ß√£o do banco.
 */
function atualizarInterfaceBancos() {
  for (const equipeId in saldosBancosEquipes) {
    const saldoEl = document.getElementById(`banco-saldo-${equipeId}`);
    if (saldoEl) {
      saldoEl.textContent = saldosBancosEquipes[equipeId].toLocaleString('pt-BR');
    }
  }
}

/**
 * Abre o modal para o membro enviar moedas ao banco da sua equipe.
 */
async function abrirModalEnviarMoedasBanco() {
  if (!currentUser || !userTeam) {
    mostrarPopup("üö´ Acesso Negado", "Voc√™ precisa estar em uma equipe para enviar moedas ao banco.", 4000);
    return;
  }

  try {
    const membroDoc = await getDoc(doc(db, "membros", currentUser));
    if (!membroDoc.exists()) return;

    const saldoPessoal = membroDoc.data().moedas || 0;
    document.querySelector("#enviar-moedas-saldo-pessoal span").textContent = saldoPessoal.toLocaleString('pt-BR');
    document.getElementById("enviar-moedas-nome-equipe").textContent = userTeam.charAt(0).toUpperCase() + userTeam.slice(1);
    document.getElementById('input-valor-banco').value = '';
    
    openModal('enviar-moedas-banco-modal');
  } catch (error) {
    console.error("Erro ao buscar saldo pessoal para envio ao banco:", error);
    mostrarPopup("‚ùå Erro", "N√£o foi poss√≠vel buscar seu saldo atual.", 4000);
  }
}

/**
 * Executa a transa√ß√£o de envio de moedas do membro para o banco da equipe.
 */
async function executarEnvioMoedasBanco() {
  if (!currentUser || !userTeam) return;

  const inputValor = document.getElementById('input-valor-banco');
  const valor = parseInt(inputValor.value, 10);

  if (isNaN(valor) || valor <= 0) {
    mostrarPopup("‚ùå Valor Inv√°lido", "Por favor, digite um valor positivo.", 3000);
    return;
  }

  const membroRef = doc(db, "membros", currentUser);
  const bancoRef = doc(db, "bancosEquipes", userTeam);
  
  // Trava para evitar cliques duplos
  const btn = document.getElementById('enviar-moedas-banco-confirmar-btn');
  btn.disabled = true;
  btn.textContent = "Enviando...";

  try {
    await runTransaction(db, async (transaction) => {
      const membroDoc = await transaction.get(membroRef);
      if (!membroDoc.exists()) throw "Membro n√£o encontrado.";

      const saldoPessoal = membroDoc.data().moedas || 0;
      if (saldoPessoal < valor) {
        throw `Saldo insuficiente. Voc√™ tem apenas ${saldoPessoal} moedas.`;
      }

      // 1. Debita do membro
      transaction.update(membroRef, { moedas: increment(-valor) });

      // 2. Credita no banco da equipe (cria o banco se n√£o existir)
      transaction.set(bancoRef, { saldo: increment(valor) }, { merge: true });

      // 3. Registra a movimenta√ß√£o no extrato do banco
      const movimentacaoRef = doc(collection(db, "bancosEquipes", userTeam, "movimentacoes"));
      transaction.set(movimentacaoRef, {
        tipo: 'deposito',
        membroId: currentUser,
        valor: valor,
        descricao: `Dep√≥sito de ${currentUser}`,
        timestamp: new Date()
      });
    });

    // 4. Adiciona ao feed semanal
    await adicionarEventoAoFeed(
      'geral',
      'üí∏ Contribui√ß√£o ao Banco!',
      `<strong>${currentUser}</strong> enviou <strong>${valor.toLocaleString('pt-BR')} üí∞ moedas</strong> para o banco da Equipe ${userTeam}!`,
      { nomeMembro: currentUser, equipe: userTeam }
    );

    mostrarPopup("‚úÖ Sucesso!", `Voc√™ enviou ${valor.toLocaleString('pt-BR')} moedas para o banco da equipe!`, 5000);
    closeModal('enviar-moedas-banco-modal');

  } catch (error) {
    console.error("Erro ao enviar moedas para o banco:", error);
    mostrarPopup("‚ùå Falha na Transa√ß√£o", error.toString(), 5000);
  } finally {
    btn.disabled = false;
    btn.textContent = "Confirmar Envio";
  }
}

async function processarJurosEAutolimpezaBancos() {
  const hojeISO = getHojeISO();
  
  const taskRef = doc(db, "appState", "bancoJurosState"); 
  
  try {
    const taskDoc = await getDoc(taskRef);
    
    if (taskDoc.exists() && taskDoc.data().jurosProcessadoPara === hojeISO) {
      return;
    }

    const bancosRef = collection(db, "bancosEquipes");
    const bancosSnapshot = await getDocs(bancosRef);
    const batch = writeBatch(db);

    // 1. Processar Juros
    bancosSnapshot.forEach(bancoDoc => { 
      const equipeId = bancoDoc.id;
      const saldoAtual = bancoDoc.data().saldo || 0;
      const juros = Math.floor(saldoAtual * 0.03); 

      if (juros > 0) {
        const bancoRef = bancoDoc.ref;
        batch.update(bancoRef, { saldo: increment(juros) });

        const movRef = doc(collection(bancoRef, "movimentacoes"));
        batch.set(movRef, {
          tipo: 'juros',
          valor: juros,
          descricao: `Rendimento de 3% sobre o saldo`,
          timestamp: new Date()
        });
      }
    });

    // 2. Processar Limpeza de Extratos Antigos (transa√ß√µes com +30 dias)
    const dataCorte = new Date();
    dataCorte.setDate(dataCorte.getDate() - 30);

    for (const bancoDoc of bancosSnapshot.docs) { 
      const equipeId = bancoDoc.id;
      const movRef = collection(bancoDoc.ref, "movimentacoes");
      const q = query(movRef, where("timestamp", "<", dataCorte));
      
      const movSnapshot = await getDocs(q);
      if (!movSnapshot.empty) {
        movSnapshot.forEach(movDoc => {
          batch.delete(movDoc.ref);
        });
      }
    }

    // 3. Marcar a tarefa como conclu√≠da no NOVO documento de trava
    batch.set(taskRef, { jurosProcessadoPara: hojeISO }, { merge: true });

    await batch.commit();

  } catch (error) {
    console.error("Erro cr√≠tico no processamento de juros do banco:", error);
  }
}

/**
 * Abre o modal de extrato do banco da equipe do usu√°rio.
 */
async function abrirModalExtratoBanco() {
  if (!currentUser || !userTeam) {
    mostrarPopup("üö´ Acesso Negado", "Voc√™ precisa estar em uma equipe para ver o extrato.", 4000);
    return;
  }

  const nomeEquipeCapitalizado = userTeam.charAt(0).toUpperCase() + userTeam.slice(1);
  document.getElementById('extrato-banco-titulo').textContent = `üßæ Extrato (${nomeEquipeCapitalizado})`;
  const listaEl = document.getElementById('extrato-banco-lista');
  listaEl.innerHTML = '<div class="ociosos-placeholder">Carregando...</div>';
  openModal('extrato-banco-modal');

  try {
    const movRef = collection(db, "bancosEquipes", userTeam, "movimentacoes");
    const q = query(movRef, orderBy("timestamp", "desc"), limit(50));
    
    const snapshot = await getDocs(q);
    
    if (snapshot.empty) {
      listaEl.innerHTML = '<div class="ociosos-placeholder">Nenhuma movimenta√ß√£o encontrada.</div>';
      return;
    }

    listaEl.innerHTML = '';
    snapshot.forEach(doc => {
      const mov = doc.data();
      const itemEl = document.createElement('div');
      itemEl.className = 'extrato-item';

      const tipoClasse = (mov.tipo === 'deposito' || mov.tipo === 'juros' || mov.tipo === 'premio') ? 'entrada' : 'saida';
      const operador = (tipoClasse === 'entrada') ? '+' : '-';
      const data = mov.timestamp.toDate();
      const dataFormatada = `${data.toLocaleDateString('pt-BR')} ${data.toLocaleTimeString('pt-BR', {hour: '2-digit', minute: '2-digit'})}`;

      itemEl.innerHTML = `
        <div class="extrato-info">
          <div class="extrato-descricao">${mov.descricao}</div>
          <div class="extrato-data">${dataFormatada}</div>
        </div>
        <div class="extrato-valor ${tipoClasse}">
          ${operador} ${mov.valor.toLocaleString('pt-BR')} üí∞
        </div>
      `;
      listaEl.appendChild(itemEl);
    });

  } catch (error) {
    console.error("Erro ao carregar extrato do banco:", error);
    listaEl.innerHTML = '<div class="ociosos-placeholder">Falha ao carregar o extrato.</div>';
  }
}

/**
 * Abre o modal de estat√≠sticas do banco da equipe do usu√°rio.
 */
async function abrirModalEstatisticasBanco() {
  if (!currentUser || !userTeam) {
    mostrarPopup("üö´ Acesso Negado", "Voc√™ precisa estar em uma equipe para ver as estat√≠sticas.", 4000);
    return;
  }

  const nomeEquipeCapitalizado = userTeam.charAt(0).toUpperCase() + userTeam.slice(1);
  document.getElementById('estatisticas-banco-titulo').textContent = `üìä Estat√≠sticas (${nomeEquipeCapitalizado})`;
  
  // Reseta as abas para a primeira
  document.querySelector('.avatar-tab-btn[data-tab-stats="contribuidores"]').click();
  
  const jurosListaEl = document.getElementById('stats-juros-lista');
  const contListaEl = document.getElementById('stats-contribuidores-lista');
  jurosListaEl.innerHTML = '<div class="ociosos-placeholder">Calculando...</div>';
  contListaEl.innerHTML = '<div class="ociosos-placeholder">Calculando...</div>';
  
  openModal('estatisticas-banco-modal');

  try {
    const movRef = collection(db, "bancosEquipes", userTeam, "movimentacoes");
    const q = query(movRef, orderBy("timestamp", "desc"));
    
    const snapshot = await getDocs(q);

    if (snapshot.empty) {
      jurosListaEl.innerHTML = '<div class="ociosos-placeholder">Nenhum rendimento ainda.</div>';
      contListaEl.innerHTML = '<div class="ociosos-placeholder">Nenhum contribuidor ainda.</div>';
      return;
    }

    // Processamento dos dados
    const rendimentosJuros = [];
    const contribuicoes = {};

    snapshot.forEach(doc => {
      const mov = doc.data();
      
      if (mov.tipo === 'juros') {
        rendimentosJuros.push(mov);
      }
      
      if (mov.tipo === 'deposito' && mov.membroId) {
        if (!contribuicoes[mov.membroId]) {
          contribuicoes[mov.membroId] = 0;
        }
        contribuicoes[mov.membroId] += mov.valor;
      }
    });

    // Popular Aba de Juros
    if (rendimentosJuros.length === 0) {
      jurosListaEl.innerHTML = '<div class="ociosos-placeholder">Nenhum rendimento ainda.</div>';
    } else {
      jurosListaEl.innerHTML = '';
      rendimentosJuros.forEach(mov => {
        const itemEl = document.createElement('div');
        itemEl.className = 'stats-item';
        const data = mov.timestamp.toDate();
        const dataFormatada = `${data.toLocaleDateString('pt-BR')} ${data.toLocaleTimeString('pt-BR', {hour: '2-digit', minute: '2-digit'})}`;
        itemEl.innerHTML = `
          <div class="extrato-info">
            <div class="extrato-descricao">${mov.descricao}</div>
            <div class="stats-juros-data">${dataFormatada}</div>
          </div>
          <div class="stats-juros-valor">+ ${mov.valor.toLocaleString('pt-BR')} üí∞</div>
        `;
        jurosListaEl.appendChild(itemEl);
      });
    }

    // Popular Aba de Contribuidores
    if (Object.keys(contribuicoes).length === 0) {
      contListaEl.innerHTML = '<div class="ociosos-placeholder">Nenhum contribuidor ainda.</div>';
    } else {
      contListaEl.innerHTML = '';
      const ranking = Object.entries(contribuicoes)
        .sort(([, a], [, b]) => b - a) // Ordena do maior para o menor
        .slice(0, 10); // Pega o Top 10

      ranking.forEach(([nome, valor], index) => {
        const itemEl = document.createElement('div');
        itemEl.className = 'stats-item';
        let emojiPos = `${index + 1}¬∫`;
        if (index === 0) emojiPos = 'ü•á';
        if (index === 1) emojiPos = 'ü•à';
        if (index === 2) emojiPos = 'ü•â';

        itemEl.innerHTML = `
          <span class="stats-posicao">${emojiPos}</span>
          <span class="stats-nome">${nome}</span>
          <span class="stats-valor">${valor.toLocaleString('pt-BR')} üí∞</span>
        `;
        contListaEl.appendChild(itemEl);
      });
    }

  } catch (error) {
    console.error("Erro ao carregar estat√≠sticas do banco:", error);
    jurosListaEl.innerHTML = '<div class="ociosos-placeholder">Falha ao carregar dados.</div>';
    contListaEl.innerHTML = '<div class="ociosos-placeholder">Falha ao carregar dados.</div>';
  }
}

// =============================================
// ===== FIM: FUN√á√ïES DO BANCO DAS EQUIPES =====
// =============================================

// =============================================
// ===== IN√çCIO: FUN√á√ïES DA LOJINHA DE PODERES ===
// =============================================

/**
 * Define os dados est√°ticos de todos os poderes da loja.
 * √â chamado uma vez no login.
 */
function inicializarLojaPoderes() {
    todosPoderesInfo = [
        { 
            id: 'pocao_sextagem', 
            nome: 'Po√ß√£o da Sextagem', 
            emoji: 'üç∫',
            descricao: 'Concede folga imediata para todos os membros da sua equipe. As caixas de sele√ß√£o de todos os membros ativos da sua equipe ser√£o marcadas automaticamente no momento da compra.',
            preco: 50000,
            limiteTipo: 'semanal', // 'semanal', 'quinzenal'
            limiteQtd: 1,
            requerAlvo: false
        },
        { 
            id: 'praga_kriptonita', 
            nome: 'Praga de Kriptonita', 
            emoji: 'ü§¢',
            descricao: 'Impede uma equipe advers√°ria de comprar qualquer poder na Lojinha. O efeito dura 3 dias a partir do momento da compra.',
            preco: 20000,
            limiteTipo: 'semanal',
            limiteQtd: 1,
            requerAlvo: true
        },
        { 
            id: 'maldicao_pilantragem', 
            nome: 'Maldi√ß√£o da Pilantragem', 
            emoji: 'üíÄ',
            descricao: 'Retira 2 pontos da pontua√ß√£o m√©dia de uma equipe advers√°ria. A dedu√ß√£o ser√° aplicada em tempo real no placar da semana e no resultado detalhado de domingo.',
            preco: 100000,
            limiteTipo: 'quinzenal', // "semana sim, semana n√£o"
            limiteQtd: 1,
            requerAlvo: true
        },
        { 
            id: 'elixir_vida', 
            nome: 'Elixir de Vida', 
            emoji: 'üíñ',
            descricao: 'Adiciona 2 pontos √† pontua√ß√£o m√©dia da sua equipe. O b√¥nus ser√° aplicado em tempo real no placar da semana e no resultado detalhado de domingo.',
            preco: 30000,
            limiteTipo: 'semanal',
            limiteQtd: 1,
            requerAlvo: false
        },
        { 
            id: 'runa_soft_block', 
            nome: 'Runa do Soft Block', 
            emoji: 'üîí',
            descricao: 'Impede que todos os membros de uma equipe advers√°ria (exceto o l√≠der dela) fa√ßam login na p√°gina por 3 dias.',
            preco: 120000,
            limiteTipo: 'quinzenal',
            limiteQtd: 1,
            requerAlvo: true
        },
        { 
            id: 'amuleto_protecao', 
            nome: 'Amuleto de Prote√ß√£o', 
            emoji: 'üõ°Ô∏è',
            descricao: 'Torna sua equipe imune a todas as maldi√ß√µes de outras equipes (Kriptonita, Pilantragem e Soft Block) at√© o final da competi√ß√£o no s√°bado.',
            preco: 60000,
            limiteTipo: 'quinzenal',
            limiteQtd: 1,
            requerAlvo: false
        }
    ];
}

/**
 * Carrega o status atual dos poderes (ativos e hist√≥rico) do Firestore.
 * √â chamado no login e ap√≥s uma compra.
 */
async function carregarStatusPoderes() {
    console.log("[LOJA PODERES] Carregando status e hist√≥rico...");
    const semana = getSemanaAtual();
    const semanaId = `semana_${semana.numero}_${semana.inicio.getFullYear()}`;

    // Limpa os caches locais
    statusPoderesAtivos = [];
    historicoPoderesSemana = {};

    try {
        // 1. Busca todos os efeitos ativos (buffs e debuffs)
        const statusRef = collection(db, "statusPoderes");
        const qStatus = query(statusRef, where("expiraEm", ">", new Date())); // Pega s√≥ os que n√£o expiraram
        const statusSnap = await getDocs(qStatus);
        
        // CORRE√á√ÉO: Filtro de seguran√ßa adicional
        const dataCorteSeguranca = new Date(semana.inicio); 
        dataCorteSeguranca.setHours(0, 0, 0, 0); // Segunda-feira 00:00 da semana ATUAL

        statusSnap.forEach(doc => {
            const dados = doc.data();
            
            // L√ìGICA DE PROTE√á√ÉO DE SEMANA:
            // A maioria dos poderes dura 3 dias. Se 'expiraEm' √© hoje, ele foi criado h√° 3 dias.
            // Se (expiraEm - 3 dias) for MENOR que o in√≠cio desta semana, √© um poder velho.
            if (dados.expiraEm) {
                const dataExpiracao = dados.expiraEm.toDate();
                // Subtrai 3 dias (aproximado) para estimar a cria√ß√£o
                const dataCriacaoEstimada = new Date(dataExpiracao.getTime() - (3 * 24 * 60 * 60 * 1000));
                
                // Se foi criado antes do in√≠cio desta semana, ignoramos (mesmo que ainda n√£o tenha expirado)
                if (dataCriacaoEstimada < dataCorteSeguranca) {
                    return; // Pula este item
                }
            }

            statusPoderesAtivos.push({ id: doc.id, ...dados });
        });
        console.log(`[LOJA PODERES] ${statusPoderesAtivos.length} efeitos de poder ativos carregados.`);

        // 2. Busca o hist√≥rico de compras desta semana e da semana passada (para o limite quinzenal)
        const semanaPassadaNum = semana.numero === 1 ? 52 : semana.numero - 1; // Lida com a virada do ano
        const anoSemanaPassada = semana.numero === 1 ? semana.inicio.getFullYear() - 1 : semana.inicio.getFullYear();
        
        const historicoRef = collection(db, "historicoPoderes");
        const qHistorico = query(historicoRef, where("semana", "in", [semana.numero, semanaPassadaNum]));
        const historicoSnap = await getDocs(qHistorico);

        historicoSnap.forEach(doc => {
            const compra = doc.data();
            // Filtra o ano, caso a semana 52 seja do ano anterior
            if (compra.semana === semanaPassadaNum && compra.timestamp.toDate().getFullYear() !== anoSemanaPassada) {
                return; 
            }
            
            const equipe = compra.equipe;
            if (!historicoPoderesSemana[equipe]) {
                historicoPoderesSemana[equipe] = {};
            }
            if (!historicoPoderesSemana[equipe][compra.poderId]) {
                historicoPoderesSemana[equipe][compra.poderId] = [];
            }
            historicoPoderesSemana[equipe][compra.poderId].push(compra);
        });
        console.log("[LOJA PODERES] Hist√≥rico de compras da semana carregado.");

    } catch (error) {
        console.error("Erro ao carregar status dos poderes:", error);
    }

    // 3. Constr√≥i a interface da loja com os dados atualizados
    construirInterfaceLojaPoderes();
    
    // 4. (Vamos adicionar esta fun√ß√£o depois)
    // exibirPopupPoderesAtivos(); 
}

// COLE ESTA FUN√á√ÉO ATUALIZADA (v4 - Otimizada)
function construirInterfaceLojaPoderes() {
    const grid = document.getElementById('loja-poderes-grid');
    if (!grid) return;
    grid.innerHTML = '';

    // === IN√çCIO DA ALTERA√á√ÉO: VERIFICA√á√ÉO VISUAL DE KRIPTONITA ===
    // Verifica se a equipe do usu√°rio atual √© alvo de uma praga ativa
    const pragaAtiva = statusPoderesAtivos.find(p => 
        p.poderId === 'praga_kriptonita' && 
        p.equipeAlvo === userTeam
    );

    if (pragaAtiva) {
        const dataFim = pragaAtiva.expiraEm.toDate().toLocaleString('pt-BR');
        
        grid.innerHTML = `
            <div class="kriptonita-overlay">
                <div class="kriptonita-icon">ü§¢</div>
                <div class="kriptonita-titulo">Loja Bloqueada!</div>
                <p>Sua equipe est√° sob o efeito da <strong>Praga de Kriptonita</strong>.</p>
                <p>Nenhuma magia pode ser comprada enquanto o efeito durar.</p>
                <div class="kriptonita-timer">Libera em: ${dataFim}</div>
            </div>
        `;
        return;
    }
	
    // --- CORRE√á√ÉO: Definindo as vari√°veis necess√°rias ---
    const semana = getSemanaAtual();
    const semanaPassadaNum = semana.numero === 1 ? 52 : semana.numero - 1;
    const anoSemanaPassada = semana.numero === 1 ? semana.inicio.getFullYear() - 1 : semana.inicio.getFullYear();
    // ----------------------------------------------------

    let precisaIniciarTimer = false;

    todosPoderesInfo.forEach(poder => {
        const card = document.createElement('div');
        card.className = 'poder-card';
        card.onclick = () => abrirModalDetalhesPoder(poder.id);
        
        let podeComprar = true;
        let dataFimBloqueio = null;

        const historicoEquipe = historicoPoderesSemana[userTeam] || {};
        const comprasFeitas = historicoEquipe[poder.id] || [];

        // L√≥gica de Limite Semanal
        if (poder.limiteTipo === 'semanal') {
            const comprasEstaSemana = comprasFeitas.filter(c => c.semana === semana.numero);
            if (comprasEstaSemana.length >= poder.limiteQtd) {
                podeComprar = false;
                dataFimBloqueio = getFimDaSemanaAtual(); 
            }
        }
        // L√≥gica de Limite Quinzenal
        else if (poder.limiteTipo === 'quinzenal') {
            const comprasEstaSemana = comprasFeitas.filter(c => c.semana === semana.numero);
            if (comprasEstaSemana.length >= poder.limiteQtd) {
                podeComprar = false;
                dataFimBloqueio = getFimDaProximaSemana(); 
            } else {
                const comprasSemanaPassada = comprasFeitas.filter(c => 
                    c.semana === semanaPassadaNum &&
                    c.timestamp.toDate().getFullYear() === anoSemanaPassada
                );
                
                if (comprasSemanaPassada.length > 0) {
                    podeComprar = false;
                    dataFimBloqueio = getFimDaSemanaAtual(); 
                }
            }
        }
        
        let botaoHTML = '';
        if (userRole === 'membro') {
            botaoHTML = `<button class="poder-card-botao pedir">Ver Detalhes</button>`;
        } else {
            botaoHTML = `<button class="poder-card-botao comprar">Ver Detalhes</button>`;
        }
        
        card.innerHTML = `
            <div class="poder-emoji">${poder.emoji}</div>
            <div class="poder-nome">${poder.nome}</div>
            <div class="poder-preco">üí∞ ${poder.preco.toLocaleString('pt-BR')}</div>
            ${botaoHTML}
        `;

        if (!podeComprar && dataFimBloqueio) {
            card.classList.add('em-cooldown');
            card.onclick = null; 
            
            // ALTERA√á√ÉO AQUI: Usamos classes e data-attributes em vez de IDs √∫nicos complexos
            const deadlineMs = dataFimBloqueio.getTime();
            card.innerHTML += `<div class="poder-cooldown-overlay"><span class="timer-ativo" data-deadline="${deadlineMs}">Calculando...</span></div>`;
            precisaIniciarTimer = true;
        }

        grid.appendChild(card);
    });

    // Inicia o gerenciador global se houver pelo menos um timer
    if (precisaIniciarTimer) {
        iniciarGerenciadorDeTimers();
    }
}

// COLE ESTA FUN√á√ÉO ATUALIZADA (v2 - Texto de Limite)
function abrirModalDetalhesPoder(poderId) {
    const poder = todosPoderesInfo.find(p => p.id === poderId);
    if (!poder) return;

    poderParaComprar = poder; // Armazena o poder que est√° sendo visto

    document.getElementById('detalhes-poder-titulo').textContent = poder.nome;
    document.getElementById('detalhes-poder-emoji').textContent = poder.emoji;
    document.getElementById('detalhes-poder-preco').textContent = `üí∞ ${poder.preco.toLocaleString('pt-BR')}`;
    document.getElementById('detalhes-poder-descricao').textContent = poder.descricao;
    
    // --- IN√çCIO DA ALTERA√á√ÉO ---
    const limiteEl = document.getElementById('detalhes-poder-limite');
    if (poder.limiteTipo === 'semanal') {
        limiteEl.textContent = `Limite: 1 por semana.`;
    } else if (poder.limiteTipo === 'quinzenal') {
        limiteEl.textContent = `Limite: 1 a cada 2 semanas.`;
    } else {
        // Fallback
        limiteEl.textContent = `Limite: ${poder.limiteQtd} por ${poder.limiteTipo}.`;
    }
    // --- FIM DA ALTERA√á√ÉO ---

    const btnComprar = document.getElementById('detalhes-poder-btn-comprar');
    const btnPedir = document.getElementById('detalhes-poder-btn-pedir');

    if (userRole === 'membro') {
        btnComprar.classList.add('hidden');
        btnPedir.classList.remove('hidden');
    } else {
        btnComprar.classList.remove('hidden');
        btnPedir.classList.add('hidden');
    }
    
    openModal('modal-poder-detalhes');
}

/**
 * (Membro) Envia uma notifica√ß√£o ao l√≠der da equipe.
 */
async function pedirPoderAoLider() {
    if (!userTeam || !poderParaComprar) return;

    const liderDaEquipe = equipes[userTeam]?.lider;
    if (!liderDaEquipe) {
        mostrarPopup("‚ùå Sem L√≠der", "Sua equipe n√£o tem um l√≠der de equipe para notificar.", 4000);
        return;
    }

    try {
        const notificacaoRef = doc(collection(db, "notificacoes"));
        await setDoc(notificacaoRef, {
            destinatarioId: liderDaEquipe.nome,
            remetenteNome: currentUser,
            tipo: 'poder',
            conteudo: 'üí°',
            acao: `sugeriu a compra do poder: **${poderParaComprar.nome}** para a equipe!`,
            lida: false,
            timestamp: new Date()
        });

        mostrarPopup("‚úÖ Pedido Enviado!", `Sua sugest√£o foi enviada para ${liderDaEquipe.nome}.`, 4000);
        closeModal('modal-poder-detalhes');
        poderParaComprar = null; // Limpa a vari√°vel

    } catch (error) {
        console.error("Erro ao pedir poder ao l√≠der:", error);
        mostrarPopup("‚ùå Erro", "N√£o foi poss√≠vel enviar sua sugest√£o.", 4000);
    }
}
window.pedirPoderAoLider = pedirPoderAoLider;

/**
 * (L√≠der) Inicia o fluxo de compra de um poder.
 */
async function iniciarCompraPoder() {
    if (!userTeam || !poderParaComprar) return;

    const poder = poderParaComprar;
    const equipeCompradora = userTeam;
    const preco = poder.preco;

    // 1. Verificar se a equipe est√° sob efeito da "Kriptonita"
    const estaBloqueado = statusPoderesAtivos.find(p => p.poderId === 'praga_kriptonita' && p.equipeAlvo === equipeCompradora);
    if (estaBloqueado) {
        const dataExpiracao = estaBloqueado.expiraEm.toDate().toLocaleString('pt-BR');
        mostrarPopup("üö´ Compra Bloqueada", `Sua equipe est√° sob o efeito da Praga de Kriptonita e n√£o pode comprar poderes at√© ${dataExpiracao}.`, 7000);
        return;
    }

    // 2. Verificar saldo do banco
    const saldoBanco = saldosBancosEquipes[equipeCompradora] || 0;
    if (saldoBanco < preco) {
        mostrarPopup("üí∞ Saldo Insuficiente", `O banco da sua equipe tem ${saldoBanco.toLocaleString('pt-BR')} moedas. Voc√™ precisa de ${preco.toLocaleString('pt-BR')}.`, 5000);
        return;
    }
    
    // 3. Verificar se o poder requer um alvo
    if (poder.requerAlvo) {
        abrirModalSelecionarAlvo();
    } else {
        // Se n√£o requer alvo, vai direto para a confirma√ß√£o
        abrirModalConfirmarCompra(null); // null = sem alvo
    }
}
window.iniciarCompraPoder = iniciarCompraPoder;

/**
 * (L√≠der) Abre o modal para selecionar uma equipe advers√°ria.
 */
function abrirModalSelecionarAlvo() {
    const listaContainer = document.getElementById('lista-equipes-alvo');
    listaContainer.innerHTML = '';
    
    const equipesAdversarias = Object.keys(equipes).filter(id => id !== userTeam);
    
    equipesAdversarias.forEach(equipeId => {
        // A VERIFICA√á√ÉO DE IMUNIDADE FOI REMOVIDA DAQUI
        
        const radioEl = document.createElement('div');
        radioEl.className = 'equipe-alvo-opcao';
        radioEl.innerHTML = `
            <input type="radio" id="alvo-${equipeId}" name="equipe_alvo" value="${equipeId}">
            <label for="alvo-${equipeId}">
                Equipe ${equipeId.charAt(0).toUpperCase() + equipeId.slice(1)}
            </label>
        `;
        listaContainer.appendChild(radioEl);
    });

    document.getElementById('confirmar-alvo-btn').onclick = () => {
        const selecionado = document.querySelector('input[name="equipe_alvo"]:checked');
        if (!selecionado) {
            mostrarPopup("‚ö†Ô∏è Aten√ß√£o", "Voc√™ precisa selecionar uma equipe alvo.", 3000);
            return;
        }
        equipeAlvoParaPoder = selecionado.value;
        closeModal('modal-selecionar-equipe-alvo');
        abrirModalConfirmarCompra(equipeAlvoParaPoder);
    };
    
    closeModal('modal-poder-detalhes');
    openModal('modal-selecionar-equipe-alvo');
}

/**
 * (Helper) Registra uma falha de poder, reembolsa o custo e registra o status.
 */
async function registrarFalhaDePoder(poder, equipeCompradora, equipeAlvo, preco, timestamp) {
    const batch = writeBatch(db);
    const bancoRef = doc(db, "bancosEquipes", equipeCompradora);
    
    // 1. Debita do banco (a compra √© efetuada)
    batch.update(bancoRef, { saldo: increment(-preco) });
    
    // 2. Reembolsa as moedas imediatamente
    batch.update(bancoRef, { saldo: increment(preco) });

    // 3. Registra a compra falha no extrato
    const movRefCompra = doc(collection(bancoRef, "movimentacoes"));
    batch.set(movRefCompra, {
        tipo: 'compra_poder_falha',
        membroId: currentUser,
        valor: preco,
        descricao: `Tentativa de usar ${poder.nome} em ${equipeAlvo} (falhou)`,
        timestamp: timestamp
    });

    // 4. Registra o reembolso no extrato
    const movRefReembolso = doc(collection(bancoRef, "movimentacoes"));
    batch.set(movRefReembolso, {
        tipo: 'reembolso_amuleto',
        membroId: 'Sistema', // O reembolso √© autom√°tico
        valor: preco,
        descricao: `Reembolso: ${poder.nome} falhou (alvo protegido)`,
        timestamp: new Date(timestamp.getTime() + 1000) // 1 segundo depois
    });

    // 5. Salva no hist√≥rico de limites (a compra foi "usada")
    const historicoRef = doc(collection(db, "historicoPoderes"));
    batch.set(historicoRef, {
        equipe: equipeCompradora,
        poderId: poder.id,
        alvo: equipeAlvo,
        semana: getSemanaAtual().numero,
        timestamp: timestamp
    });
    
    // 6. Registra o "status de falha" para o popup do atacante
    const statusRef = doc(collection(db, "statusPoderes"));
    batch.set(statusRef, {
        poderId: 'amuleto_falha', // Novo tipo de status
        nomePoder: poder.nome,
        usadoPor: equipeCompradora, // A equipe que falhou
        equipeAlvo: equipeAlvo, // A equipe que foi alvo
        valorReembolsado: preco,
        expiraEm: new Date(timestamp.getTime() + 3 * 24 * 60 * 60 * 1000) // Mant√©m o registro por 3 dias
    });

    await batch.commit();
}

/**
 * (L√≠der) Abre o modal final de confirma√ß√£o antes de gastar.
 */
function abrirModalConfirmarCompra(equipeAlvo) {
    const resumoContainer = document.getElementById('resumo-compra-poder');
    const saldoBanco = saldosBancosEquipes[userTeam] || 0;
    const novoSaldo = saldoBanco - poderParaComprar.preco;

    let resumoHTML = `
        <p><strong>Poder:</strong> ${poderParaComprar.nome}</p>
        <p><strong>Custo:</strong> üí∞ ${poderParaComprar.preco.toLocaleString('pt-BR')}</p>
        ${equipeAlvo ? `<p><strong>Alvo:</strong> Equipe ${equipeAlvo}</p>` : ''}
        <hr style="margin: 10px 0;">
        <p><strong>Saldo do Banco:</strong> ${saldoBanco.toLocaleString('pt-BR')}</p>
        <p><strong>Novo Saldo:</strong> ${novoSaldo.toLocaleString('pt-BR')}</p>
    `;
    resumoContainer.innerHTML = resumoHTML;
    
    document.getElementById('confirmar-compra-poder-btn').onclick = executarCompraPoder;

    closeModal('modal-poder-detalhes'); // Garante que o de detalhes feche
    openModal('modal-confirmar-compra-poder');
}

/**
 * (L√≠der) Fun√ß√£o final que executa a compra e aplica os efeitos.
 * (VERS√ÉO ATUALIZADA COM TRAVA DE SEGURAN√áA)
 */
async function executarCompraPoder() {
    if (comprandoPoder) {
        mostrarPopup("‚è≥ Aguarde", "Uma compra j√° est√° em processamento...", 3000);
        return;
    }
    comprandoPoder = true; 

    const poder = poderParaComprar;
    const equipeCompradora = userTeam;
    const equipeAlvo = equipeAlvoParaPoder; // Pode ser null
    const preco = poder.preco;
    const semana = getSemanaAtual();
    const semanaId = `semana_${semana.numero}_${semana.inicio.getFullYear()}`;
    const timestamp = new Date();

    const btn = document.getElementById('confirmar-compra-poder-btn');
    btn.disabled = true;
    btn.textContent = "Processando...";

    try {
        // --- IN√çCIO DA NOVA L√ìGICA DE VERIFICA√á√ÉO ---
        let alvoEstaImune = false;
        if (equipeAlvo && poder.id !== 'amuleto_protecao') { // S√≥ verifica se h√° um alvo e se n√£o √© o pr√≥prio amuleto
            const statusRef = collection(db, "statusPoderes");
            const qStatus = query(statusRef, 
                where("expiraEm", ">", new Date()),
                where("poderId", "==", "amuleto_protecao"),
                where("equipeAlvo", "==", equipeAlvo) // Verifica se o ALVO est√° protegido
            );
            const statusSnap = await getDocs(qStatus);
            alvoEstaImune = !statusSnap.empty;
        }
        
        let feedTexto = ''; // Vari√°vel para o texto do feed

        // --- CORRE√á√ÉO: Formata√ß√£o dos nomes das equipes ---
        const fmtNome = (n) => n ? (n === 'vagalume' ? 'Vaga-lume' : n.charAt(0).toUpperCase() + n.slice(1)) : '';
        const nomeEqComp = fmtNome(equipeCompradora); // Ex: Abelha, Vaga-lume
        const nomeEqAlvo = fmtNome(equipeAlvo);       // Ex: Joaninha
        // --------------------------------------------------

        if (alvoEstaImune) {
            // --- CASO 1: O ALVO EST√Å PROTEGIDO ---
            console.log(`[LOJA PODERES] Ataque falhou! Equipe ${equipeAlvo} est√° imune.`);
            await registrarFalhaDePoder(poder, equipeCompradora, equipeAlvo, preco, timestamp);
            
            // Use as vari√°veis formatadas aqui:
            feedTexto = `<strong>${currentUser}</strong> (Equipe ${nomeEqComp}) usou o poder <strong>${poder.emoji} ${poder.nome}</strong> contra a <strong>Equipe ${nomeEqAlvo}</strong>... Mas o alvo estava protegido por um Amuleto de Prote√ß√£o! Ou seja, a magia falhou.`;
            await adicionarEventoAoFeed('geral', 'üõ°Ô∏è Magia Bloqueada!', feedTexto, { nomeMembro: currentUser, equipe: equipeCompradora });

        } else if (poder.id === 'pocao_sextagem') {
            // --- CASO 2: PO√á√ÉO DA SEXTAGEM (l√≥gica especial mantida) ---
            await aplicarPocaoSextagem(equipeCompradora, preco, poder, timestamp);
            
            // Use a vari√°vel formatada aqui:
            feedTexto = `<strong>${currentUser}</strong> (Equipe ${nomeEqComp}) usou o poder <strong>${poder.emoji} ${poder.nome}</strong> e concedeu folga para toda a sua equipe!`;
            await adicionarEventoAoFeed('geral', 'üî• Poder Ativado!', feedTexto, { nomeMembro: currentUser, equipe: equipeCompradora });

        } else {
            // --- CASO 3: COMPRA NORMAL (sem imunidade) ---
            const batch = writeBatch(db);
            const bancoRef = doc(db, "bancosEquipes", equipeCompradora);
            
            // 1. Debita do banco
            batch.update(bancoRef, { saldo: increment(-preco) });

            // 2. Registra no extrato do banco
            const movRef = doc(collection(db, "bancosEquipes", equipeCompradora, "movimentacoes"));
            let descMov = `Compra do poder: ${poder.nome}`;
            if (equipeAlvo) descMov += ` (Alvo: ${equipeAlvo})`;
            batch.set(movRef, {
                tipo: 'compra_poder',
                membroId: currentUser,
                valor: preco,
                descricao: descMov,
                timestamp: timestamp
            });

            // 3. Salva no hist√≥rico de limites
            const historicoRef = doc(collection(db, "historicoPoderes"));
            batch.set(historicoRef, {
                equipe: equipeCompradora,
                poderId: poder.id,
                alvo: equipeAlvo || null,
                semana: semana.numero,
                timestamp: timestamp
            });
            
            // 4. Aplica o efeito do poder
            aplicarEfeitoPoderBatch(batch, poder, equipeCompradora, equipeAlvo, timestamp);

            // 5. Executa o batch
            await batch.commit();
            
            // 6. Adiciona ao Feed (SE N√ÉO FOR O AMULETO)
            if (poder.id !== 'amuleto_protecao') {
                // Use as vari√°veis formatadas aqui:
                feedTexto = `<strong>${currentUser}</strong> (Equipe ${nomeEqComp}) usou o poder <strong>${poder.emoji} ${poder.nome}</strong>`;
                if (equipeAlvo) {
                    feedTexto += ` contra a <strong>Equipe ${nomeEqAlvo}</strong>!`;
                } else if (poder.id === 'elixir_vida') {
                    feedTexto += ` para acrescentar +2 pontos √† m√©dia da sua equipe!`;
                } else {
                    feedTexto += `!`;
                }
                await adicionarEventoAoFeed('geral', 'üî• Poder Ativado!', feedTexto, { nomeMembro: currentUser, equipe: equipeCompradora });
            }
            // Se for o amuleto, NENHUM evento de feed √© postado.
        }
        
        mostrarPopup("‚úÖ Poder Ativado!", `${poder.nome} foi usado com sucesso!`, 5000);

    } catch (error) {
        console.error("Erro ao executar a compra do poder:", error);
        mostrarPopup("‚ùå Erro Cr√≠tico", `A compra falhou: ${error.message}`, 6000);
    } finally {
        comprandoPoder = false; // Libera a trava
        
        btn.disabled = false;
        btn.textContent = "Confirmar e Usar";
        closeModal('modal-confirmar-compra-poder');
        poderParaComprar = null;
        equipeAlvoParaPoder = null;
        await carregarStatusPoderes(); // Atualiza a loja
		await atualizarMediaEquipes();
    }
}

/**
 * (Helper) Aplica os efeitos dos poderes que usam BATCH.
 */
function aplicarEfeitoPoderBatch(batch, poder, equipeCompradora, equipeAlvo, timestamp) {
    const semana = getSemanaAtual();
    const semanaId = `semana_${semana.numero}_${semana.inicio.getFullYear()}`;
    const vantageRef = doc(db, "vantagemSemanal", semanaId);

    let dataExpiracao;
    
    switch (poder.id) {
        case 'praga_kriptonita':
            dataExpiracao = new Date(timestamp.getTime() + 3 * 24 * 60 * 60 * 1000); // +3 dias
            batch.set(doc(collection(db, "statusPoderes")), {
                equipeAlvo: equipeAlvo,
                poderId: poder.id,
                nomePoder: poder.nome,
                usadoPor: equipeCompradora,
                expiraEm: dataExpiracao
            });
            break;
            
        case 'maldicao_pilantragem':
            // 1. Deduz 2 pontos dos pontos semanais IMEDIATAMENTE
            // 2. Salva o registro da dedu√ß√£o para o resultado final
            batch.set(vantageRef, { 
                deducoesPoderes: { 
                    [equipeAlvo]: arrayUnion({
                        por: equipeCompradora,
                        nomePoder: poder.nome,
                        valor: -2,
                        timestamp: timestamp
                    })
                }
            }, { merge: true });
            break;
            
        case 'elixir_vida':
            // 1. Adiciona 2 pontos aos pontos semanais IMEDIATAMENTE
            // 2. Salva o registro da adi√ß√£o para o resultado final
            batch.set(vantageRef, { 
                adicoesPoderes: { 
                    [equipeCompradora]: arrayUnion({
                        por: equipeCompradora,
                        nomePoder: poder.nome,
                        valor: 2,
                        timestamp: timestamp
                    })
                }
            }, { merge: true });
            break;
            
        case 'runa_soft_block':
            dataExpiracao = new Date(timestamp.getTime() + 3 * 24 * 60 * 60 * 1000); // +3 dias
            batch.set(doc(collection(db, "statusPoderes")), {
                equipeAlvo: equipeAlvo,
                poderId: poder.id,
                nomePoder: poder.nome,
                usadoPor: equipeCompradora,
                expiraEm: dataExpiracao
            });
            break;
            
        case 'amuleto_protecao':
            const fimDaSemana = new Date(semana.fim);
            fimDaSemana.setHours(23, 59, 59); // S√°bado √†s 23:59:59
            batch.set(doc(collection(db, "statusPoderes")), {
                equipeAlvo: equipeCompradora, // Protege a pr√≥pria equipe
                poderId: poder.id,
                nomePoder: poder.nome,
                usadoPor: equipeCompradora,
                expiraEm: fimDaSemana
            });
            break;
    }
}

/**
 * (Helper) Fun√ß√£o especial para a Po√ß√£o da Sextagem (n√£o usa batch).
 */
async function aplicarPocaoSextagem(equipeCompradora, preco, poder, timestamp) {
    const semana = getSemanaAtual();
    const hojeISO = getHojeISO();
    
    // 1. Debita do banco
    await updateDoc(doc(db, "bancosEquipes", equipeCompradora), { saldo: increment(-preco) });
    
    // 2. Registra no extrato
    const movRef = doc(collection(db, "bancosEquipes", equipeCompradora, "movimentacoes"));
    await setDoc(movRef, {
        tipo: 'compra_poder',
        membroId: currentUser,
        valor: preco,
        descricao: `Compra do poder: ${poder.nome}`,
        timestamp: timestamp
    });

    // 3. Salva no hist√≥rico de limites
    const historicoRef = doc(collection(db, "historicoPoderes"));
    await setDoc(historicoRef, {
        equipe: equipeCompradora,
        poderId: poder.id,
        alvo: null,
        semana: semana.numero,
        timestamp: timestamp
    });
    
    // 4. Marca a presen√ßa de todos
    const membrosDaEquipe = equipes[equipeCompradora].membros.filter(m => !m.deFerias);
    let membrosMarcados = 0;
    
    for (const membro of membrosDaEquipe) {
        // Verifica se o membro j√° marcou hoje
        const presencaDoc = await getDoc(doc(db, "presencas", hojeISO));
        const jaMarcado = presencaDoc.exists() && presencaDoc.data()[membro.nome];
        
        if (!jaMarcado) {
            // Usa a fun√ß√£o de marcar folga, que √© segura e faz tudo (streak, moedas, pontos)
            // A fun√ß√£o `marcarFolgaAutomatica` j√° n√£o incrementa moedas, o que √© perfeito.
            // Precisamos de uma vers√£o que N√ÉO poste no feed.
            await marcarPresencaPoder(membro);
            membrosMarcados++;
        }
    }
    console.log(`[LOJA PODERES] Po√ß√£o da Sextagem marcou ${membrosMarcados} membros.`);
}

/**
 * (Helper) Vers√£o silenciosa de 'marcarFolgaAutomatica' para uso por poderes.
 * Marca presen√ßa, streak e ponto de equipe, mas N√ÉO d√° moedas e N√ÉO posta no feed.
 */
async function marcarPresencaPoder(membro) {
  if (!membro || !membro.nome) return;

  const nome = membro.nome;
  const hojeISO = getHojeISO();
  const membroRef = doc(db, "membros", nome);
  const presencaRef = doc(db, "presencas", hojeISO);
  const pontosSemanaisRef = doc(db, "semanas", "pontosSemanais");

  try {
    // --- TRANSA√á√ÉO BLINDADA ---
    const { novoStreak } = await runTransaction(db, async (transaction) => {
      // 1. LEITURAS
      const membroSnap = await transaction.get(membroRef);
      const presencaSnap = await transaction.get(presencaRef); // Leitura essencial
      
      if (!membroSnap.exists()) throw "Membro n√£o encontrado.";
      
      const equipeDoMembro = membroSnap.data().equipe;
      const streakAtual = (membroSnap.data().streak || 0) + 1;
      
      // 2. ESCRITAS BLINDADAS
      if (presencaSnap.exists()) {
         transaction.update(presencaRef, { [nome]: new Date() });
      } else {
         transaction.set(presencaRef, { [nome]: new Date() }, { merge: true });
      }
      
      // Atualiza streak (mas N√ÉO d√° moedas, conforme sua regra original para po√ß√£o)
      transaction.update(membroRef, { streak: streakAtual }); 

      // Atualiza pontos da equipe
      let novosPontos = 0; // Apenas controle interno da transa√ß√£o
      if (equipeDoMembro && getHoje().getDay() !== 0) {
        transaction.update(pontosSemanaisRef, { [equipeDoMembro]: increment(1) });
        novosPontos = 1;
      }
      
      return { novoStreak: streakAtual, novosPontosEquipe: novosPontos };
    });

    // --- L√ìGICA VISUAL ORIGINAL ---
    streaksCache[nome] = novoStreak;
    atualizarStreakVisualMembro(nome, novoStreak);
    if (membro.equipe && getHoje().getDay() !== 0) {
      pontosSemanais[membro.equipe]++;
    }
    
    const checkbox = document.getElementById(nome);
    if(checkbox) checkbox.checked = true;
    await atualizarResumo();

  } catch (error) {
    console.error(`Erro ao marcar presen√ßa (poder) para ${nome}:`, error);
  }
}

async function regerarAnaliseOraculoSemanaPassada() {
  if (!confirm("Isso ir√° recalcular os dados, INCLUINDO O HIST√ìRICO DE PODERES, e regerar a an√°lise. Deseja continuar?")) {
    return;
  }

  showLoadingOverlay("O Or√°culo est√° re-examinando os fatos...");

  try {
    const hoje = getHoje();
    const semanaPassada = getSemanaAtual(new Date(hoje.getTime() - (24 * 60 * 60 * 1000)));
    const semanaId = `semana_${semanaPassada.numero}_${semanaPassada.inicio.getFullYear()}`;
    
    const resultadoRef = doc(db, "resultadosCompeticao", semanaId);
    const docSnap = await getDoc(resultadoRef);

    if (!docSnap.exists()) {
      throw new Error("O documento de resultados da semana passada n√£o existe.");
    }

    const dadosSalvos = docSnap.data();
    
    updateLoadingOverlayText("Recalculando tempos e status de sa√∫de...");

    const detalhesMembrosRecalculados = {};
    todosMembros.forEach(m => {
        detalhesMembrosRecalculados[m.nome] = { 
            nome: m.nome, 
            equipe: m.equipe, 
            pontuacao: { foco: 0, vantagem: 0, total: 0 }, 
            meChamo: m['me chamo'] || m.nome, 
            deFerias: m.deFerias || false,
            motivoAusencia: m.motivoAusencia || null,
            tempoTotal: 0
        };
    });

    const inicioSemanaISO = formatarDataISO(semanaPassada.inicio);
    const fimSemanaISO = formatarDataISO(semanaPassada.fim);
    const qPresencas = query(collection(db, "presencas"), where('__name__', '>=', inicioSemanaISO), where('__name__', '<=', fimSemanaISO));
    const presencasSnap = await getDocs(qPresencas);
    
    presencasSnap.forEach(doc => {
        const presencasDoDia = doc.data();
        for (const nome in presencasDoDia) {
            if (presencasDoDia[nome] && detalhesMembrosRecalculados[nome]) {
                detalhesMembrosRecalculados[nome].pontuacao.foco++;
                detalhesMembrosRecalculados[nome].pontuacao.total = detalhesMembrosRecalculados[nome].pontuacao.foco;
                let timestamp = 0;
                if (presencasDoDia[nome].toDate) {
                    timestamp = presencasDoDia[nome].toDate().getTime();
                } else if (presencasDoDia[nome] instanceof Date) {
                    timestamp = presencasDoDia[nome].getTime();
                } else {
                    timestamp = new Date(presencasDoDia[nome]).getTime();
                }
                detalhesMembrosRecalculados[nome].tempoTotal += timestamp;
            }
        }
    });

    const advantageRef = doc(db, "vantagemSemanal", semanaId);
    const advantageDoc = await getDoc(advantageRef);
    if (advantageDoc.exists()) {
        const completadoPor = advantageDoc.data().completadoPor || {};
        const PONTOS_FIXOS = 3;
        for (const nome in completadoPor) {
            if (detalhesMembrosRecalculados[nome]) {
                detalhesMembrosRecalculados[nome].pontuacao.vantagem += PONTOS_FIXOS;
                detalhesMembrosRecalculados[nome].pontuacao.total += PONTOS_FIXOS;
            }
        }
    }

    // --- IN√çCIO DA ADI√á√ÉO: Recalcular Hist√≥rico de Poderes ---
    updateLoadingOverlayText("Buscando hist√≥rico de poderes da semana...");
    const historicoPoderesRef = collection(db, "historicoPoderes");
    const qHistorico = query(historicoPoderesRef, where("semana", "==", semanaPassada.numero));
    const historicoSnap = await getDocs(qHistorico);

    const historicoCompletoSemana = { abelha: [], joaninha: [], vagalume: [] };
    const mapaNomesPoderes = {
        'pocao_sextagem': 'üç∫ Po√ß√£o da Sextagem',
        'praga_kriptonita': 'ü§¢ Praga de Kriptonita',
        'maldicao_pilantragem': 'üíÄ Maldi√ß√£o da Pilantragem',
        'elixir_vida': 'üíñ Elixir de Vida',
        'runa_soft_block': 'üîí Runa do Soft Block',
        'amuleto_protecao': 'üõ°Ô∏è Amuleto de Prote√ß√£o',
        'amuleto_falha': '‚ùå Falha de Magia'
    };

    historicoSnap.forEach(doc => {
        const data = doc.data();
        const anoData = data.timestamp.toDate().getFullYear();
        if (anoData === semanaPassada.inicio.getFullYear()) {
            if (historicoCompletoSemana[data.equipe]) {
                const nomePoder = mapaNomesPoderes[data.poderId] || data.poderId;
                historicoCompletoSemana[data.equipe].push({
                    nomePoder: nomePoder,
                    poderId: data.poderId,
                    alvo: data.alvo,
                    timestamp: data.timestamp
                });
            }
        }
    });
    // --- FIM DA ADI√á√ÉO ---

    const dadosParaIA = {
        ...dadosSalvos,
        detalhesMembros: detalhesMembrosRecalculados,
        historicoCompletoPoderes: historicoCompletoSemana // Adiciona para a IA saber tamb√©m
    };

    updateLoadingOverlayText("O Or√°culo est√° reescrevendo a an√°lise...");
    const analiseHtml = await gerarResumoSemanalComIA(dadosParaIA, semanaPassada);

    updateLoadingOverlayText("Salvando nova an√°lise e hist√≥rico...");
    await updateDoc(resultadoRef, {
      analiseOraculo: analiseHtml,
      detalhesMembros: detalhesMembrosRecalculados,
      historicoCompletoPoderes: historicoCompletoSemana // <<< Salva o hist√≥rico no documento!
    });

    sessionStorage.removeItem('popupAnaliseOraculoVisto');
    sessionStorage.removeItem(`resultadoVisto_${semanaId}`); // Reseta o visto do resultado tamb√©m

    hideLoadingOverlay();
    mostrarPopup("‚úÖ Sucesso!", "An√°lise corrigida e hist√≥rico de poderes atualizado!", 4000);

    setTimeout(() => {
        exibirPopupResultadoCompeticao(); // Reabre o popup para testar
    }, 1000);

  } catch (error) {
    hideLoadingOverlay();
    console.error("Erro ao regerar an√°lise do Or√°culo:", error);
    mostrarPopup("‚ùå Erro", `Falha ao regerar: ${error.message}`, 5000);
  }
}
window.regerarAnaliseOraculoSemanaPassada = regerarAnaliseOraculoSemanaPassada; // Expor para o onclick


/**
 * (TESTE) Simula o recebimento da recompensa de 5.000 moedas (Membro Comum).
 * Para usar: Abra o console (F12) e digite: testarPopupRecompensa5k()
 */
window.testarPopupRecompensa5k = function() {
  if (!currentUser) {
    console.log("Voc√™ precisa estar logado para testar.");
    return;
  }
  const liderDaEquipe = equipes[userTeam]?.lider?.nome || "Seu L√≠der";
  const valor = 5000;
  const notificacaoIdFalsa = "teste_notificacao_id_5k";
  
  // Chama a fun√ß√£o que voc√™ criou, simulando os dados de uma notifica√ß√£o
  mostrarPopupRecompensaRecebida(
    liderDaEquipe,
    valor,
    notificacaoIdFalsa,
    false // false = o agradecimento ainda n√£o foi enviado
  );
}

/**
 * (TESTE) Simula o recebimento da recompensa de 100.000 moedas (L√≠der de Equipe).
 * Para usar: Abra o console (F12) e digite: testarPopupRecompensa100k()
 */
window.testarPopupRecompensa100k = function() {
  if (!currentUser) {
    console.log("Voc√™ precisa estar logado para testar.");
    return;
  }
  const valor = 100000;
  const notificacaoIdFalsa = "teste_notificacao_id_100k";

  // Chama a fun√ß√£o que voc√™ criou, simulando os dados de uma notifica√ß√£o
  mostrarPopupRecompensaRecebida(
    "Sistema", // O L√≠der Geral envia como "Sistema"
    valor,
    notificacaoIdFalsa,
    false // false = o agradecimento ainda n√£o foi enviado
  );
}

// =============================================
// ===== IN√çCIO: FUN√á√ïES DE TEMPORADA ANUAL =====
// =============================================

// ATUALIZADA: Dispara confete com as cores das equipes vencedoras
function dispararConfeteFimTemporada(equipesVencedoras = []) {
    const canvas = document.getElementById('fim-temporada-confetti');
    if (!canvas) return;

    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    const particles = [];
    const particleCount = 300; 

    // Defini√ß√£o das cores baseada nas equipes
    let colors = [];
    
    // Se n√£o houver vencedores definidos ou array vazio, usa colorido padr√£o
    if (!equipesVencedoras || equipesVencedoras.length === 0) {
        colors = ["#FFD700", "#FF6B6B", "#2ECC71", "#3498DB", "#9B59B6"];
    } else {
        // Adiciona as cores espec√≠ficas das equipes vencedoras
        equipesVencedoras.forEach(eq => {
            const nome = eq.toLowerCase();
            if (nome === 'abelha') colors.push("#FFD700", "#F1C40F"); // Amarelo
            if (nome === 'joaninha') colors.push("#FF6B6B", "#E74C3C"); // Vermelho
            if (nome === 'vagalume') colors.push("#2ECC71", "#27AE60"); // Verde
        });
        // Adiciona branco/prata para brilho
        colors.push("#FFFFFF", "#BDC3C7");
    }

    // Se por algum motivo as cores ficarem vazias (ex: nome de equipe errado), volta ao padr√£o
    if (colors.length === 0) colors = ["#FFD700", "#FF6B6B", "#2ECC71"];

    for (let i = 0; i < particleCount; i++) {
        particles.push({
            x: Math.random() * canvas.width,
            y: -Math.random() * canvas.height,
            speed: Math.random() * 5 + 3,
            rotation: Math.random() * 360,
            size: Math.random() * 10 + 10,
            color: colors[Math.floor(Math.random() * colors.length)],
        });
    }

    let animationFrameId;

    function animateConfetti() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        let particlesAlive = 0;

        for (let i = 0; i < particles.length; i++) {
            const p = particles[i];
            p.y += p.speed;
            p.rotation += p.speed / 5;

            ctx.font = `${p.size}px Arial`;
            ctx.fillStyle = p.color;
            ctx.save();
            ctx.translate(p.x, p.y);
            ctx.rotate(p.rotation * Math.PI / 180);
            
            // Alterna entre confete quadrado e emoji de festa
            if (i % 2 === 0) {
                ctx.fillRect(-p.size / 2, -p.size / 2, p.size, p.size);
            } else {
                ctx.fillText('üéâ', -p.size / 2, p.size / 2);
            }
            
            ctx.restore();

            if (p.y < canvas.height) {
                particlesAlive++;
            }
        }

        if (particlesAlive > 0) {
            animationFrameId = requestAnimationFrame(animateConfetti);
        } else {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (window.fimTemporadaConfettiAnimation) {
                 cancelAnimationFrame(window.fimTemporadaConfettiAnimation);
                 window.fimTemporadaConfettiAnimation = null;
            }
        }
    }

    if (window.fimTemporadaConfettiAnimation) cancelAnimationFrame(window.fimTemporadaConfettiAnimation);
    window.fimTemporadaConfettiAnimation = requestAnimationFrame(animateConfetti);
}

/**
 * (ATUALIZADA) Verifica se o popup de fim de temporada deve ser exibido.
 * Busca o vencedor no Hall da Fama e personaliza a mensagem e as cores.
 * N√£o bloqueia mais o m√™s de Dezembro.
 */
async function verificarPopupFimDeTemporada() {
  if (!currentUser) return;

  try {
    // 1. Pega o status global para ver se h√° uma temporada encerrada
    const statusSnap = await getDoc(doc(db, "appState", "status"));
    if (!statusSnap.exists() || !statusSnap.data().popupAnoNovo) {
      return; // Nenhuma temporada marcada como encerrada
    }
    const anoPopup = statusSnap.data().popupAnoNovo; // Ex: 2025

    // 2. Pega os dados do membro para saber se ele j√° viu
    const membroSnap = await getDoc(doc(db, "membros", currentUser));
    if (!membroSnap.exists()) return;

    const dadosMembro = membroSnap.data();
    const ultimoPopupVisto = dadosMembro.ultimoPopupAnoNovoVisto || 0; 
    
    // Tratamento de data de entrada para n√£o parabenizar quem entrou DEPOIS da temporada
    const dataEntrada = dadosMembro.dataEntrada ? dadosMembro.dataEntrada.toDate() : new Date(2000, 0, 1);
    const anoEntrada = dataEntrada.getFullYear();

    // 3. Verifica se deve exibir (se ainda n√£o viu e se participou daquele ano)
    if (anoPopup > ultimoPopupVisto && anoEntrada <= anoPopup) {
      
      // --- L√ìGICA DE PERSONALIZA√á√ÉO ---
      let textoVencedor = "uma temporada incr√≠vel!";
      let equipesVencedoras = [];

      try {
          // Busca quem ganhou no documento do Hall da Fama daquele ano
          const hallRef = doc(db, "hallDaFama", String(anoPopup));
          const hallSnap = await getDoc(hallRef);
          
          if (hallSnap.exists()) {
              const dadosHall = hallSnap.data();
              equipesVencedoras = dadosHall.vencedora || []; // Array de nomes, ex: ['abelha']

              if (equipesVencedoras.length === 1) {
                  // Capitaliza a primeira letra (abelha -> Abelha)
                  const nome = equipesVencedoras[0].charAt(0).toUpperCase() + equipesVencedoras[0].slice(1);
                  textoVencedor = `a vit√≥ria da <strong>Equipe ${nome}</strong>!`;
              } else if (equipesVencedoras.length > 1) {
                  const nomes = equipesVencedoras.map(n => n.charAt(0).toUpperCase() + n.slice(1)).join(' e ');
                  textoVencedor = `o empate hist√≥rico entre <strong>${nomes}</strong>!`;
              }
          }
      } catch (errHall) {
          console.error("Erro ao buscar dados do Hall da Fama para o popup:", errHall);
      }

      console.log(`Exibindo popup de Fim de Temporada ${anoPopup} para ${currentUser}.`);
      
      // Define o conte√∫do do Modal
      const tituloEl = document.getElementById('fim-temporada-titulo');
      const msgEl = document.getElementById('fim-temporada-mensagem');
      
      if(tituloEl) tituloEl.textContent = `üåü A Temporada ${anoPopup} foi Encerrada!`;
      
      if(msgEl) {
        msgEl.innerHTML = `
            Um ciclo se encerra e a hist√≥ria foi escrita. Parab√©ns a todos pela dedica√ß√£o e, especialmente, pel${textoVencedor}<br><br>
            Preparem-se: a pr√≥xima temporada trar√° novas hist√≥rias e recome√ßos.
        `;
      }
      
      const btnClose = document.getElementById('fim-temporada-close-btn');
      if(btnClose) btnClose.onclick = () => closeModal('fim-temporada-popup');
      
      openModal('fim-temporada-popup');
      tocarSom('som-conquista');
      
      // Passa as equipes vencedoras para o confete saber qual cor usar
      dispararConfeteFimTemporada(equipesVencedoras);

      // 4. Marca que o usu√°rio j√° viu este popup
      await updateDoc(doc(db, "membros", currentUser), {
        ultimoPopupAnoNovoVisto: anoPopup
      });
    }

  } catch (error) {
    console.error("Erro ao verificar popup de Fim de Temporada:", error);
  }
}

/**
 * (NOVA) Rotina que roda 1x por ano (1¬∫ de Janeiro) para resetar a temporada.
 * √â chamada pela 'executarRotinaDeMeiaNoite'.
 */
async function executarResetDeTemporada() {
  const hoje = getHoje();
  
  // --- ALTERA√á√ÉO PARA O FIM DA TEMPORADA 2025 ---
  // Verifica se √© 1¬∫ de Janeiro (Padr√£o) OU se √© o per√≠odo de Encerramento (a partir de 28/12/2025)
  const ehPrimeiroJan = (hoje.getDate() === 1 && hoje.getMonth() === 0);
  // Alterado de '===' para '>=' para garantir que funcione mesmo se o dia virar
  const ehDomingoEncerramento = (hoje.getFullYear() === 2025 && hoje.getMonth() === 11 && hoje.getDate() >= 28);

  if (!ehPrimeiroJan && !ehDomingoEncerramento) {
    return;
  }

  // Se for Dezembro (28/12), o ano a fechar √© o ATUAL (2025). 
  // Se for Janeiro (01/01), o ano a fechar √© o ANTERIOR.
  const anoPassado = (hoje.getMonth() === 11) ? hoje.getFullYear() : hoje.getFullYear() - 1;
  
  const lockId = `temporada_${anoPassado}_encerrada`;
  const lockRef = doc(db, "appState", "seasonResetLock");

  try {
    const lockDoc = await getDoc(lockRef);
    if (lockDoc.exists() && lockDoc.data().lastReset === lockId) {
      console.log(`Reset da temporada ${anoPassado} j√° foi executado.`);
      return; // J√° foi feito
    }

    console.log(`üéâ EXECUTANDO RESET DE TEMPORADA PARA ${anoPassado}! üéâ`);

    // 1. Pegar o ranking final da temporada que acabou
    const rankingRef = doc(db, "ranking", "geral");
    const rankingSnap = await getDoc(rankingRef);
    if (!rankingSnap.exists()) {
      throw new Error("Documento de ranking 'geral' n√£o encontrado!");
    }
    const rankingData = rankingSnap.data();

    // 2. Encontrar a equipe vencedora
    const rankingArray = Object.entries(rankingData); // [ ['abelha', 20], ['joaninha', 15], ... ]
    if (rankingArray.length === 0) {
       throw new Error("Ranking vazio, n√£o √© poss√≠vel determinar vencedor.");
    }
    
    rankingArray.sort((a, b) => b[1] - a[1]); // Ordena do maior para o menor
    
    // Detecta empates
    const maxVitorias = rankingArray[0][1];
    // Filtra todas as equipes que t√™m o mesmo n√∫mero m√°ximo de vit√≥rias
    const equipesVencedoras = rankingArray
        .filter(item => item[1] === maxVitorias)
        .map(item => item[0]); // Pega apenas os nomes (ex: ['abelha', 'vagalume'])

    const vitoriasVencedora = maxVitorias;
    
    // 3. Salvar o resultado no Hall da Fama
    const hallRef = doc(db, "hallDaFama", `${anoPassado}`);
    await setDoc(hallRef, {
      ano: anoPassado,
      vencedora: equipesVencedoras, // Agora salva um ARRAY de vencedores
      vitorias: vitoriasVencedora,
      rankingCompleto: rankingData
    });

    // 4. Resetar o ranking 'geral' para a nova temporada
    await setDoc(rankingRef, {
      abelha: 0,
      joaninha: 0,
      vagalume: 0
    });
    // Atualiza o cache local
    rankingGeral.abelha = 0;
    rankingGeral.joaninha = 0;
    rankingGeral.vagalume = 0;

    // 5. Ativar o flag global para o popup de Ano Novo
    await setDoc(doc(db, "appState", "status"), { 
      popupAnoNovo: anoPassado // Flag para o ano que terminou (ex: 2024)
    }, { merge: true });

    // 6. Colocar a trava final
    await setDoc(lockRef, { lastReset: lockId });
    
    console.log(`Reset da temporada ${anoPassado} conclu√≠do. Vencedora: ${nomeVencedora}.`);

    // 7. Atualizar a interface local (Hall da Fama e Ranking)
    await carregarHallDaFama();
    atualizarRankingGeral();

  } catch (error) {
    console.error("ERRO CR√çTICO no reset da temporada:", error);
    // N√£o trava o app, mas registra o erro
  }
}
// =============================================
// ===== FIM: FUN√á√ïES DE TEMPORADA ANUAL =====
// =============================================

// --- FUN√á√ïES DO MAPA E LOCALIZA√á√ÉO ---

// Fun√ß√£o do Mapa com Espa√ßamento M√≠nimo Garantido (v3)
function inicializarMapa() {
  const container = document.getElementById('mapa-container');
  if (!container) return;

  const frases = [
    "‚ÄúEspalhados, mas unidos üå±‚Äù",
    "‚ÄúOs √âpicos est√£o por toda a parte ‚ú®‚Äù",
    "‚ÄúDist√¢ncia nenhuma apaga a chama √©pica üî•‚Äù",
    "‚ÄúDe norte a sul, o foco nos conecta üåé‚Äù"
  ];
  const fraseEl = document.getElementById('frase-mapa');
  if(fraseEl) fraseEl.textContent = frases[Math.floor(Math.random() * frases.length)];

  // Inicializa ou limpa o mapa
  if (mapaEpicos) {
    marcadoresMapa.forEach(m => mapaEpicos.removeLayer(m));
    marcadoresMapa = [];
    mapaEpicos.off('zoomend'); 
  } else {
    // --- CORRE√á√ÉO DE ZOOM MOBILE ---
    // Se a tela for menor que 768px (celular), usa zoom 3. Se for maior, usa zoom 4.
    const isMobile = window.innerWidth < 768;
    const zoomInicial = isMobile ? 3 : 4; 
    
    // Ajuste fino do centro para mobile (opcional, sobe um pouco o mapa para centralizar melhor)
    const centroInicial = isMobile ? [-12.0, -51.925] : [-14.235, -51.925];

    mapaEpicos = L.map('mapa-container').setView(centroInicial, zoomInicial);
    
    L.tileLayer('https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png', {
      attribution: '&copy; OpenStreetMap & CartoDB',
      maxZoom: 19
    }).addTo(mapaEpicos);
  }

  const listaTextoContainer = document.getElementById('lista-localizacao-texto');
  listaTextoContainer.innerHTML = '';

  // 1. Agrupar membros pela mesma coordenada exata
  let gruposDeCoordenadas = {};

  todosMembros.forEach(membro => {
    if (!membro.localizacao) return;
    const { cidade, estado, latitude, longitude } = membro.localizacao;

    if (latitude && longitude) {
        const key = `${latitude.toFixed(4)},${longitude.toFixed(4)}`;
        if (!gruposDeCoordenadas[key]) {
            gruposDeCoordenadas[key] = [];
        }
        gruposDeCoordenadas[key].push(membro);
    }
    
    // Lista de texto abaixo do mapa
    let emojiLista = 'üí°';
    if (membro.papel === 'lider') emojiLista = 'üëë';
    else if (membro.equipe === 'abelha') emojiLista = 'üêù';
    else if (membro.equipe === 'joaninha') emojiLista = 'üêû';
    
    const itemLista = document.createElement('div');
    itemLista.className = 'item-localizacao';
    itemLista.innerHTML = `${emojiLista} <strong>${membro.nome}</strong> ‚Äî ${cidade}/${estado}`;
    listaTextoContainer.appendChild(itemLista);
  });

  // 2. Criar os marcadores
  for (const key in gruposDeCoordenadas) {
      const membrosNoLocal = gruposDeCoordenadas[key];
      const qtd = membrosNoLocal.length;
      
      membrosNoLocal.forEach((membro, index) => {
          let { cidade, estado, latitude, longitude } = membro.localizacao;
          
          // Defini√ß√£o de Estilo
          let corClasse = 'vagalume';
          let emoji = 'üí°';
          let nomeEquipeTexto = 'Membro';

          if (membro.papel === 'lider') {
              corClasse = 'lider-geral'; emoji = 'üëë'; nomeEquipeTexto = 'L√≠der Geral';
          } else if (membro.equipe === 'abelha') { 
              corClasse = 'abelha'; emoji = 'üêù'; nomeEquipeTexto = 'Equipe Abelha';
          } else if (membro.equipe === 'joaninha') { 
              corClasse = 'joaninha'; emoji = 'üêû'; nomeEquipeTexto = 'Equipe Joaninha';
          } else if (membro.equipe === 'vagalume') { 
              corClasse = 'vagalume'; emoji = 'üí°'; nomeEquipeTexto = 'Equipe Vaga-lume';
          }

          const customIcon = L.divIcon({
            className: 'custom-div-icon',
            html: `<div class='marker-pin ${corClasse}'></div>`,
            iconSize: [30, 42],
            iconAnchor: [15, 42]
          });

          const marker = L.marker([latitude, longitude], { icon: customIcon }).addTo(mapaEpicos);
          
          const popupContent = `
            <div style="text-align:center;">
              <strong style="font-size:1.1rem;">${emoji} ${membro.nome}</strong><br>
              <span style="color:#7f8c8d;">${nomeEquipeTexto}</span><br>
              <hr style="margin:5px 0; border:0; border-top:1px solid #eee;">
              üìç ${cidade}, ${estado}
            </div>
          `;
          marker.bindPopup(popupContent);
          
          // Salva dados para rec√°lculo
          marker.dadosPosicao = {
              latOriginal: latitude,
              lngOriginal: longitude,
              indice: index,
              totalNoGrupo: qtd,
              angulo: (index / qtd) * (2 * Math.PI)
          };

          marcadoresMapa.push(marker);
      });
  }

  // 3. Fun√ß√£o INTELIGENTE de atualiza√ß√£o de posi√ß√£o
  const atualizarPosicoesVisuais = () => {
      const zoomAtual = mapaEpicos.getZoom();
      
      // --- CORRE√á√ÉO DE DIST√ÇNCIA DOS PINOS ---
      
      // Reduzimos o multiplicador base de 0.00025 para 0.00006.
      // Isso faz com que, no zoom inicial, os pinos fiquem muito mais pr√≥ximos da cidade original.
      const calculoDinamico = 0.00006 * Math.pow(2, (16 - zoomAtual));
      
      // Dist√¢ncia M√≠nima Fixa (aprox 300m) para quando der muito zoom (n√≠vel rua)
      const distanciaMinima = 0.003; 

      // A M√ÅGICA: Usa o MAIOR valor, mas agora com um teto m√°ximo
      let fatorAfastamento = Math.max(calculoDinamico, distanciaMinima);
      
      // TRAVA DE SEGURAN√áA: Se o zoom for muito distante (pa√≠s inteiro),
      // limitamos o afastamento m√°ximo para 0.5 graus (aprox 50km) para n√£o cair no mar.
      if (zoomAtual <= 5) {
          fatorAfastamento = Math.min(fatorAfastamento, 0.5);
      }

      marcadoresMapa.forEach(marker => {
          const d = marker.dadosPosicao;
          
          if (d.totalNoGrupo > 1) {
              // Aplica o afastamento em c√≠rculo
              const latOffset = Math.cos(d.angulo) * fatorAfastamento;
              const lngOffset = Math.sin(d.angulo) * fatorAfastamento;
              
              marker.setLatLng([d.latOriginal + latOffset, d.lngOriginal + lngOffset]);
          } else {
              marker.setLatLng([d.latOriginal, d.lngOriginal]);
          }
      });
  };

  mapaEpicos.on('zoomend', atualizarPosicoesVisuais);
  atualizarPosicoesVisuais(); // Executa imediatamente
}

// --- FUN√á√ïES DE LOCALIZA√á√ÉO (IBGE + OPEN-METEO) ---

// 1. Carrega a lista de Estados do IBGE ao abrir o modal ou iniciar
window.carregarEstadosIBGE = async function() {
    const selectEstado = document.getElementById('input-loc-estado');
    if (selectEstado.options.length > 1) return; // J√° carregou

    try {
        const response = await fetch('https://servicodados.ibge.gov.br/api/v1/localidades/estados?orderBy=nome');
        const estados = await response.json();
        
        estados.forEach(uf => {
            const option = document.createElement('option');
            option.value = uf.sigla;
            option.textContent = `${uf.nome} (${uf.sigla})`;
            selectEstado.appendChild(option);
        });
    } catch (error) {
        console.error("Erro ao carregar estados:", error);
    }
}

// 2. Carrega as Cidades quando o Estado muda
window.carregarCidadesPorEstado = async function() {
    const uf = document.getElementById('input-loc-estado').value;
    const inputCidade = document.getElementById('input-loc-cidade');
    const datalist = document.getElementById('lista-cidades-brasil');
    
    inputCidade.value = ''; // Limpa cidade anterior
    datalist.innerHTML = ''; // Limpa lista anterior
    
    if (!uf) {
        inputCidade.disabled = true;
        inputCidade.placeholder = "Primeiro selecione o estado...";
        return;
    }

    inputCidade.disabled = false;
    inputCidade.placeholder = "Carregando cidades...";
    inputCidade.focus();

    try {
        const response = await fetch(`https://servicodados.ibge.gov.br/api/v1/localidades/estados/${uf}/municipios`);
        const cidades = await response.json();
        
        cidades.forEach(cidade => {
            const option = document.createElement('option');
            option.value = cidade.nome;
            datalist.appendChild(option);
        });
        
        inputCidade.placeholder = "Digite ou selecione a cidade...";
    } catch (error) {
        console.error("Erro ao carregar cidades:", error);
        inputCidade.placeholder = "Erro ao carregar cidades.";
    }
}

// --- NOVA FUN√á√ÉO: Alterna entre modo Brasil (IBGE) e Internacional ---
window.alternarModoLocalizacao = function() {
    const pais = document.getElementById('input-loc-pais').value;
    const containerBR = document.getElementById('container-loc-brasil');
    const containerGringo = document.getElementById('container-loc-gringo');

    if (pais === 'BR') {
        containerBR.classList.remove('hidden');
        containerGringo.classList.add('hidden');
        // Se voltou para o Brasil e a lista est√° vazia, carrega
        const selectEstado = document.getElementById('input-loc-estado');
        if (selectEstado.options.length <= 1) {
            carregarEstadosIBGE();
        }
    } else {
        containerBR.classList.add('hidden');
        containerGringo.classList.remove('hidden');
    }
}

// Fun√ß√£o de Abrir Modal (CORRIGIDA: Sem refer√™ncias a lat/lon)
window.abrirModalLocalizacao = function() {
  if (!currentUser) {
    mostrarPopup("üö´ Erro", "Fa√ßa login para ajustar sua localiza√ß√£o.", 3000);
    return;
  }
  
  const membro = todosMembros.find(m => m.nome === currentUser);
  
  // Elementos do DOM
  const paisSelect = document.getElementById('input-loc-pais');
  const estadoSelectBR = document.getElementById('input-loc-estado');
  const cidadeInputBR = document.getElementById('input-loc-cidade');
  
  const estadoInputGringo = document.getElementById('input-loc-estado-gringo');
  const cidadeInputGringo = document.getElementById('input-loc-cidade-gringo');

  // Define o valor padr√£o
  let paisSalvo = 'BR';
  if (membro && membro.localizacao && membro.localizacao.pais) {
      paisSalvo = membro.localizacao.pais;
  }
  paisSelect.value = paisSalvo;
  
  // Configura a visibilidade correta
  alternarModoLocalizacao();

  if (paisSalvo === 'BR') {
      // L√≥gica Brasil (Carrega IBGE)
      carregarEstadosIBGE().then(() => {
          if (membro && membro.localizacao) {
              estadoSelectBR.value = membro.localizacao.estado || '';
              cidadeInputBR.value = membro.localizacao.cidade || '';
              if (membro.localizacao.estado) {
                  cidadeInputBR.disabled = false;
                  carregarCidadesPorEstado(); 
              }
          } else {
              estadoSelectBR.value = '';
              cidadeInputBR.value = '';
              cidadeInputBR.disabled = true;
          }
      });
  } else {
      // L√≥gica Internacional (Preenche Texto)
      if (membro && membro.localizacao) {
          estadoInputGringo.value = membro.localizacao.estado || '';
          cidadeInputGringo.value = membro.localizacao.cidade || '';
      } else {
          estadoInputGringo.value = '';
          cidadeInputGringo.value = '';
      }
  }
  
  // Configura o bot√£o de salvar
  document.getElementById('btn-salvar-localizacao').onclick = salvarLocalizacaoUsuario;
  
  openModal('modal-localizacao');
}

async function salvarLocalizacaoUsuario() {
  const paisCode = document.getElementById('input-loc-pais').value; // Ex: 'BR', 'PE', 'OUTRO'
  let cidade, estadoOuRegiao, termoBusca;
  
  const btn = document.getElementById('btn-salvar-localizacao');
  btn.disabled = true;
  btn.textContent = "Varrendo mapa...";

  // 1. Coleta os dados
  if (paisCode === 'BR') {
      cidade = document.getElementById('input-loc-cidade').value.trim();
      const estadoSelect = document.getElementById('input-loc-estado');
      estadoOuRegiao = estadoSelect.value.trim().toUpperCase(); 
      
      if (!cidade || !estadoOuRegiao) {
        mostrarPopup("‚ö†Ô∏è Aten√ß√£o", "Cidade e Estado s√£o obrigat√≥rios.", 3000);
        btn.disabled = false; btn.textContent = "Salvar Localiza√ß√£o";
        return;
      }
  } else {
      // Internacional
      cidade = document.getElementById('input-loc-cidade-gringo').value.trim();
      estadoOuRegiao = document.getElementById('input-loc-estado-gringo').value.trim();
      
      if (!cidade) {
        mostrarPopup("‚ö†Ô∏è Aten√ß√£o", "O nome da cidade √© obrigat√≥rio.", 3000);
        btn.disabled = false; btn.textContent = "Salvar Localiza√ß√£o";
        return;
      }
  }
  
  let lat = ''; 
  let lon = '';

  try {
    // --- ESTRAT√âGIA DE BUSCA INTELIGENTE ---
    // Buscamos apenas o nome da cidade primeiro. Isso retorna uma lista de cidades com esse nome no mundo todo.
    // Depois, filtramos a lista para encontrar a que bate com o pa√≠s e estado selecionado.
    
    console.log(`Buscando coordenadas para cidade: "${cidade}" no pa√≠s: "${paisCode}"`);
    const url = `https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(cidade)}&count=10&language=pt&format=json`;
    
    const res = await fetch(url);
    const data = await res.json();

    if (data.results && data.results.length > 0) {
        let match = null;

        // FILTRAGEM:
        if (paisCode === 'BR') {
            // Se for Brasil, procura o resultado onde country_code √© BR e o estado bate
            match = data.results.find(r => 
                r.country_code === 'BR' && 
                (r.admin1?.toUpperCase().includes(estadoOuRegiao) || r.admin1_code?.includes(estadoOuRegiao))
            );
        } else if (paisCode === 'OUTRO') {
            // Se for "Outro", confiamos no primeiro resultado ou tentamos bater o nome do estado se foi digitado
            if (estadoOuRegiao) {
                match = data.results.find(r => 
                    r.admin1?.toLowerCase().includes(estadoOuRegiao.toLowerCase()) || 
                    r.country?.toLowerCase().includes(estadoOuRegiao.toLowerCase())
                );
            }
            // Se n√£o achou espec√≠fico ou n√£o digitou estado, pega o primeiro da lista (geralmente a capital ou cidade maior)
            if (!match) match = data.results[0];

        } else {
            // Se for um pa√≠s espec√≠fico (Ex: Peru 'PE'), filtra pelo country_code
            match = data.results.find(r => r.country_code === paisCode);
            
            // Fallback: Se n√£o achou pelo c√≥digo exato, tenta pelo nome do estado se o usu√°rio digitou
            if (!match && estadoOuRegiao) {
                 match = data.results.find(r => r.admin1?.toLowerCase().includes(estadoOuRegiao.toLowerCase()));
            }
        }

        // Se encontrou um match v√°lido
        if (match) {
            lat = match.latitude;
            lon = match.longitude;
            console.log("Localiza√ß√£o confirmada:", match.name, match.country, match.admin1);
        }
    }

    // --- PLANO B: BUSCA COMPOSTA (Se a busca simples falhar) ---
    if (!lat) {
        console.log("Busca simples falhou. Tentando busca composta...");
        const selectPais = document.getElementById('input-loc-pais');
        let nomePaisTexto = selectPais.options[selectPais.selectedIndex].text.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, '').trim();
        if (paisCode === 'OUTRO') nomePaisTexto = ""; // N√£o adicionar "Outro" na busca
        
        const termoComposto = `${cidade} ${estadoOuRegiao || ''} ${nomePaisTexto}`.trim();
        const urlB = `https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(termoComposto)}&count=1&language=pt&format=json`;
        
        const resB = await fetch(urlB);
        const dataB = await resB.json();
        
        if (dataB.results && dataB.results.length > 0) {
            lat = dataB.results[0].latitude;
            lon = dataB.results[0].longitude;
        }
    }

    // --- VERIFICA√á√ÉO FINAL ---
    if (!lat || !lon) {
        mostrarPopup("‚ùå N√£o encontrado", `N√£o conseguimos encontrar "${cidade}" neste pa√≠s. Tente escrever o nome da cidade em ingl√™s (ex: London) ou verifique a grafia.`, 6000);
        return;
    }

    const dadosLoc = {
      pais: paisCode,
      cidade: cidade,
      estado: estadoOuRegiao,
      latitude: parseFloat(lat),
      longitude: parseFloat(lon)
    };

    await updateDoc(doc(db, "membros", currentUser), {
      localizacao: dadosLoc
    });

    // Atualiza localmente
    const membroIndex = todosMembros.findIndex(m => m.nome === currentUser);
    if (membroIndex > -1) {
      todosMembros[membroIndex].localizacao = dadosLoc;
    }

    mostrarPopup("‚úÖ Sucesso", "Localiza√ß√£o salva corretamente!", 3000);
    closeModal('modal-localizacao');
    inicializarMapa(); 

  } catch (error) {
    console.error("Erro ao salvar localiza√ß√£o:", error);
    mostrarPopup("‚ùå Erro", "N√£o foi poss√≠vel salvar.", 4000);
  } finally {
    btn.disabled = false;
    btn.textContent = "Salvar Localiza√ß√£o";
  }
}

// --- NOVAS FUN√á√ïES: GERENCIADOR DE G√äNEROS ---

// Fun√ß√£o para salvar o g√™nero do membro
async function toggleGeneroMembro(nome, novoGenero) {
  try {
    const membroRef = doc(db, "membros", nome);
    
    await updateDoc(membroRef, { 
        genero: novoGenero 
    });
    
    // Atualiza o cache local imediatamente para n√£o precisar recarregar
    const index = todosMembros.findIndex(m => m.nome === nome);
    if (index !== -1) {
        todosMembros[index].genero = novoGenero;
    }

    mostrarPopup("‚úÖ Atualizado", `G√™nero de ${nome} definido como: ${novoGenero}`, 2000);
  } catch (error) {
    console.error(`Erro ao atualizar g√™nero para ${nome}:`, error);
    mostrarPopup("‚ùå Erro", "N√£o foi poss√≠vel salvar a altera√ß√£o.", 4000);
  }
}

// Fun√ß√£o para popular o painel de g√™neros com op√ß√µes
function popularPainelGeneros() {
  const listaContainer = document.getElementById('generos-lista-membros');
  if (!listaContainer) return;
  
  listaContainer.innerHTML = ''; 

  const membrosOrdenados = [...todosMembros].sort((a, b) => a.nome.localeCompare(b.nome));

  membrosOrdenados.forEach(membro => {
    // Opcional: se quiser esconder o pr√≥prio l√≠der da lista, descomente a linha abaixo
    // if (membro.papel === 'lider') return;

    const itemEl = document.createElement('div');
    itemEl.className = 'ferias-item'; // Reutiliza o estilo CSS do item de f√©rias
    itemEl.style.justifyContent = "space-between"; 

    // Determina o valor atual
    let valorAtual = membro.genero || 'indefinido';

    itemEl.innerHTML = `
      <label for="genero_${membro.nome}" style="font-weight: 500;">${membro.nome}</label>
      <select id="genero_${membro.nome}" class="painel-input" style="width: 140px; padding: 5px;">
        <option value="indefinido" ${valorAtual === 'indefinido' ? 'selected' : ''}>‚ùì Indefinido</option>
        <option value="masculino" ${valorAtual === 'masculino' ? 'selected' : ''}>üë® Masculino</option>
        <option value="feminino" ${valorAtual === 'feminino' ? 'selected' : ''}>üë© Feminino</option>
      </select>
    `;

    // Evento de mudan√ßa
    itemEl.querySelector('select').addEventListener('change', (e) => {
      toggleGeneroMembro(membro.nome, e.target.value);
    });

    listaContainer.appendChild(itemEl);
  });
}

// Fun√ß√£o para o l√≠der decretar feriado manual
async function handleDecretarFeriado() {
    const dataInput = document.getElementById('input-data-feriado').value;
    const nomeInput = document.getElementById('input-nome-feriado').value.trim();

    if (!dataInput || !nomeInput) {
        mostrarPopup("‚ùå Erro", "Preencha a data e o nome do feriado.", 3000);
        return;
    }

    // Ajusta a data para evitar problemas de fuso hor√°rio ao salvar a string YYYY-MM-DD
    const [ano, mes, dia] = dataInput.split('-');
    const dataISO = `${ano}-${mes}-${dia}`;
    
    try {
        const feriadosRef = doc(db, "configuracoes", "feriadosManuais");
        
        // Salva no banco de dados
        await setDoc(feriadosRef, {
            [dataISO]: nomeInput
        }, { merge: true });

        // Atualiza o cache local
        cacheFeriadosManuais[dataISO] = nomeInput;

        mostrarPopup("‚úÖ Sucesso", `Feriado "${nomeInput}" agendado para ${dia}/${mes}/${ano}.`, 4000);

        // Se a data for HOJE, processa imediatamente
        const hojeISO = getHojeISO();
        if (dataISO === hojeISO) {
            console.log("O feriado decretado √© HOJE. Executando imediatamente...");
            await processarFeriadoDoDia();
        }

        // Limpa os campos
        document.getElementById('input-nome-feriado').value = '';

    } catch (error) {
        console.error("Erro ao agendar feriado:", error);
        mostrarPopup("‚ùå Erro", "Falha ao salvar o feriado.", 4000);
    }
}

// --- L√ìGICA DO NOVO CALEND√ÅRIO (ATUALIZADA) ---
let calendarioMesAtual = new Date().getMonth();
let calendarioAnoAtual = new Date().getFullYear();

// Torna as fun√ß√µes acess√≠veis globalmente para corrigir o erro "not defined"
window.iniciarCalendario = function() {
    renderizarCalendario(calendarioMesAtual, calendarioAnoAtual);
}

window.mudarMesCalendario = function(direcao) {
    calendarioMesAtual += direcao;
    if (calendarioMesAtual < 0) {
        calendarioMesAtual = 11;
        calendarioAnoAtual--;
    } else if (calendarioMesAtual > 11) {
        calendarioMesAtual = 0;
        calendarioAnoAtual++;
    }
    renderizarCalendario(calendarioMesAtual, calendarioAnoAtual);
}

async function renderizarCalendario(mes, ano) {
    const calendarDays = document.getElementById('calendar-days');
    const monthYearText = document.getElementById('calendar-month-year');
    const detailsContainer = document.getElementById('calendar-event-details');
    
    if(!calendarDays) return;

    calendarDays.innerHTML = '';
    if(detailsContainer) detailsContainer.classList.add('hidden');

    const nomesMeses = ["Janeiro", "Fevereiro", "Mar√ßo", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"];
    monthYearText.textContent = `${nomesMeses[mes]} ${ano}`;

    const primeiroDiaSemana = new Date(ano, mes, 1).getDay(); // 0 = Domingo
    const diasNoMes = new Date(ano, mes + 1, 0).getDate();
    
    // Espa√ßos vazios antes do dia 1
    for (let i = 0; i < primeiroDiaSemana; i++) {
        const emptyDiv = document.createElement('div');
        emptyDiv.className = 'calendar-day empty';
        calendarDays.appendChild(emptyDiv);
    }

    // Feriados Fixos (Com emoji üéâ)
    const feriadosFixos = {
        "01/01": "üéâ Confraterniza√ß√£o Universal", 
        "08/03": "üéâ Dia da Mulher", 
        "21/04": "üéâ Tiradentes",
        "01/05": "üéâ Dia do Trabalhador", 
        "12/06": "üéâ Dia dos Namorados", 
        "07/09": "üéâ Independ√™ncia",
        "12/10": "üéâ Nsa. Sra. Aparecida", 
        "15/10": "üéâ Dia dos Professores", 
        "02/11": "üéâ Finados",
        "15/11": "üéâ Proclama√ß√£o Rep√∫blica", 
        "20/11": "üéâ Consci√™ncia Negra", 
        "24/12": "üéâ V√©spera de Natal",
        "25/12": "üéâ Natal", 
        "31/12": "üéâ V√©spera de Ano Novo"
    };

    // Renderiza os dias
    for (let dia = 1; dia <= diasNoMes; dia++) {
        const dataAtualLoop = new Date(ano, mes, dia);
        const diaSemana = dataAtualLoop.getDay();
        const dataFormatada = `${String(dia).padStart(2, '0')}/${String(mes + 1).padStart(2, '0')}`;
        const dataISO = `${ano}-${String(mes + 1).padStart(2, '0')}-${String(dia).padStart(2, '0')}`;
        
        const dayEl = document.createElement('div');
        dayEl.className = 'calendar-day';
        
        // Marca o dia de hoje
        const hojeReal = getHoje();
        if (dia === hojeReal.getDate() && mes === hojeReal.getMonth() && ano === hojeReal.getFullYear()) {
            dayEl.classList.add('today');
        }

        const dayNumber = document.createElement('div');
        dayNumber.className = 'day-number';
        dayNumber.textContent = dia;
        dayEl.appendChild(dayNumber);

        const contentDiv = document.createElement('div');
        contentDiv.className = 'day-content';
        
        // === 1. Eventos de Rotina (SEPARADOS e COM EMOJIS) ===
        
        // Segunda-feira (1): In√≠cio Jogo e In√≠cio Competi√ß√£o
        if (diaSemana === 1) {
            addEventDot(contentDiv, '‚öîÔ∏è In√≠cio da Competi√ß√£o', 'evt-competicao');
			addEventDot(contentDiv, 'üéÆ In√≠cio do Jogo da Vantagem', 'evt-jogo');
        }

        // TER√áA-FEIRA (2): Resultado da Batalha de Desenhos (NOVO - Cor √önica)
        if (diaSemana === 2) {
             addEventDot(contentDiv, 'üé® Resultado da Batalha de Desenhos', 'evt-desenho');
        }
        
        // Quarta-feira (3): Loteria
        if (diaSemana === 3) {
            addEventDot(contentDiv, 'üçÄ Sorteio da Loteria', 'evt-loteria');
        }

        // QUINTA-FEIRA (4): Novo Tema de Desenho (NOVO - Cor √önica)
        if (diaSemana === 4) {
             addEventDot(contentDiv, 'üñåÔ∏è Novo Tema de Desenho', 'evt-desenho');
        }
        
        // Sexta-feira (5): Fim do Jogo da Vantagem
        if (diaSemana === 5) {
            addEventDot(contentDiv, 'üèÅ Fim do Jogo da Vantagem', 'evt-jogo');
        }
        
        // S√°bado (6): Fim da Competi√ß√£o
        if (diaSemana === 6) {
            addEventDot(contentDiv, 'üèÅ Fim da Competi√ß√£o', 'evt-competicao');
        }
        
        // Domingo (0): Resultado
        if (diaSemana === 0) {
            addEventDot(contentDiv, 'üèÜ Resultado da competi√ß√£o', 'evt-resultado');
        }

        // === 2. Feriados (Fixos e Manuais) ===
        if (feriadosFixos[dataFormatada]) {
            addEventDot(contentDiv, feriadosFixos[dataFormatada], 'evt-feriado');
        }
        
        if (typeof cacheFeriadosManuais !== 'undefined' && cacheFeriadosManuais[dataISO]) {
             addEventDot(contentDiv, `üéâ ${cacheFeriadosManuais[dataISO]}`, 'evt-feriado');
        }

        // === 3. Anivers√°rios ===
        todosMembros.forEach(m => {
            if (m.aniversario && m.aniversario === dataFormatada) {
                addEventDot(contentDiv, `üéÇ ${m.nome}`, 'evt-aniversario');
            }
        });

        dayEl.appendChild(contentDiv);
        
        // Clique para ver detalhes
        dayEl.onclick = () => mostrarDetalhesDia(dia, mes, ano, contentDiv);
        
        calendarDays.appendChild(dayEl);
    }
}

function addEventDot(container, text, className) {
    const dot = document.createElement('div');
    dot.className = `event-dot ${className}`;
    dot.textContent = text;
    dot.title = text; // Tooltip nativo para ler o texto completo ao passar o mouse
    container.appendChild(dot);
}

function mostrarDetalhesDia(dia, mes, ano, contentDiv) {
    const container = document.getElementById('calendar-event-details');
    if (!container) return;

    const dataStr = `${String(dia).padStart(2, '0')}/${String(mes + 1).padStart(2, '0')}/${ano}`;
    
    // Pega o texto dos eventos
    const eventos = Array.from(contentDiv.children).map(el => {
        let corBola = window.getComputedStyle(el).backgroundColor;
        return `<div style="margin-bottom:8px; display:flex; align-items:center;">
                  <span style="display:inline-block;width:12px;height:12px;border-radius:50%;background:${corBola};margin-right:10px;flex-shrink:0;"></span>
                  <span style="font-size:1rem;">${el.textContent || el.title}</span>
                </div>`;
    });

    if (eventos.length > 0) {
        container.innerHTML = `<h4 style="margin-bottom:10px; border-bottom:1px solid #ddd; padding-bottom:5px;">Eventos em ${dataStr}:</h4>${eventos.join('')}`;
        container.classList.remove('hidden');
    } else {
        container.innerHTML = `<h4 style="margin-bottom:10px;">${dataStr}</h4><p style="color:#7f8c8d; font-style:italic;">Nenhum evento especial neste dia.</p>`;
        container.classList.remove('hidden');
    }
}

// =============================================
// ===== FUN√á√ïES DE RECOMPENSA DI√ÅRIA =====
// =============================================

async function carregarRecompensaDiaria() {
  if (!currentUser) return;
  
  // OTIMIZA√á√ÉO: Busca os dados na mem√≥ria global 'todosMembros'
  // em vez de fazer uma nova leitura no Firestore.
  const membroCache = todosMembros.find(m => m.nome === currentUser);
  
  if (membroCache) {
    let streak = membroCache.dailyRewardStreak || 0;
    
    // Tratamento de timestamp (pode vir como objeto do Firestore ou Date direto dependendo do cache)
    let lastClaimTimestamp = null;
    if (membroCache.lastDailyRewardClaim) {
        if (membroCache.lastDailyRewardClaim.toDate) {
            lastClaimTimestamp = membroCache.lastDailyRewardClaim.toDate();
        } else {
            lastClaimTimestamp = new Date(membroCache.lastDailyRewardClaim);
        }
    }
    
    const hoje = getHoje();
    hoje.setHours(0,0,0,0);
    
    let jaResgatouHoje = false;

    if (lastClaimTimestamp) {
      const lastClaim = new Date(lastClaimTimestamp);
      lastClaim.setHours(0,0,0,0);
      
      const diffTime = hoje.getTime() - lastClaim.getTime();
      const diffDays = Math.floor(diffTime / (1000 * 3600 * 24));

      if (diffDays === 0) {
        jaResgatouHoje = true;
      } else if (diffDays > 1) {
        
        // --- L√ìGICA DE PROTE√á√ÉO DE SEQU√äNCIA (ATUALIZADA) ---
        // Verifica se o membro tinha prote√ß√£o ativa durante o per√≠odo que ficou fora
        const dadosProtecao = membroCache.protecaoSoftBlock || {};
        const protegidoAte = dadosProtecao.protegidoAte ? 
            (dadosProtecao.protegidoAte.toDate ? dadosProtecao.protegidoAte.toDate() : new Date(dadosProtecao.protegidoAte)) 
            : null;

        // A l√≥gica: Se a data de "protegidoAte" √© posterior √† data do √∫ltimo resgate,
        // significa que o escudo estava ativo cobrindo o intervalo de aus√™ncia.
        const protecaoValida = protegidoAte && protegidoAte.getTime() > lastClaim.getTime();

        if (protecaoValida) {
            console.log(`üõ°Ô∏è Sequ√™ncia de ${currentUser} mantida gra√ßas ao Escudo de Prote√ß√£o!`);
            
            // N√£o zera o streak. Mant√©m o valor atual.
            
            // Mostra um aviso visual para o usu√°rio entender por que n√£o perdeu
            // Usamos um pequeno timeout para n√£o atropelar outros popups de login
            setTimeout(() => {
                mostrarCardPopup(
                    "üõ°Ô∏è Escudo Ativado!", 
                    "Voc√™ ficou ausente, mas sua sequ√™ncia de dias foi <strong>salva</strong> pelo Escudo de Prote√ß√£o.<br><br>Continue focado!", 
                    null
                );
            }, 1500);

        } else {
            // Caso contr√°rio: Perdeu a sequ√™ncia! (Sem prote√ß√£o ou prote√ß√£o venceu antes)
            if (streak > 0) {
               // O reset visual
               streak = 0; 
               // Atualiza no banco silenciosamente
               const membroRef = doc(db, "membros", currentUser);
               updateDoc(membroRef, { dailyRewardStreak: 0 });
               
               // Atualiza cache local
               membroCache.dailyRewardStreak = 0;

                adicionarEventoAoFeed(
                    'geral',
                    'üìâ Sequ√™ncia Perdida...',
                    `<strong>${currentUser}</strong> deixou de resgatar a recompensa di√°ria e sua sequ√™ncia voltou ao in√≠cio.`,
                    { nomeMembro: currentUser }
                );
            }
        }
        // --- FIM DA L√ìGICA DE PROTE√á√ÉO ---
      }
    }

    dailyStreakGlobal = streak;
    dailyClaimedToday = jaResgatouHoje;
	
	iniciarTimerRecompensa();
    
    atualizarInterfaceRecompensa();
    popularTabelaNiveis();
  }
}

function atualizarInterfaceRecompensa() {
  const nivelAtual = getNivelRecompensa(dailyStreakGlobal);
  const proximoNivel = NIVEIS_RECOMPENSA.find(n => n.min > dailyStreakGlobal);
  
  // --- NOVO: Define a cor din√¢mica para o CSS usar na borda e no brilho ---
  const container = document.getElementById('secao-recompensa-diaria');
  if (container) {
    container.style.setProperty('--reward-color', nivelAtual.cor);
  }

  // 1. Atualiza Contador e Cores
  const streakNumberEl = document.getElementById('streak-number');
  streakNumberEl.textContent = dailyStreakGlobal;
  streakNumberEl.style.color = nivelAtual.cor;
  
  // 2. Atualiza Bot√£o (Com L√≥gica de Tempo de Espera)
  const btn = document.getElementById('btn-resgatar-diario');
  btn.style.backgroundColor = nivelAtual.cor;
  btn.style.color = nivelAtual.textoCor;

  // Atualiza tamb√©m o bot√£o de consultar regras com a mesma cor
  const btnRegras = document.getElementById('btn-consultar-niveis');
  if (btnRegras) {
      btnRegras.style.backgroundColor = nivelAtual.cor;
      btnRegras.style.color = nivelAtual.textoCor;
      btnRegras.style.borderColor = "transparent"; // Remove borda para ficar limpo
  }
  
  if (dailyClaimedToday) {
    btn.textContent = `Volte Amanh√£`;
    btn.disabled = true;
    btn.style.opacity = "0.5";
    btn.style.animation = "none";
    btn.onclick = null; // Remove o click
  } else {
    // Verifica se o timer global j√° terminou (vamos criar essa vari√°vel no passo seguinte)
    if (window.tempoEsperaRecompensa > 0) {
        btn.textContent = `Aguarde... (${window.tempoEsperaRecompensa}s)`;
        btn.style.opacity = "0.7";
        btn.style.animation = "none";
        // Define o clique para mostrar o aviso
        btn.onclick = () => mostrarCardPopup(
            "‚è≥ Calma, Viajante!", 
            "Voc√™ precisa permanecer ao menos por <strong>30 segundos</strong> na p√°gina para realizar o resgate.<br><br>Aproveite para ver as novidades e notifica√ß√µes!"
        );
    } else {
        btn.textContent = `Resgatar üí∞ ${nivelAtual.valor} Moedas`;
        btn.style.opacity = "1";
        btn.style.animation = "pulse 2s infinite";
        btn.onclick = resgatarRecompensaDiaria; // Restaura a fun√ß√£o original
    }
    btn.disabled = false; // Bot√£o sempre "clic√°vel" para mostrar o popup, exceto se j√° resgatou
  }

  // 3. Atualiza Linha do Tempo (Dias da Semana)
  const dotsContainer = document.getElementById('timeline-dots');
  const lineProgress = document.getElementById('timeline-line-progress');
  dotsContainer.innerHTML = '';
  
  // Mapeamento de Dias: 0=Dom, 1=Seg ... 6=Sab.
  // Queremos ordem: Seg(1), Ter(2), Qua(3), Qui(4), Sex(5), Sab(6), Dom(0/7)
  const hoje = getHoje();
  let diaSemanaHoje = hoje.getDay(); 
  if (diaSemanaHoje === 0) diaSemanaHoje = 7; // Transforma Domingo (0) em 7

  const labelsDias = ["S", "T", "Q", "Q", "S", "S", "D"];

  // Calcula porcentagem da linha baseada no dia da semana (a linha continua preenchendo at√© hoje)
  const progressPercent = Math.min(100, ((diaSemanaHoje - 1) / 6) * 100);
  
  lineProgress.style.width = `${progressPercent}%`;
  lineProgress.style.backgroundColor = nivelAtual.cor;

  for (let i = 1; i <= 7; i++) {
    const stepContainer = document.createElement('div');
    stepContainer.className = 'timeline-step';

    const label = document.createElement('span');
    label.className = 'day-label';
    label.textContent = labelsDias[i-1];
    
    const dot = document.createElement('div');
    dot.className = 'daily-dot';
    
    // --- L√ìGICA ATUALIZADA (Request 1) ---
    if (i < diaSemanaHoje) {
      // √â um dia passado (Ontem, Anteontem...)
      
      // Calcula quantos dias atr√°s foi esse dia 'i'
      // Ex: Hoje √© Quarta (3). Para Segunda (1), diff = 2 dias atr√°s.
      const diasAtras = diaSemanaHoje - i;
      
      // Verifica se o streak atual cobre esse dia
      // Ex: Se streak √© 1, ele come√ßou hoje. 1 > 2 √© falso (Segunda fica cinza).
      // Ex: Se streak √© 5, 5 > 2 √© verdadeiro (Segunda fica colorida).
      if (dailyStreakGlobal > diasAtras) {
          // Faz parte da sequ√™ncia atual -> Colorido
          dot.style.backgroundColor = nivelAtual.cor;
          dot.classList.add('passed');
          label.style.color = nivelAtual.cor;
      } else {
          // N√£o faz parte da sequ√™ncia (Come√ßou depois) -> Cinza (Skipped)
          dot.classList.add('skipped'); // Classe nova definida no CSS
          label.style.color = '#ccc';
      }

    } else if (i === diaSemanaHoje) {
      // Dia Atual
      label.style.fontWeight = "bold";
      label.style.color = nivelAtual.cor;

      if (dailyClaimedToday) {
         // J√° resgatou hoje -> Colorido
         dot.style.backgroundColor = nivelAtual.cor;
         dot.classList.add('claimed');
      } else {
         // Pendente hoje -> Borda colorida e efeito Pulsate (CSS novo)
         dot.className = 'daily-dot current-pending';
         // A cor da borda/brilho agora √© controlada pela vari√°vel CSS --reward-color
      }
    } else {
      // Dias futuros -> Cinza padr√£o
      dot.style.backgroundColor = '#e0e0e0';
      label.style.color = '#ccc';
    }
    
    stepContainer.appendChild(label);
    stepContainer.appendChild(dot);
    dotsContainer.appendChild(stepContainer);
  }

  // 4. Texto de Pr√≥ximo N√≠vel
  const infoEl = document.getElementById('next-level-info');
  if (proximoNivel) {
    const diasFaltam = proximoNivel.min - dailyStreakGlobal;
    // Adicionamos a classe 'quebra-mobile' ao redor dos par√™nteses
    infoEl.innerHTML = `Faltam <strong>${diasFaltam} dias</strong> para o N√≠vel ${NIVEIS_RECOMPENSA.indexOf(proximoNivel) + 1} <span class="quebra-mobile">(${proximoNivel.valor} moedas por dia)!</span>`;
  } else {
    infoEl.textContent = "Voc√™ atingiu o n√≠vel m√°ximo! Mantenha a sequ√™ncia!";
  }
}

async function resgatarRecompensaDiaria() {
  if (dailyClaimedToday) return;
  
  const btn = document.getElementById('btn-resgatar-diario');
  btn.disabled = true;
  btn.textContent = "Resgatando...";
  btn.style.animation = "none";

  const nivelAtual = getNivelRecompensa(dailyStreakGlobal);
  const valorRecompensa = nivelAtual.valor;
  const novoStreak = dailyStreakGlobal + 1;

  try {
    const membroRef = doc(db, "membros", currentUser);
    
    // Atualiza no Firestore
    await updateDoc(membroRef, {
      moedas: increment(valorRecompensa),
      dailyRewardStreak: novoStreak,
      lastDailyRewardClaim: new Date()
    });

    // --- ATUALIZA√á√ÉO DO CACHE LOCAL (IMPORTANTE) ---
    const indexMembro = todosMembros.findIndex(m => m.nome === currentUser);
    if (indexMembro !== -1) {
        todosMembros[indexMembro].moedas = (todosMembros[indexMembro].moedas || 0) + valorRecompensa;
        todosMembros[indexMembro].dailyRewardStreak = novoStreak;
        todosMembros[indexMembro].lastDailyRewardClaim = new Date(); // Salva como objeto Date
    }
    // ----------------------------------------------

    // Atualiza estado local
    dailyStreakGlobal = novoStreak;
    dailyClaimedToday = true;

    // Efeitos
    dispararConfeteMoedas();
    tocarSom('som-conquista');
    atualizarInterfaceRecompensa();
    mostrarPopupMoedas(valorRecompensa);

    // Verifica se subiu de n√≠vel na tabela
    const novoNivel = getNivelRecompensa(novoStreak);
    if (novoNivel.min === novoStreak && novoStreak > 0) {
        // Subiu de n√≠vel!
        mostrarPopup("üéâ N√≠vel Aumentado!", `Sua sequ√™ncia evoluiu! Agora voc√™ ganha ${novoNivel.valor} moedas por dia!`, 5000);
        
        await adicionarEventoAoFeed(
            'medalha', // Usando tipo medalha para destaque dourado
            'üöÄ Evolu√ß√£o de Sequ√™ncia!',
            `<strong>${currentUser}</strong> atingiu uma sequ√™ncia de <strong>${novoStreak} dias</strong> e evoluiu para o pr√≥ximo n√≠vel de recompensas di√°rias!`,
            { nomeMembro: currentUser }
        );
    }

  } catch (error) {
    console.error("Erro ao resgatar recompensa di√°ria:", error);
    mostrarPopup("‚ùå Erro", "Falha ao resgatar. Tente novamente.", 4000);
    btn.disabled = false;
    btn.textContent = `Resgatar üí∞ ${nivelAtual.valor} Moedas`;
  }
}
window.resgatarRecompensaDiaria = resgatarRecompensaDiaria;

function dispararConfeteMoedas() {
  // 1. Cria√ß√£o do Canvas Principal
  const canvas = document.createElement('canvas');
  canvas.id = "moedas-confetti";
  canvas.style.position = "fixed";
  canvas.style.top = "0";
  canvas.style.left = "0";
  canvas.style.width = "100%";
  canvas.style.height = "100%";
  canvas.style.pointerEvents = "none";
  canvas.style.zIndex = "9999";
  document.body.appendChild(canvas);

  const ctx = canvas.getContext('2d');
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  // 2. OTIMIZA√á√ÉO: Cria um canvas "invis√≠vel" (Offscreen) para desenhar o emoji uma s√≥ vez
  const emojiCanvas = document.createElement('canvas');
  const size = 50; // Tamanho do emoji
  emojiCanvas.width = size;
  emojiCanvas.height = size;
  const emojiCtx = emojiCanvas.getContext('2d');
  emojiCtx.font = "35px Arial"; // Tamanho da fonte
  emojiCtx.textAlign = "center";
  emojiCtx.textBaseline = "middle";
  emojiCtx.fillText("üí∞", size / 2, size / 2); // Desenha no centro do canvas invis√≠vel

  // 3. Configura√ß√£o das Part√≠culas
  const particles = [];
  const particleCount = 50; // Quantidade de sacos de moeda

  for(let i=0; i < particleCount; i++) {
    particles.push({
      x: Math.random() * canvas.width,
      y: -50 - Math.random() * 500, // Come√ßam fora da tela, espalhados verticalmente
      speed: Math.random() * 4 + 3, // Velocidade de queda
      rotation: Math.random() * 360,
      rotationSpeed: (Math.random() - 0.5) * 5 // Rota√ß√£o aleat√≥ria (hor√°ria ou anti-hor√°ria)
    });
  }

  // 4. Loop de Anima√ß√£o
  function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    let active = 0;
    
    particles.forEach(p => {
      p.y += p.speed;
      p.rotation += p.rotationSpeed;

      // Desenha apenas se estiver vis√≠vel (Otimiza√ß√£o extra)
      if (p.y > -60 && p.y < canvas.height + 60) {
          ctx.save();
          ctx.translate(p.x, p.y);
          ctx.rotate(p.rotation * Math.PI / 180);
          
          // Em vez de desenhar texto (lento), desenha a imagem pr√©-renderizada (r√°pido)
          ctx.drawImage(emojiCanvas, -size / 2, -size / 2);
          
          ctx.restore();
      }

      if(p.y < canvas.height) active++;
    });

    if(active > 0) {
        requestAnimationFrame(animate);
    } else {
        canvas.remove();
    }
  }
  
  requestAnimationFrame(animate);
}

function popularTabelaNiveis() {
    const container = document.getElementById('lista-niveis-tabela');
    if(!container) return;
    
    container.innerHTML = '';
    
    NIVEIS_RECOMPENSA.forEach((nivel, index) => {
        const row = document.createElement('div');
        row.className = 'nivel-row';
        
        let rangeText = `${nivel.min} - ${nivel.max}`;
        if (nivel.max > 1000) rangeText = `${nivel.min}+`;
        
        row.innerHTML = `
            <div style="display:flex; align-items:center; gap:10px;">
                <span class="nivel-tag" style="background-color: ${nivel.cor}; color: ${nivel.textoCor}">N√≠vel ${index + 1}</span>
                <span>Sequ√™ncia: ${rangeText} dias</span>
            </div>
            <strong>${nivel.valor} üí∞</strong>
        `;
        container.appendChild(row);
    });
}

// --- L√ìGICA DE PROTE√á√ÉO DE SEQU√äNCIA ---

async function atualizarProgressoProtecao(tipoAcao, resourceId = null) { // Adicionado par√¢metro resourceId
    if (!currentUser) return;
    const membroRef = doc(db, "membros", currentUser);
    
    try {
        await runTransaction(db, async (transaction) => {
            const docSnap = await transaction.get(membroRef);
            if (!docSnap.exists()) return;
            
            const dados = docSnap.data();
            let protecao = dados.protecaoSoftBlock || { 
                postouMural: false, 
                comentouMural: false, 
                reacoesCount: 0, 
                apostouLoteria: false,
                protegidoAte: null,
                popupVisto: false,
                backupDate: null, // Novo campo para guardar a data antiga
                activeCommentId: null, // ID do coment√°rio que validou a tarefa
                activePostId: null // ID do post que validou a tarefa
            };

            const agora = new Date();
            const protegidoAte = protecao.protegidoAte ? protecao.protegidoAte.toDate() : null;
            
            // --- L√ìGICA DE RENOVA√á√ÉO ---
            let modoRenovacao = false;
            if (protegidoAte && protegidoAte > agora) {
                const umDiaEmMs = 24 * 60 * 60 * 1000;
                const tempoRestante = protegidoAte.getTime() - agora.getTime();
                
                // Se falta mais de 24h, sai e n√£o faz nada (j√° est√° protegido)
                if (tempoRestante > umDiaEmMs) return; 
                
                modoRenovacao = true;
                
                // Se vai renovar, limpa os IDs antigos para permitir novos
                const cicloAnteriorCompleto = protecao.postouMural && protecao.comentouMural && protecao.reacoesCount >= 5 && protecao.apostouLoteria;
                if (cicloAnteriorCompleto) {
                     protecao.postouMural = false;
                     protecao.comentouMural = false;
                     protecao.reacoesCount = 0;
                     protecao.apostouLoteria = false;
                     protecao.activeCommentId = null; // Limpa ID antigo
                     protecao.activePostId = null;    // Limpa ID antigo
                }
            }

            // --- ATUALIZA CONFORME A A√á√ÉO E SALVA O ID (CORRIGIDO) ---
            if (tipoAcao === 'postar') {
                // Salva se n√£o cumpriu OU se j√° cumpriu mas est√° sem ID salvo (corre√ß√£o de legado)
                if (!protecao.postouMural || (protecao.postouMural && !protecao.activePostId)) { 
                    protecao.postouMural = true;
                    if (resourceId) protecao.activePostId = resourceId; 
                }
            }
            if (tipoAcao === 'comentar') {
                // Salva se n√£o cumpriu OU se j√° cumpriu mas est√° sem ID salvo (corre√ß√£o de legado)
                if (!protecao.comentouMural || (protecao.comentouMural && !protecao.activeCommentId)) { 
                    protecao.comentouMural = true;
                    if (resourceId) protecao.activeCommentId = resourceId; 
                }
            }
            if (tipoAcao === 'reagir') protecao.reacoesCount = (protecao.reacoesCount || 0) + 1;
            if (tipoAcao === 'apostar') protecao.apostouLoteria = true;
            
            // Verifica se completou tudo
            if (protecao.postouMural && protecao.comentouMural && protecao.reacoesCount >= 5 && protecao.apostouLoteria) {
                
                // --- CORRE√á√ÉO DO BUG DE RESET DO TEMPO ---
                let novaDataFim = new Date();
                
                // Cen√°rio A: Recuperando uma prote√ß√£o quebrada (Backup existe e √© v√°lido)
                // Se existe backup e ele ainda est√° no futuro, restauramos ele
                const backupDate = protecao.backupDate ? protecao.backupDate.toDate() : null;
                
                if (backupDate && backupDate > agora && !modoRenovacao) {
                    novaDataFim = backupDate;
                    console.log("Prote√ß√£o restaurada usando data de backup (Anti-Exploit).");
                } 
                // Cen√°rio B: Renova√ß√£o ou Nova Prote√ß√£o
                else {
                    if (modoRenovacao && protegidoAte) {
                        novaDataFim.setTime(protegidoAte.getTime() + (4 * 24 * 60 * 60 * 1000));
                    } else {
                        novaDataFim.setDate(novaDataFim.getDate() + 4);
                    }
                }
                
                protecao.protegidoAte = novaDataFim;
                protecao.popupVisto = false; 
                protecao.backupDate = null; // Limpa o backup ap√≥s usar ou renovar
            }
            
            transaction.update(membroRef, { protecaoSoftBlock: protecao });
            
            const membroLocal = todosMembros.find(m => m.nome === currentUser);
            if (membroLocal) membroLocal.protecaoSoftBlock = protecao;
        });
        
        verificarEExibirSucessoProtecao();
        
    } catch (e) {
        console.error("Erro ao atualizar prote√ß√£o:", e);
    }
}

async function reverterProgressoProtecao(tipoAcao, resourceId = null) { // Adicionado par√¢metro resourceId
    if (!currentUser) return;
    const membroRef = doc(db, "membros", currentUser);
    
    try {
        await runTransaction(db, async (transaction) => {
            const docSnap = await transaction.get(membroRef);
            if (!docSnap.exists()) return;
            
            const dados = docSnap.data();
            let protecao = dados.protecaoSoftBlock || {};
            let mudouAlgo = false;

            // Remove o check conforme a a√ß√£o desfeita COM VERIFICA√á√ÉO ESTRITA DE ID
            if (tipoAcao === 'postar') {
                // CORRE√á√ÉO: S√≥ remove se o ID existir E for id√™ntico ao apagado.
                // Se activePostId for nulo (dado antigo), n√£o removemos para evitar injusti√ßas.
                if (protecao.activePostId && protecao.activePostId === resourceId) {
                    protecao.postouMural = false;
                    protecao.activePostId = null;
                    mudouAlgo = true;
                }
            }
            else if (tipoAcao === 'comentar') {
                // CORRE√á√ÉO: S√≥ remove se o ID existir E for id√™ntico ao apagado.
                if (protecao.activeCommentId && protecao.activeCommentId === resourceId) {
                    protecao.comentouMural = false;
                    protecao.activeCommentId = null;
                    mudouAlgo = true;
                }
            }
            else if (tipoAcao === 'reagir') {
                protecao.reacoesCount = Math.max(0, (protecao.reacoesCount || 0) - 1);
                mudouAlgo = true;
            }
            else if (tipoAcao === 'apostar') {
                protecao.apostouLoteria = false;
                mudouAlgo = true;
            }

            if (!mudouAlgo) return; // Se apagou um coment√°rio extra, n√£o faz nada.

            // --- L√ìGICA ANTI-CHEAT RIGOROSA (COM BACKUP) ---
            const requisitosAtendidos = 
                protecao.postouMural && 
                protecao.comentouMural && 
                (protecao.reacoesCount >= 5) && 
                protecao.apostouLoteria;

            if (!requisitosAtendidos) {
                // Se a prote√ß√£o estava ativa e vai cair, salvamos a data no backup
                if (protecao.protegidoAte) {
                    protecao.backupDate = protecao.protegidoAte; // Salva a data atual
                }
                
                protecao.protegidoAte = null;
                protecao.popupVisto = false;
                console.log(`Anti-Cheat: Prote√ß√£o pausada para ${currentUser}. Tempo salvo em backup.`);
            }
            
            transaction.update(membroRef, { protecaoSoftBlock: protecao });
            
            const membroLocal = todosMembros.find(m => m.nome === currentUser);
            if (membroLocal) membroLocal.protecaoSoftBlock = protecao;
        });

        verificarEExibirSucessoProtecao();

    } catch (e) {
        console.error("Erro ao reverter prote√ß√£o:", e);
    }
}

// Verifica e atualiza a UI do bot√£o e do modal
window.abrirModalProtecaoSequencia = function() {
    const membro = todosMembros.find(m => m.nome === currentUser);
    if (!membro) return;
    
    const dados = membro.protecaoSoftBlock || { reacoesCount: 0 };
    const agora = new Date();
    const protegidoAte = dados.protegidoAte ? (dados.protegidoAte.toDate ? dados.protegidoAte.toDate() : new Date(dados.protegidoAte)) : null;
    
    const estaProtegido = protegidoAte && protegidoAte > agora;
    
    // --- L√ìGICA DE RENOVA√á√ÉO (CORRIGIDA) ---
    let mostrarChecksDeProtecao = estaProtegido;
    let emModoRenovacao = false;
    
    if (estaProtegido) {
        const umDiaEmMs = 24 * 60 * 60 * 1000;
        const tempoRestante = protegidoAte.getTime() - agora.getTime();
        
        if (tempoRestante < umDiaEmMs) {
            // Entrou na janela de renova√ß√£o
            mostrarChecksDeProtecao = false; 
            emModoRenovacao = true;
        }
    }
    
    // --- CORRE√á√ÉO DO BUG VISUAL ---
    // Verifica se os dados no banco ainda refletem o ciclo anterior completo
    const cicloAnteriorCompleto = dados.postouMural && dados.comentouMural && (dados.reacoesCount >= 5) && dados.apostouLoteria;
    
    // Se estamos em renova√ß√£o E o banco diz que tudo est√° feito, √© porque o usu√°rio 
    // ainda n√£o fez a primeira a√ß√£o para resetar. Ent√£o, visualmente, for√ßamos 'false'.
    let visualPostou = dados.postouMural;
    let visualComentou = dados.comentouMural;
    let visualApostou = dados.apostouLoteria;
    let visualReacoes = dados.reacoesCount || 0;

    if (emModoRenovacao && cicloAnteriorCompleto) {
        visualPostou = false;
        visualComentou = false;
        visualApostou = false;
        visualReacoes = 0;
    }
    // -----------------------------
    
    // Atualiza Visual do Modal usando as vari√°veis visuais corrigidas
    document.getElementById('task-postar-mural').innerHTML = 
        `<span class="task-status">${visualPostou || mostrarChecksDeProtecao ? '‚úÖ' : '‚¨ú'}</span> <span class="task-desc">Postar uma mensagem no Mural</span>`;
    
    document.getElementById('task-comentar-mural').innerHTML = 
        `<span class="task-status">${visualComentou || mostrarChecksDeProtecao ? '‚úÖ' : '‚¨ú'}</span> <span class="task-desc">Comentar em uma mensagem</span>`;
    
    const reactCountDisplay = Math.min(visualReacoes, 5);
    document.getElementById('task-reagir').innerHTML = 
        `<span class="task-status">${visualReacoes >= 5 || mostrarChecksDeProtecao ? '‚úÖ' : '‚¨ú'}</span> <span class="task-desc">Reagir a 5 conte√∫dos (Mural/Feed) <span id="task-reagir-count">(${reactCountDisplay}/5)</span></span>`;
        
    document.getElementById('task-apostar').innerHTML = 
        `<span class="task-status">${visualApostou || mostrarChecksDeProtecao ? '‚úÖ' : '‚¨ú'}</span> <span class="task-desc">Fazer uma aposta na Loteria</span>`;

    const statusMsg = document.getElementById('protecao-status-msg');
    if (estaProtegido) {
        // Se estiver no modo renova√ß√£o, avisa o usu√°rio
        if (emModoRenovacao) {
             statusMsg.innerHTML = `‚ö†Ô∏è RENOVA√á√ÉO DISPON√çVEL!<br>Complete as tarefas novamente para estender sua prote√ß√£o.`;
             statusMsg.style.color = "#e67e22"; // Laranja
        } else {
             statusMsg.textContent = `üõ°Ô∏è VOC√ä EST√Å PROTEGIDO AT√â ${protegidoAte.toLocaleDateString('pt-BR')}!`;
             statusMsg.style.color = "#f1c40f"; // Dourado
        }
    } else {
        statusMsg.textContent = "Complete as tarefas para ativar o escudo.";
        statusMsg.style.color = "#7f8c8d";
    }

    openModal('modal-protecao-sequencia');
}

async function verificarEExibirSucessoProtecao() {
    const membro = todosMembros.find(m => m.nome === currentUser);
    if (!membro || !membro.protecaoSoftBlock) return;
    
    const dados = membro.protecaoSoftBlock;
    const agora = new Date();
    const protegidoAte = dados.protegidoAte ? (dados.protegidoAte.toDate ? dados.protegidoAte.toDate() : new Date(dados.protegidoAte)) : null;

    const btn = document.getElementById('btn-protecao-sequencia');
    const estaProtegido = protegidoAte && protegidoAte > agora;
    
    // --- L√ìGICA DO BOT√ÉO (Visual) ---
    if (estaProtegido) {
        if (btn) {
            btn.classList.add('protegido');
            btn.innerHTML = "üõ°Ô∏è Sequ√™ncia Protegida";
        }
    } else {
        if (btn) {
            btn.classList.remove('protegido');
            btn.innerHTML = "üõ°Ô∏è Proteja sua Sequ√™ncia";
        }
    }

    if (!estaProtegido) return; // Se n√£o est√° protegido, n√£o precisa de avisos

    const umDiaEmMs = 24 * 60 * 60 * 1000; // 24 horas em milissegundos
    const tempoRestante = protegidoAte.getTime() - agora.getTime();
    
    // --- CEN√ÅRIO 1: POPUP DE SUCESSO (Quando acaba de completar) ---
    if (dados.popupVisto === false) {
        mostrarCardPopup(
            "üõ°Ô∏è Sequ√™ncia Protegida!", 
            "Voc√™ completou todas as tarefas! <br><br>Agora voc√™ est√° imune √† maldi√ß√£o da Runa do Soft Block pelos pr√≥ximos <strong>4 dias</strong>. Parab√©ns pela dedica√ß√£o!",
            dispararConfete
        );
        tocarSom('som-conquista');

        try {
            const membroRef = doc(db, "membros", currentUser);
            await updateDoc(membroRef, { "protecaoSoftBlock.popupVisto": true });
            dados.popupVisto = true; 
        } catch(e) {
            console.error("Erro ao marcar popup de prote√ß√£o como visto:", e);
        }
        return; // Prioridade para o sucesso, n√£o mostra aviso de renova√ß√£o agora
    }

    // --- CEN√ÅRIO 2: AVISO DE RENOVA√á√ÉO (√öltimas 24h) ---
    // Esta √© a parte que voc√™ mencionou que estava faltando
    if (tempoRestante < umDiaEmMs) {
        // Removida a verifica√ß√£o de sessionStorage para usar o sistema do bot√£o
        
        mostrarCardPopup(
            "‚ö†Ô∏è Prote√ß√£o Expirando!", 
            `Sua prote√ß√£o contra a maldi√ß√£o do Soft Block acaba em menos de 24 horas.<br><br>Voc√™ j√° pode realizar as tarefas novamente agora para <strong>estender sua prote√ß√£o</strong> por mais 4 dias sem perder o escudo atual!`,
            null,
            "Grupo √âpicos",
            "aviso_renovacao_protecao" // ID √önico adicionado
        );
    }
}

// Chame esta fun√ß√£o no login para configurar o bot√£o corretamente
function inicializarEstadoProtecao() {
    verificarEExibirSucessoProtecao();
}

window.onload = async () => {

  // 1. Inicializa elementos essenciais
  initAuth();
  setupMaintenanceListenerAndCheck();
  setupAdminBackdoor();

  // --- CORRE√á√ÉO: INICIA A IA AQUI DENTRO ---
  console.log("Iniciando Or√°culo e carregando dados...");
  // O await aqui √© seguro pois est√° dentro de uma fun√ß√£o async
  await inicializarGemini(); 
  carregarBaseDeConhecimento();
  configurarEventosChat();
  // -----------------------------------------

  // 2. VERIFICA O MODO MANUTEN√á√ÉO
  const isManutencaoAtiva = await verificarEstadoManutencaoInicial();

  if (isManutencaoAtiva) {
    console.log("Modo de Manuten√ß√£o ATIVO. Bloqueado.");
    document.getElementById('maintenance-overlay').classList.remove('hidden');
    document.body.style.overflow = 'hidden';
    return; 
  }

  // 3. Se n√£o estiver em manuten√ß√£o, verifica login
  const rememberedUser = localStorage.getItem('loggedInUser');
  if (rememberedUser) {
    await performSuccessfulLogin(rememberedUser);
  } else {
    authContainer.classList.remove('hidden');
    // Configura o fundo da tela de login
    dataAtual = getHojeISO();
    const hora = new Date().getHours();
    const body = document.body;
    body.classList.remove("tema-manha", "tema-tarde", "tema-noite");
    if (hora >= 5 && hora < 12) body.classList.add("tema-manha");
    else if (hora >= 12 && hora < 18) body.classList.add("tema-tarde");
    else body.classList.add("tema-noite");
  }

  // 4. Inicia Rel√≥gio e Verifica√ß√µes
  atualizarRelogio();
  setInterval(atualizarRelogio, 1000);
  setInterval(verificarMudancaData, 60000);
  window.addEventListener('focus', verificarMudancaData);

  // Garante sincroniza√ß√£o ao voltar para a aba
  document.addEventListener("visibilitychange", async () => {
    if (document.visibilityState === 'visible') {
      console.log("üëÄ Aba ativa. Re-sincronizando hor√°rio...");
      const relogioEl = document.getElementById('relogio');
      if(relogioEl) relogioEl.style.color = '#f39c12'; // Laranja = Atualizando
      try { await sincronizarHorarioBrasilia(); } catch(e) { console.log("Sem rede."); }
      if(relogioEl) relogioEl.style.color = ''; // Normal
      await verificarMudancaData(); 
    }
  });

  // Exposi√ß√£o Global de Fun√ß√µes
  window.abrirDetalhesMedalha = abrirDetalhesMedalha;
  window.handleQueroEssa = handleQueroEssa; 
  window.abrirModalCompraMedalha = abrirModalCompraMedalha; 
  window.abrirModalOrdenarMedalhas = abrirModalOrdenarMedalhas; 
  window.mudarPaginaMedalhas = mudarPaginaMedalhas; 
  window.processarJurosEAutolimpezaBancos = processarJurosEAutolimpezaBancos;
};